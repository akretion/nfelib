#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Sep 23 18:59:20 2019 by generateDS.py version 2.29.3.
# Python 3.7.3 (default, Jun 24 2019, 04:54:02)  [GCC 9.1.0]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('--use-getter-setter', 'none')
#   ('-f', '')
#   ('-o', '/home/mileo/PycharmProjects/generateds/nfelib/nfelib/v4_00/retConsReciNFe.py')
#
# Command line arguments:
#   -
#
# Command line:
#   /home/mileo/PycharmProjects/generateds/generateds/generateDS.py --no-namespace-defs --use-getter-setter="none" -f -o "/home/mileo/PycharmProjects/generateds/nfelib/nfelib/v4_00/retConsReciNFe.py" -
#
# Current working directory (os.getcwd()):
#   v4_00
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
                 optional=0, child_attrs=None, choice=None,
                 documentation=""):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
        self.documentation = documentation
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional
    def get_documentation(self): return self.documentation


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class TNFe(GeneratedsSuper):
    """Tipo Nota Fiscal Eletrônica"""
    subclass = None
    superclass = None
    def __init__(self, infNFe=None, infNFeSupl=None, Signature=None):
        self.original_tagname_ = None
        self.infNFe = infNFe
        self.infNFeSupl = infNFeSupl
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TNFe.subclass:
            return TNFe.subclass(*args_, **kwargs_)
        else:
            return TNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.infNFe is not None or
            self.infNFeSupl is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TNFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TNFe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infNFe is not None:
            self.infNFe.export(outfile, level, namespace_, name_='infNFe', pretty_print=pretty_print)
        if self.infNFeSupl is not None:
            self.infNFeSupl.export(outfile, level, namespace_, name_='infNFeSupl', pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespace_='ds:', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infNFe':
            obj_ = infNFeType.factory()
            obj_.build(child_)
            self.infNFe = obj_
            obj_.original_tagname_ = 'infNFe'
        elif nodeName_ == 'infNFeSupl':
            obj_ = infNFeSuplType.factory()
            obj_.build(child_)
            self.infNFeSupl = obj_
            obj_.original_tagname_ = 'infNFeSupl'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TNFe


class TProtNFe(GeneratedsSuper):
    """Tipo Protocolo de status resultado do processamento da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, infProt=None, Signature=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.infProt = infProt
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TProtNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TProtNFe.subclass:
            return TProtNFe.subclass(*args_, **kwargs_)
        else:
            return TProtNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]
    def hasContent_(self):
        if (
            self.infProt is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TProtNFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TProtNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TProtNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TProtNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TProtNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TProtNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infProt is not None:
            self.infProt.export(outfile, level, namespace_, name_='infProt', pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespace_='ds:', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infProt':
            obj_ = infProtType.factory()
            obj_.build(child_)
            self.infProt = obj_
            obj_.original_tagname_ = 'infProt'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TProtNFe


class TEnviNFe(GeneratedsSuper):
    """Tipo Pedido de Concessão de Autorização da Nota Fiscal Eletrônica"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, idLote=None, indSinc=None, NFe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.idLote = idLote
        self.validate_TIdLote(self.idLote)
        self.indSinc = indSinc
        self.validate_indSincType(self.indSinc)
        if NFe is None:
            self.NFe = []
        else:
            self.NFe = NFe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnviNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnviNFe.subclass:
            return TEnviNFe.subclass(*args_, **kwargs_)
        else:
            return TEnviNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TIdLote(self, value):
        # Validate type TIdLote, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TIdLote_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIdLote_patterns_, ))
    validate_TIdLote_patterns_ = [['^[0-9]{1,15}$']]
    def validate_indSincType(self, value):
        # Validate type indSincType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indSincType' % {"value" : value.encode("utf-8")} )
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]
    def hasContent_(self):
        if (
            self.idLote is not None or
            self.indSinc is not None or
            self.NFe
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEnviNFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnviNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEnviNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEnviNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEnviNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TEnviNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.idLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<idLote>%s</idLote>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.idLote), input_name='idLote')), eol_))
        if self.indSinc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indSinc>%s</indSinc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indSinc), input_name='indSinc')), eol_))
        for NFe_ in self.NFe:
            NFe_.export(outfile, level, namespace_, name_='NFe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'idLote':
            idLote_ = child_.text
            idLote_ = self.gds_validate_string(idLote_, node, 'idLote')
            self.idLote = idLote_
            # validate type TIdLote
            self.validate_TIdLote(self.idLote)
        elif nodeName_ == 'indSinc':
            indSinc_ = child_.text
            indSinc_ = self.gds_validate_string(indSinc_, node, 'indSinc')
            self.indSinc = indSinc_
            # validate type indSincType
            self.validate_indSincType(self.indSinc)
        elif nodeName_ == 'NFe':
            obj_ = TNFe.factory()
            obj_.build(child_)
            self.NFe.append(obj_)
            obj_.original_tagname_ = 'NFe'
# end class TEnviNFe


class TRetEnviNFe(GeneratedsSuper):
    """Tipo Retorno do Pedido de Autorização da Nota Fiscal Eletrônica"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, verAplic=None, cStat=None, xMotivo=None, cUF=None, dhRecbto=None, infRec=None, protNFe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.infRec = infRec
        self.protNFe = protNFe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetEnviNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetEnviNFe.subclass:
            return TRetEnviNFe.subclass(*args_, **kwargs_)
        else:
            return TRetEnviNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {"value" : value.encode("utf-8")} )
    def validate_TVerAplic(self, value):
        # Validate type TVerAplic, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TVerAplic' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TVerAplic' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerAplic_patterns_, ))
    validate_TVerAplic_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TStat(self, value):
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TStat' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TStat_patterns_, ))
    validate_TStat_patterns_ = [['^[0-9]{3}$']]
    def validate_TMotivo(self, value):
        # Validate type TMotivo, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TMotivo' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TMotivo' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TMotivo_patterns_, ))
    validate_TMotivo_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))T(20$|^21$|^22$|^23$|^[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]$|^10$|^11):00$|^([\\+](12):00))$']]
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.cUF is not None or
            self.dhRecbto is not None or
            self.infRec is not None or
            self.protNFe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TRetEnviNFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetEnviNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TRetEnviNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TRetEnviNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TRetEnviNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TRetEnviNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpAmb>%s</tpAmb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<verAplic>%s</verAplic>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cStat>%s</cStat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMotivo>%s</xMotivo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), eol_))
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cUF>%s</cUF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dhRecbto>%s</dhRecbto>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), eol_))
        if self.infRec is not None:
            self.infRec.export(outfile, level, namespace_, name_='infRec', pretty_print=pretty_print)
        if self.protNFe is not None:
            self.protNFe.export(outfile, level, namespace_, name_='protNFe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'dhRecbto':
            dhRecbto_ = child_.text
            dhRecbto_ = self.gds_validate_string(dhRecbto_, node, 'dhRecbto')
            self.dhRecbto = dhRecbto_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'infRec':
            obj_ = infRecType.factory()
            obj_.build(child_)
            self.infRec = obj_
            obj_.original_tagname_ = 'infRec'
        elif nodeName_ == 'protNFe':
            obj_ = TProtNFe.factory()
            obj_.build(child_)
            self.protNFe = obj_
            obj_.original_tagname_ = 'protNFe'
# end class TRetEnviNFe


class TConsReciNFe(GeneratedsSuper):
    """Tipo Pedido de Consulta do Recido do Lote de Notas Fiscais Eletrônicas"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, nRec=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.nRec = nRec
        self.validate_TRec(self.nRec)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TConsReciNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TConsReciNFe.subclass:
            return TConsReciNFe.subclass(*args_, **kwargs_)
        else:
            return TConsReciNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {"value" : value.encode("utf-8")} )
    def validate_TRec(self, value):
        # Validate type TRec, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TRec' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TRec_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TRec_patterns_, ))
    validate_TRec_patterns_ = [['^[0-9]{15}$']]
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.nRec is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TConsReciNFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TConsReciNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TConsReciNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TConsReciNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TConsReciNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TConsReciNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpAmb>%s</tpAmb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), eol_))
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nRec>%s</nRec>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nRec), input_name='nRec')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
            # validate type TRec
            self.validate_TRec(self.nRec)
# end class TConsReciNFe


class TRetConsReciNFe(GeneratedsSuper):
    """Tipo Retorno do Pedido de  Consulta do Recido do Lote de Notas Fiscais
    Eletrônicas"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, verAplic=None, nRec=None, cStat=None, xMotivo=None, cUF=None, dhRecbto=None, cMsg=None, xMsg=None, protNFe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.nRec = nRec
        self.validate_TRec(self.nRec)
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.cMsg = cMsg
        self.validate_cMsgType53(self.cMsg)
        self.xMsg = xMsg
        self.validate_xMsgType54(self.xMsg)
        if protNFe is None:
            self.protNFe = []
        else:
            self.protNFe = protNFe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetConsReciNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetConsReciNFe.subclass:
            return TRetConsReciNFe.subclass(*args_, **kwargs_)
        else:
            return TRetConsReciNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {"value" : value.encode("utf-8")} )
    def validate_TVerAplic(self, value):
        # Validate type TVerAplic, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TVerAplic' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TVerAplic' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerAplic_patterns_, ))
    validate_TVerAplic_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TRec(self, value):
        # Validate type TRec, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TRec' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TRec_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TRec_patterns_, ))
    validate_TRec_patterns_ = [['^[0-9]{15}$']]
    def validate_TStat(self, value):
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TStat' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TStat_patterns_, ))
    validate_TStat_patterns_ = [['^[0-9]{3}$']]
    def validate_TMotivo(self, value):
        # Validate type TMotivo, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TMotivo' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TMotivo' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TMotivo_patterns_, ))
    validate_TMotivo_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))T(20$|^21$|^22$|^23$|^[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]$|^10$|^11):00$|^([\\+](12):00))$']]
    def validate_cMsgType53(self, value):
        # Validate type cMsgType53, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cMsgType53_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cMsgType53_patterns_, ))
    validate_cMsgType53_patterns_ = [['^[0-9]{1,4}$']]
    def validate_xMsgType54(self, value):
        # Validate type xMsgType54, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 200:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMsgType54' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMsgType54' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMsgType54_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMsgType54_patterns_, ))
    validate_xMsgType54_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.nRec is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.cUF is not None or
            self.dhRecbto is not None or
            self.cMsg is not None or
            self.xMsg is not None or
            self.protNFe
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TRetConsReciNFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetConsReciNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TRetConsReciNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TRetConsReciNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TRetConsReciNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TRetConsReciNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpAmb>%s</tpAmb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<verAplic>%s</verAplic>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), eol_))
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nRec>%s</nRec>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nRec), input_name='nRec')), eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cStat>%s</cStat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMotivo>%s</xMotivo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), eol_))
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cUF>%s</cUF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dhRecbto>%s</dhRecbto>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), eol_))
        if self.cMsg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMsg>%s</cMsg>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMsg), input_name='cMsg')), eol_))
        if self.xMsg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMsg>%s</xMsg>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMsg), input_name='xMsg')), eol_))
        for protNFe_ in self.protNFe:
            protNFe_.export(outfile, level, namespace_, name_='protNFe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
            # validate type TRec
            self.validate_TRec(self.nRec)
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'dhRecbto':
            dhRecbto_ = child_.text
            dhRecbto_ = self.gds_validate_string(dhRecbto_, node, 'dhRecbto')
            self.dhRecbto = dhRecbto_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'cMsg':
            cMsg_ = child_.text
            cMsg_ = self.gds_validate_string(cMsg_, node, 'cMsg')
            self.cMsg = cMsg_
            # validate type cMsgType53
            self.validate_cMsgType53(self.cMsg)
        elif nodeName_ == 'xMsg':
            xMsg_ = child_.text
            xMsg_ = self.gds_validate_string(xMsg_, node, 'xMsg')
            self.xMsg = xMsg_
            # validate type xMsgType54
            self.validate_xMsgType54(self.xMsg)
        elif nodeName_ == 'protNFe':
            obj_ = TProtNFe.factory()
            obj_.build(child_)
            self.protNFe.append(obj_)
            obj_.original_tagname_ = 'protNFe'
# end class TRetConsReciNFe


class TNfeProc(GeneratedsSuper):
    """Tipo da NF-e processada"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, NFe=None, protNFe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.NFe = NFe
        self.protNFe = protNFe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TNfeProc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TNfeProc.subclass:
            return TNfeProc.subclass(*args_, **kwargs_)
        else:
            return TNfeProc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]
    def hasContent_(self):
        if (
            self.NFe is not None or
            self.protNFe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TNfeProc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TNfeProc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TNfeProc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TNfeProc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TNfeProc'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TNfeProc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NFe is not None:
            self.NFe.export(outfile, level, namespace_, name_='NFe', pretty_print=pretty_print)
        if self.protNFe is not None:
            self.protNFe.export(outfile, level, namespace_, name_='protNFe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NFe':
            obj_ = TNFe.factory()
            obj_.build(child_)
            self.NFe = obj_
            obj_.original_tagname_ = 'NFe'
        elif nodeName_ == 'protNFe':
            obj_ = TProtNFe.factory()
            obj_.build(child_)
            self.protNFe = obj_
            obj_.original_tagname_ = 'protNFe'
# end class TNfeProc


class TEndereco(GeneratedsSuper):
    """Tipo Dados do Endereço  // 24/10/08 - tamanho mínimo"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, UF=None, CEP=None, cPais=None, xPais=None, fone=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.validate_xLgrType(self.xLgr)
        self.nro = nro
        self.validate_nroType(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType55(self.xMun)
        self.UF = UF
        self.validate_TUf(self.UF)
        self.CEP = CEP
        self.validate_CEPType(self.CEP)
        self.cPais = cPais
        self.validate_cPaisType56(self.cPais)
        self.xPais = xPais
        self.validate_xPaisType(self.xPais)
        self.fone = fone
        self.validate_foneType57(self.fone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndereco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndereco.subclass:
            return TEndereco.subclass(*args_, **kwargs_)
        else:
            return TEndereco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_xLgrType(self, value):
        # Validate type xLgrType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType_patterns_, ))
    validate_xLgrType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nroType(self, value):
        # Validate type nroType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType_patterns_, ))
    validate_nroType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xCplType(self, value):
        # Validate type xCplType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType_patterns_, ))
    validate_xCplType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xBairroType(self, value):
        # Validate type xBairroType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType_patterns_, ))
    validate_xBairroType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunType55(self, value):
        # Validate type xMunType55, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType55' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType55' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType55_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType55_patterns_, ))
    validate_xMunType55_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def validate_CEPType(self, value):
        # Validate type CEPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CEPType_patterns_, ))
    validate_CEPType_patterns_ = [['^[0-9]{8}$']]
    def validate_cPaisType56(self, value):
        # Validate type cPaisType56, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType56_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cPaisType56_patterns_, ))
    validate_cPaisType56_patterns_ = [['^[0-9]{1,4}$']]
    def validate_xPaisType(self, value):
        # Validate type xPaisType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xPaisType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xPaisType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xPaisType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xPaisType_patterns_, ))
    validate_xPaisType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_foneType57(self, value):
        # Validate type foneType57, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType57_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_foneType57_patterns_, ))
    validate_foneType57_patterns_ = [['^[0-9]{6,14}$']]
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None or
            self.CEP is not None or
            self.cPais is not None or
            self.xPais is not None or
            self.fone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndereco', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndereco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndereco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndereco', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndereco'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndereco', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLgr>%s</xLgr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nro>%s</nro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xCpl>%s</xCpl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xBairro>%s</xBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMun>%s</cMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMun>%s</xMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CEP>%s</CEP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cPais>%s</cPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), eol_))
        if self.xPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xPais>%s</xPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xPais), input_name='xPais')), eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fone>%s</fone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType
            self.validate_xLgrType(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType
            self.validate_nroType(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType
            self.validate_xCplType(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType
            self.validate_xBairroType(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType55
            self.validate_xMunType55(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType
            self.validate_CEPType(self.CEP)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType56
            self.validate_cPaisType56(self.cPais)
        elif nodeName_ == 'xPais':
            xPais_ = child_.text
            xPais_ = self.gds_validate_string(xPais_, node, 'xPais')
            self.xPais = xPais_
            # validate type xPaisType
            self.validate_xPaisType(self.xPais)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType57
            self.validate_foneType57(self.fone)
# end class TEndereco


class TEnderEmi(GeneratedsSuper):
    """Tipo Dados do Endereço do Emitente  // 24/10/08 - desmembrado / tamanho
    mínimo"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, UF=None, CEP=None, cPais=None, xPais=None, fone=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.validate_xLgrType58(self.xLgr)
        self.nro = nro
        self.validate_nroType59(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType60(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType61(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType62(self.xMun)
        self.UF = UF
        self.validate_TUfEmi(self.UF)
        self.CEP = CEP
        self.validate_CEPType63(self.CEP)
        self.cPais = cPais
        self.validate_cPaisType64(self.cPais)
        self.xPais = xPais
        self.validate_xPaisType65(self.xPais)
        self.fone = fone
        self.validate_foneType66(self.fone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnderEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnderEmi.subclass:
            return TEnderEmi.subclass(*args_, **kwargs_)
        else:
            return TEnderEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_xLgrType58(self, value):
        # Validate type xLgrType58, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType58' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType58' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType58_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType58_patterns_, ))
    validate_xLgrType58_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nroType59(self, value):
        # Validate type nroType59, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType59' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType59' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType59_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType59_patterns_, ))
    validate_nroType59_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xCplType60(self, value):
        # Validate type xCplType60, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType60' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType60' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType60_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType60_patterns_, ))
    validate_xCplType60_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xBairroType61(self, value):
        # Validate type xBairroType61, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType61' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType61' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType61_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType61_patterns_, ))
    validate_xBairroType61_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunType62(self, value):
        # Validate type xMunType62, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType62' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType62' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType62_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType62_patterns_, ))
    validate_xMunType62_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {"value" : value.encode("utf-8")} )
    def validate_CEPType63(self, value):
        # Validate type CEPType63, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType63_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CEPType63_patterns_, ))
    validate_CEPType63_patterns_ = [['^[0-9]{8}$']]
    def validate_cPaisType64(self, value):
        # Validate type cPaisType64, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1058']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cPaisType64' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType64_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cPaisType64_patterns_, ))
    validate_cPaisType64_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xPaisType65(self, value):
        # Validate type xPaisType65, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Brasil', 'BRASIL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on xPaisType65' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xPaisType65_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xPaisType65_patterns_, ))
    validate_xPaisType65_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_foneType66(self, value):
        # Validate type foneType66, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType66_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_foneType66_patterns_, ))
    validate_foneType66_patterns_ = [['^[0-9]{6,14}$']]
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None or
            self.CEP is not None or
            self.cPais is not None or
            self.xPais is not None or
            self.fone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEnderEmi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnderEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEnderEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEnderEmi', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEnderEmi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEnderEmi', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLgr>%s</xLgr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nro>%s</nro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xCpl>%s</xCpl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xBairro>%s</xBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMun>%s</cMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMun>%s</xMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CEP>%s</CEP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cPais>%s</cPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), eol_))
        if self.xPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xPais>%s</xPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xPais), input_name='xPais')), eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fone>%s</fone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType58
            self.validate_xLgrType58(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType59
            self.validate_nroType59(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType60
            self.validate_xCplType60(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType61
            self.validate_xBairroType61(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType62
            self.validate_xMunType62(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UF)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType63
            self.validate_CEPType63(self.CEP)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType64
            self.validate_cPaisType64(self.cPais)
        elif nodeName_ == 'xPais':
            xPais_ = child_.text
            xPais_ = self.gds_validate_string(xPais_, node, 'xPais')
            self.xPais = xPais_
            # validate type xPaisType65
            self.validate_xPaisType65(self.xPais)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType66
            self.validate_foneType66(self.fone)
# end class TEnderEmi


class TLocal(GeneratedsSuper):
    """Tipo Dados do Local de Retirada ou Entrega // 24/10/08 - tamanho mínimo
    // v2.0"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xNome=None, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, UF=None, CEP=None, cPais=None, xPais=None, fone=None, email=None, IE=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.xNome = xNome
        self.validate_xNomeType67(self.xNome)
        self.xLgr = xLgr
        self.validate_xLgrType68(self.xLgr)
        self.nro = nro
        self.validate_nroType69(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType70(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType71(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType72(self.xMun)
        self.UF = UF
        self.validate_TUf(self.UF)
        self.CEP = CEP
        self.validate_CEPType73(self.CEP)
        self.cPais = cPais
        self.validate_cPaisType74(self.cPais)
        self.xPais = xPais
        self.validate_xPaisType75(self.xPais)
        self.fone = fone
        self.validate_foneType76(self.fone)
        self.email = email
        self.validate_emailType77(self.email)
        self.IE = IE
        self.validate_TIe(self.IE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TLocal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TLocal.subclass:
            return TLocal.subclass(*args_, **kwargs_)
        else:
            return TLocal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TCnpjOpc(self, value):
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpjOpc' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpjOpc_patterns_, ))
    validate_TCnpjOpc_patterns_ = [['^[0-9]{0}$|^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def validate_xNomeType67(self, value):
        # Validate type xNomeType67, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeType67' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeType67' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType67_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeType67_patterns_, ))
    validate_xNomeType67_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xLgrType68(self, value):
        # Validate type xLgrType68, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType68' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType68' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType68_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType68_patterns_, ))
    validate_xLgrType68_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nroType69(self, value):
        # Validate type nroType69, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType69' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType69' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType69_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType69_patterns_, ))
    validate_nroType69_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xCplType70(self, value):
        # Validate type xCplType70, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType70' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType70' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType70_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType70_patterns_, ))
    validate_xCplType70_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xBairroType71(self, value):
        # Validate type xBairroType71, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType71' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType71' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType71_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType71_patterns_, ))
    validate_xBairroType71_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunType72(self, value):
        # Validate type xMunType72, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType72' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType72' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType72_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType72_patterns_, ))
    validate_xMunType72_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def validate_CEPType73(self, value):
        # Validate type CEPType73, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType73_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CEPType73_patterns_, ))
    validate_CEPType73_patterns_ = [['^[0-9]{8}$']]
    def validate_cPaisType74(self, value):
        # Validate type cPaisType74, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType74_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cPaisType74_patterns_, ))
    validate_cPaisType74_patterns_ = [['^[0-9]{1,4}$']]
    def validate_xPaisType75(self, value):
        # Validate type xPaisType75, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xPaisType75' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xPaisType75' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xPaisType75_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xPaisType75_patterns_, ))
    validate_xPaisType75_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_foneType76(self, value):
        # Validate type foneType76, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType76_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_foneType76_patterns_, ))
    validate_foneType76_patterns_ = [['^[0-9]{6,14}$']]
    def validate_emailType77(self, value):
        # Validate type emailType77, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on emailType77' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on emailType77' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType77_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_emailType77_patterns_, ))
    validate_emailType77_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TIe(self, value):
        # Validate type TIe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TIe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TIe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIe_patterns_, ))
    validate_TIe_patterns_ = [['^[0-9]{2,14}$|^ISENTO$']]
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None or
            self.CEP is not None or
            self.cPais is not None or
            self.xPais is not None or
            self.fone is not None or
            self.email is not None or
            self.IE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TLocal', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TLocal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TLocal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TLocal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TLocal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TLocal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNome>%s</xNome>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), eol_))
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLgr>%s</xLgr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nro>%s</nro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xCpl>%s</xCpl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xBairro>%s</xBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMun>%s</cMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMun>%s</xMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CEP>%s</CEP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cPais>%s</cPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), eol_))
        if self.xPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xPais>%s</xPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xPais), input_name='xPais')), eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fone>%s</fone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), eol_))
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<email>%s</email>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IE>%s</IE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType67
            self.validate_xNomeType67(self.xNome)
        elif nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType68
            self.validate_xLgrType68(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType69
            self.validate_nroType69(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType70
            self.validate_xCplType70(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType71
            self.validate_xBairroType71(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType72
            self.validate_xMunType72(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType73
            self.validate_CEPType73(self.CEP)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType74
            self.validate_cPaisType74(self.cPais)
        elif nodeName_ == 'xPais':
            xPais_ = child_.text
            xPais_ = self.gds_validate_string(xPais_, node, 'xPais')
            self.xPais = xPais_
            # validate type xPaisType75
            self.validate_xPaisType75(self.xPais)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType76
            self.validate_foneType76(self.fone)
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            # validate type emailType77
            self.validate_emailType77(self.email)
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIe
            self.validate_TIe(self.IE)
# end class TLocal


class TInfRespTec(GeneratedsSuper):
    """Grupo de informações do responsável técnico pelo sistema de emissão de
    DF-e"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, xContato=None, email=None, fone=None, idCSRT=None, hashCSRT=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.xContato = xContato
        self.validate_xContatoType(self.xContato)
        self.email = email
        self.validate_emailType78(self.email)
        self.fone = fone
        self.validate_foneType79(self.fone)
        self.idCSRT = idCSRT
        self.validate_idCSRTType(self.idCSRT)
        self.hashCSRT = hashCSRT
        self.validate_hashCSRTType(self.hashCSRT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TInfRespTec)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TInfRespTec.subclass:
            return TInfRespTec.subclass(*args_, **kwargs_)
        else:
            return TInfRespTec(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TCnpjOpc(self, value):
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpjOpc' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpjOpc_patterns_, ))
    validate_TCnpjOpc_patterns_ = [['^[0-9]{0}$|^[0-9]{14}$']]
    def validate_xContatoType(self, value):
        # Validate type xContatoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xContatoType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xContatoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xContatoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xContatoType_patterns_, ))
    validate_xContatoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_emailType78(self, value):
        # Validate type emailType78, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on emailType78' % {"value" : value} )
            if len(str(value)) < 6:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on emailType78' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType78_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_emailType78_patterns_, ))
    validate_emailType78_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_foneType79(self, value):
        # Validate type foneType79, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType79_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_foneType79_patterns_, ))
    validate_foneType79_patterns_ = [['^[0-9]{6,14}$']]
    def validate_idCSRTType(self, value):
        # Validate type idCSRTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_idCSRTType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_idCSRTType_patterns_, ))
    validate_idCSRTType_patterns_ = [['^[0-9]{2}$']]
    def validate_hashCSRTType(self, value):
        # Validate type hashCSRTType, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 20:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on hashCSRTType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.xContato is not None or
            self.email is not None or
            self.fone is not None or
            self.idCSRT is not None or
            self.hashCSRT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TInfRespTec', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TInfRespTec')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TInfRespTec')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TInfRespTec', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TInfRespTec'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TInfRespTec', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.xContato is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xContato>%s</xContato>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xContato), input_name='xContato')), eol_))
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<email>%s</email>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fone>%s</fone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), eol_))
        if self.idCSRT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<idCSRT>%s</idCSRT>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.idCSRT), input_name='idCSRT')), eol_))
        if self.hashCSRT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<hashCSRT>%s</hashCSRT>%s' % (self.gds_format_base64(self.hashCSRT, input_name='hashCSRT'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'xContato':
            xContato_ = child_.text
            xContato_ = self.gds_validate_string(xContato_, node, 'xContato')
            self.xContato = xContato_
            # validate type xContatoType
            self.validate_xContatoType(self.xContato)
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            # validate type emailType78
            self.validate_emailType78(self.email)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType79
            self.validate_foneType79(self.fone)
        elif nodeName_ == 'idCSRT':
            idCSRT_ = child_.text
            idCSRT_ = self.gds_validate_string(idCSRT_, node, 'idCSRT')
            self.idCSRT = idCSRT_
            # validate type idCSRTType
            self.validate_idCSRTType(self.idCSRT)
        elif nodeName_ == 'hashCSRT':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'hashCSRT')
            else:
                bval_ = None
            self.hashCSRT = bval_
            # validate type hashCSRTType
            self.validate_hashCSRTType(self.hashCSRT)
# end class TInfRespTec


class TVeiculo(GeneratedsSuper):
    """Tipo Dados do Veículo"""
    subclass = None
    superclass = None
    def __init__(self, placa=None, UF=None, RNTC=None):
        self.original_tagname_ = None
        self.placa = placa
        self.validate_placaType(self.placa)
        self.UF = UF
        self.validate_TUf(self.UF)
        self.RNTC = RNTC
        self.validate_RNTCType(self.RNTC)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TVeiculo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TVeiculo.subclass:
            return TVeiculo.subclass(*args_, **kwargs_)
        else:
            return TVeiculo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_placaType(self, value):
        # Validate type placaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_placaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_placaType_patterns_, ))
    validate_placaType_patterns_ = [['^[A-Z]{2,3}[0-9]{4}$|^[A-Z]{3,4}[0-9]{3}$|^[A-Z0-9]{7}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def validate_RNTCType(self, value):
        # Validate type RNTCType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on RNTCType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RNTCType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_RNTCType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RNTCType_patterns_, ))
    validate_RNTCType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.placa is not None or
            self.UF is not None or
            self.RNTC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TVeiculo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TVeiculo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TVeiculo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TVeiculo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TVeiculo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TVeiculo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.placa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<placa>%s</placa>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.placa), input_name='placa')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
        if self.RNTC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RNTC>%s</RNTC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RNTC), input_name='RNTC')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'placa':
            placa_ = child_.text
            placa_ = self.gds_validate_string(placa_, node, 'placa')
            self.placa = placa_
            # validate type placaType
            self.validate_placaType(self.placa)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'RNTC':
            RNTC_ = child_.text
            RNTC_ = self.gds_validate_string(RNTC_, node, 'RNTC')
            self.RNTC = RNTC_
            # validate type RNTCType
            self.validate_RNTCType(self.RNTC)
# end class TVeiculo


class TIpi(GeneratedsSuper):
    """Tipo: Dados do IPI"""
    subclass = None
    superclass = None
    def __init__(self, CNPJProd=None, cSelo=None, qSelo=None, cEnq=None, IPITrib=None, IPINT=None):
        self.original_tagname_ = None
        self.CNPJProd = CNPJProd
        self.validate_TCnpj(self.CNPJProd)
        self.cSelo = cSelo
        self.validate_cSeloType(self.cSelo)
        self.qSelo = qSelo
        self.validate_qSeloType(self.qSelo)
        self.cEnq = cEnq
        self.validate_cEnqType(self.cEnq)
        self.IPITrib = IPITrib
        self.IPINT = IPINT
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TIpi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TIpi.subclass:
            return TIpi.subclass(*args_, **kwargs_)
        else:
            return TIpi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_cSeloType(self, value):
        # Validate type cSeloType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cSeloType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cSeloType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cSeloType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cSeloType_patterns_, ))
    validate_cSeloType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_qSeloType(self, value):
        # Validate type qSeloType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_qSeloType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qSeloType_patterns_, ))
    validate_qSeloType_patterns_ = [['^[0-9]{1,12}$']]
    def validate_cEnqType(self, value):
        # Validate type cEnqType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cEnqType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cEnqType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cEnqType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cEnqType_patterns_, ))
    validate_cEnqType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.CNPJProd is not None or
            self.cSelo is not None or
            self.qSelo is not None or
            self.cEnq is not None or
            self.IPITrib is not None or
            self.IPINT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TIpi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TIpi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TIpi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TIpi', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TIpi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TIpi', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJProd>%s</CNPJProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJProd), input_name='CNPJProd')), eol_))
        if self.cSelo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cSelo>%s</cSelo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cSelo), input_name='cSelo')), eol_))
        if self.qSelo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qSelo>%s</qSelo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qSelo), input_name='qSelo')), eol_))
        if self.cEnq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cEnq>%s</cEnq>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cEnq), input_name='cEnq')), eol_))
        if self.IPITrib is not None:
            self.IPITrib.export(outfile, level, namespace_, name_='IPITrib', pretty_print=pretty_print)
        if self.IPINT is not None:
            self.IPINT.export(outfile, level, namespace_, name_='IPINT', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJProd':
            CNPJProd_ = child_.text
            CNPJProd_ = self.gds_validate_string(CNPJProd_, node, 'CNPJProd')
            self.CNPJProd = CNPJProd_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJProd)
        elif nodeName_ == 'cSelo':
            cSelo_ = child_.text
            cSelo_ = self.gds_validate_string(cSelo_, node, 'cSelo')
            self.cSelo = cSelo_
            # validate type cSeloType
            self.validate_cSeloType(self.cSelo)
        elif nodeName_ == 'qSelo':
            qSelo_ = child_.text
            qSelo_ = self.gds_validate_string(qSelo_, node, 'qSelo')
            self.qSelo = qSelo_
            # validate type qSeloType
            self.validate_qSeloType(self.qSelo)
        elif nodeName_ == 'cEnq':
            cEnq_ = child_.text
            cEnq_ = self.gds_validate_string(cEnq_, node, 'cEnq')
            self.cEnq = cEnq_
            # validate type cEnqType
            self.validate_cEnqType(self.cEnq)
        elif nodeName_ == 'IPITrib':
            obj_ = IPITribType.factory()
            obj_.build(child_)
            self.IPITrib = obj_
            obj_.original_tagname_ = 'IPITrib'
        elif nodeName_ == 'IPINT':
            obj_ = IPINTType.factory()
            obj_.build(child_)
            self.IPINT = obj_
            obj_.original_tagname_ = 'IPINT'
# end class TIpi


class SignatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignedInfo=None, SignatureValue=None, KeyInfo=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.SignedInfo = SignedInfo
        self.SignatureValue = SignatureValue
        self.KeyInfo = KeyInfo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureType.subclass:
            return SignatureType.subclass(*args_, **kwargs_)
        else:
            return SignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignatureType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignatureType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SignedInfo is not None:
            self.SignedInfo.export(outfile, level, namespace_, name_='SignedInfo', pretty_print=pretty_print)
        if self.SignatureValue is not None:
            self.SignatureValue.export(outfile, level, namespace_, name_='SignatureValue', pretty_print=pretty_print)
        if self.KeyInfo is not None:
            self.KeyInfo.export(outfile, level, namespace_, name_='KeyInfo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SignedInfo':
            obj_ = SignedInfoType.factory()
            obj_.build(child_)
            self.SignedInfo = obj_
            obj_.original_tagname_ = 'SignedInfo'
        elif nodeName_ == 'SignatureValue':
            obj_ = SignatureValueType.factory()
            obj_.build(child_)
            self.SignatureValue = obj_
            obj_.original_tagname_ = 'SignatureValue'
        elif nodeName_ == 'KeyInfo':
            obj_ = KeyInfoType.factory()
            obj_.build(child_)
            self.KeyInfo = obj_
            obj_.original_tagname_ = 'KeyInfo'
# end class SignatureType


class SignatureValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, valueOf_=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureValueType.subclass:
            return SignatureValueType.subclass(*args_, **kwargs_)
        else:
            return SignatureValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignatureValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignatureValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignatureValueType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignatureValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureValueType


class SignedInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, CanonicalizationMethod=None, SignatureMethod=None, Reference=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.CanonicalizationMethod = CanonicalizationMethod
        self.SignatureMethod = SignatureMethod
        self.Reference = Reference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedInfoType.subclass:
            return SignedInfoType.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignedInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignedInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignedInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignedInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignedInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CanonicalizationMethod is not None:
            self.CanonicalizationMethod.export(outfile, level, namespace_, name_='CanonicalizationMethod', pretty_print=pretty_print)
        if self.SignatureMethod is not None:
            self.SignatureMethod.export(outfile, level, namespace_, name_='SignatureMethod', pretty_print=pretty_print)
        if self.Reference is not None:
            self.Reference.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CanonicalizationMethod':
            obj_ = CanonicalizationMethodType.factory()
            obj_.build(child_)
            self.CanonicalizationMethod = obj_
            obj_.original_tagname_ = 'CanonicalizationMethod'
        elif nodeName_ == 'SignatureMethod':
            obj_ = SignatureMethodType.factory()
            obj_.build(child_)
            self.SignatureMethod = obj_
            obj_.original_tagname_ = 'SignatureMethod'
        elif nodeName_ == 'Reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference = obj_
            obj_.original_tagname_ = 'Reference'
# end class SignedInfoType


class ReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, URI=None, Type=None, Transforms=None, DigestMethod=None, DigestValue=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.URI = _cast(None, URI)
        self.Type = _cast(None, Type)
        self.Transforms = Transforms
        self.DigestMethod = DigestMethod
        self.DigestValue = DigestValue
        self.validate_DigestValueType(self.DigestValue)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DigestValueType(self, value):
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            self.Transforms.export(outfile, level, namespace_, name_='Transforms', pretty_print=pretty_print)
        if self.DigestMethod is not None:
            self.DigestMethod.export(outfile, level, namespace_, name_='DigestMethod', pretty_print=pretty_print)
        if self.DigestValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DigestValue>%s</DigestValue>%s' % (self.gds_format_base64(self.DigestValue, input_name='DigestValue'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory()
            obj_.build(child_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
        elif nodeName_ == 'DigestMethod':
            obj_ = DigestMethodType.factory()
            obj_.build(child_)
            self.DigestMethod = obj_
            obj_.original_tagname_ = 'DigestMethod'
        elif nodeName_ == 'DigestValue':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'DigestValue')
            else:
                bval_ = None
            self.DigestValue = bval_
            # validate type DigestValueType
            self.validate_DigestValueType(self.DigestValue)
# end class ReferenceType


class TransformsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Transform=None):
        self.original_tagname_ = None
        if Transform is None:
            self.Transform = []
        else:
            self.Transform = Transform
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformsType.subclass:
            return TransformsType.subclass(*args_, **kwargs_)
        else:
            return TransformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Transform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransformsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransformsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransformsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransformsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TransformsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transform_ in self.Transform:
            Transform_.export(outfile, level, namespace_, name_='Transform', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transform':
            obj_ = TransformType.factory()
            obj_.build(child_)
            self.Transform.append(obj_)
            obj_.original_tagname_ = 'Transform'
# end class TransformsType


class TransformType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, XPath=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        if XPath is None:
            self.XPath = []
        else:
            self.XPath = XPath
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformType.subclass:
            return TransformType.subclass(*args_, **kwargs_)
        else:
            return TransformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.XPath
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransformType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransformType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TransformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for XPath_ in self.XPath:
            showIndent(outfile, level, pretty_print)
            outfile.write('<XPath>%s</XPath>%s' % (self.gds_encode(self.gds_format_string(quote_xml(XPath_), input_name='XPath')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XPath':
            XPath_ = child_.text
            XPath_ = self.gds_validate_string(XPath_, node, 'XPath')
            self.XPath.append(XPath_)
# end class TransformType


class KeyInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, X509Data=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.X509Data = X509Data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyInfoType.subclass:
            return KeyInfoType.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.X509Data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KeyInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KeyInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeyInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='KeyInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Data is not None:
            self.X509Data.export(outfile, level, namespace_, name_='X509Data', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509Data':
            obj_ = X509DataType.factory()
            obj_.build(child_)
            self.X509Data = obj_
            obj_.original_tagname_ = 'X509Data'
# end class KeyInfoType


class X509DataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X509Certificate=None):
        self.original_tagname_ = None
        self.X509Certificate = X509Certificate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509DataType.subclass:
            return X509DataType.subclass(*args_, **kwargs_)
        else:
            return X509DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.X509Certificate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='X509DataType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509DataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='X509DataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='X509DataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='X509DataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='X509DataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Certificate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<X509Certificate>%s</X509Certificate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.X509Certificate), input_name='X509Certificate')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509Certificate':
            X509Certificate_ = child_.text
            X509Certificate_ = self.gds_validate_string(X509Certificate_, node, 'X509Certificate')
            self.X509Certificate = X509Certificate_
# end class X509DataType


class infNFeType(GeneratedsSuper):
    """Informações da Nota Fiscal eletrônica"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, Id=None, ide=None, emit=None, avulsa=None, dest=None, retirada=None, entrega=None, autXML=None, det=None, total=None, transp=None, cobr=None, pag=None, infAdic=None, exporta=None, compra=None, cana=None, infRespTec=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.Id = _cast(None, Id)
        self.ide = ide
        self.emit = emit
        self.avulsa = avulsa
        self.dest = dest
        self.retirada = retirada
        self.entrega = entrega
        if autXML is None:
            self.autXML = []
        else:
            self.autXML = autXML
        if det is None:
            self.det = []
        else:
            self.det = det
        self.total = total
        self.transp = transp
        self.cobr = cobr
        self.pag = pag
        self.infAdic = infAdic
        self.exporta = exporta
        self.compra = compra
        self.cana = cana
        self.infRespTec = infRespTec
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFeType.subclass:
            return infNFeType.subclass(*args_, **kwargs_)
        else:
            return infNFeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [['^4\\.00$']]
    def hasContent_(self):
        if (
            self.ide is not None or
            self.emit is not None or
            self.avulsa is not None or
            self.dest is not None or
            self.retirada is not None or
            self.entrega is not None or
            self.autXML or
            self.det or
            self.total is not None or
            self.transp is not None or
            self.cobr is not None or
            self.pag is not None or
            self.infAdic is not None or
            self.exporta is not None or
            self.compra is not None or
            self.cana is not None or
            self.infRespTec is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infNFeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infNFeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infNFeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infNFeType'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='infNFeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ide is not None:
            self.ide.export(outfile, level, namespace_, name_='ide', pretty_print=pretty_print)
        if self.emit is not None:
            self.emit.export(outfile, level, namespace_, name_='emit', pretty_print=pretty_print)
        if self.avulsa is not None:
            self.avulsa.export(outfile, level, namespace_, name_='avulsa', pretty_print=pretty_print)
        if self.dest is not None:
            self.dest.export(outfile, level, namespace_, name_='dest', pretty_print=pretty_print)
        if self.retirada is not None:
            self.retirada.export(outfile, level, namespace_, name_='retirada', pretty_print=pretty_print)
        if self.entrega is not None:
            self.entrega.export(outfile, level, namespace_, name_='entrega', pretty_print=pretty_print)
        for autXML_ in self.autXML:
            autXML_.export(outfile, level, namespace_, name_='autXML', pretty_print=pretty_print)
        for det_ in self.det:
            det_.export(outfile, level, namespace_, name_='det', pretty_print=pretty_print)
        if self.total is not None:
            self.total.export(outfile, level, namespace_, name_='total', pretty_print=pretty_print)
        if self.transp is not None:
            self.transp.export(outfile, level, namespace_, name_='transp', pretty_print=pretty_print)
        if self.cobr is not None:
            self.cobr.export(outfile, level, namespace_, name_='cobr', pretty_print=pretty_print)
        if self.pag is not None:
            self.pag.export(outfile, level, namespace_, name_='pag', pretty_print=pretty_print)
        if self.infAdic is not None:
            self.infAdic.export(outfile, level, namespace_, name_='infAdic', pretty_print=pretty_print)
        if self.exporta is not None:
            self.exporta.export(outfile, level, namespace_, name_='exporta', pretty_print=pretty_print)
        if self.compra is not None:
            self.compra.export(outfile, level, namespace_, name_='compra', pretty_print=pretty_print)
        if self.cana is not None:
            self.cana.export(outfile, level, namespace_, name_='cana', pretty_print=pretty_print)
        if self.infRespTec is not None:
            self.infRespTec.export(outfile, level, namespace_, name_='infRespTec', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ide':
            obj_ = ideType.factory()
            obj_.build(child_)
            self.ide = obj_
            obj_.original_tagname_ = 'ide'
        elif nodeName_ == 'emit':
            obj_ = emitType.factory()
            obj_.build(child_)
            self.emit = obj_
            obj_.original_tagname_ = 'emit'
        elif nodeName_ == 'avulsa':
            obj_ = avulsaType.factory()
            obj_.build(child_)
            self.avulsa = obj_
            obj_.original_tagname_ = 'avulsa'
        elif nodeName_ == 'dest':
            obj_ = destType.factory()
            obj_.build(child_)
            self.dest = obj_
            obj_.original_tagname_ = 'dest'
        elif nodeName_ == 'retirada':
            obj_ = TLocal.factory()
            obj_.build(child_)
            self.retirada = obj_
            obj_.original_tagname_ = 'retirada'
        elif nodeName_ == 'entrega':
            obj_ = TLocal.factory()
            obj_.build(child_)
            self.entrega = obj_
            obj_.original_tagname_ = 'entrega'
        elif nodeName_ == 'autXML':
            obj_ = autXMLType.factory()
            obj_.build(child_)
            self.autXML.append(obj_)
            obj_.original_tagname_ = 'autXML'
        elif nodeName_ == 'det':
            obj_ = detType.factory()
            obj_.build(child_)
            self.det.append(obj_)
            obj_.original_tagname_ = 'det'
        elif nodeName_ == 'total':
            obj_ = totalType.factory()
            obj_.build(child_)
            self.total = obj_
            obj_.original_tagname_ = 'total'
        elif nodeName_ == 'transp':
            obj_ = transpType.factory()
            obj_.build(child_)
            self.transp = obj_
            obj_.original_tagname_ = 'transp'
        elif nodeName_ == 'cobr':
            obj_ = cobrType.factory()
            obj_.build(child_)
            self.cobr = obj_
            obj_.original_tagname_ = 'cobr'
        elif nodeName_ == 'pag':
            obj_ = pagType.factory()
            obj_.build(child_)
            self.pag = obj_
            obj_.original_tagname_ = 'pag'
        elif nodeName_ == 'infAdic':
            obj_ = infAdicType.factory()
            obj_.build(child_)
            self.infAdic = obj_
            obj_.original_tagname_ = 'infAdic'
        elif nodeName_ == 'exporta':
            obj_ = exportaType.factory()
            obj_.build(child_)
            self.exporta = obj_
            obj_.original_tagname_ = 'exporta'
        elif nodeName_ == 'compra':
            obj_ = compraType.factory()
            obj_.build(child_)
            self.compra = obj_
            obj_.original_tagname_ = 'compra'
        elif nodeName_ == 'cana':
            obj_ = canaType.factory()
            obj_.build(child_)
            self.cana = obj_
            obj_.original_tagname_ = 'cana'
        elif nodeName_ == 'infRespTec':
            obj_ = TInfRespTec.factory()
            obj_.build(child_)
            self.infRespTec = obj_
            obj_.original_tagname_ = 'infRespTec'
# end class infNFeType


class ideType(GeneratedsSuper):
    """identificação da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, cUF=None, cNF=None, natOp=None, mod=None, serie=None, nNF=None, dhEmi=None, dhSaiEnt=None, tpNF=None, idDest=None, cMunFG=None, tpImp=None, tpEmis=None, cDV=None, tpAmb=None, finNFe=None, indFinal=None, indPres=None, procEmi=None, verProc=None, dhCont=None, xJust=None, NFref=None):
        self.original_tagname_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.cNF = cNF
        self.validate_cNFType(self.cNF)
        self.natOp = natOp
        self.validate_natOpType(self.natOp)
        self.mod = mod
        self.validate_TMod(self.mod)
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.nNF = nNF
        self.validate_TNF(self.nNF)
        self.dhEmi = dhEmi
        self.validate_TDateTimeUTC(self.dhEmi)
        self.dhSaiEnt = dhSaiEnt
        self.validate_TDateTimeUTC(self.dhSaiEnt)
        self.tpNF = tpNF
        self.validate_tpNFType(self.tpNF)
        self.idDest = idDest
        self.validate_idDestType(self.idDest)
        self.cMunFG = cMunFG
        self.validate_TCodMunIBGE(self.cMunFG)
        self.tpImp = tpImp
        self.validate_tpImpType(self.tpImp)
        self.tpEmis = tpEmis
        self.validate_tpEmisType(self.tpEmis)
        self.cDV = cDV
        self.validate_cDVType(self.cDV)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.finNFe = finNFe
        self.validate_TFinNFe(self.finNFe)
        self.indFinal = indFinal
        self.validate_indFinalType(self.indFinal)
        self.indPres = indPres
        self.validate_indPresType(self.indPres)
        self.procEmi = procEmi
        self.validate_TProcEmi(self.procEmi)
        self.verProc = verProc
        self.validate_verProcType(self.verProc)
        self.dhCont = dhCont
        self.validate_TDateTimeUTC(self.dhCont)
        self.xJust = xJust
        self.validate_xJustType(self.xJust)
        if NFref is None:
            self.NFref = []
        else:
            self.NFref = NFref
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideType.subclass:
            return ideType.subclass(*args_, **kwargs_)
        else:
            return ideType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_cNFType(self, value):
        # Validate type cNFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cNFType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cNFType_patterns_, ))
    validate_cNFType_patterns_ = [['^[0-9]{8}$']]
    def validate_natOpType(self, value):
        # Validate type natOpType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on natOpType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on natOpType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_natOpType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_natOpType_patterns_, ))
    validate_natOpType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TMod(self, value):
        # Validate type TMod, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['55', '65']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TMod' % {"value" : value.encode("utf-8")} )
    def validate_TSerie(self, value):
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TSerie_patterns_, ))
    validate_TSerie_patterns_ = [['^0$|^[1-9]{1}[0-9]{0,2}$']]
    def validate_TNF(self, value):
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TNF_patterns_, ))
    validate_TNF_patterns_ = [['^[1-9]{1}[0-9]{0,8}$']]
    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))T(20$|^21$|^22$|^23$|^[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]$|^10$|^11):00$|^([\\+](12):00))$']]
    def validate_tpNFType(self, value):
        # Validate type tpNFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpNFType' % {"value" : value.encode("utf-8")} )
    def validate_idDestType(self, value):
        # Validate type idDestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on idDestType' % {"value" : value.encode("utf-8")} )
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_tpImpType(self, value):
        # Validate type tpImpType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpImpType' % {"value" : value.encode("utf-8")} )
    def validate_tpEmisType(self, value):
        # Validate type tpEmisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpEmisType' % {"value" : value.encode("utf-8")} )
    def validate_cDVType(self, value):
        # Validate type cDVType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cDVType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cDVType_patterns_, ))
    validate_cDVType_patterns_ = [['^[0-9]{1}$']]
    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {"value" : value.encode("utf-8")} )
    def validate_TFinNFe(self, value):
        # Validate type TFinNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TFinNFe' % {"value" : value.encode("utf-8")} )
    def validate_indFinalType(self, value):
        # Validate type indFinalType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indFinalType' % {"value" : value.encode("utf-8")} )
    def validate_indPresType(self, value):
        # Validate type indPresType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indPresType' % {"value" : value.encode("utf-8")} )
    def validate_TProcEmi(self, value):
        # Validate type TProcEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TProcEmi' % {"value" : value.encode("utf-8")} )
    def validate_verProcType(self, value):
        # Validate type verProcType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on verProcType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on verProcType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_verProcType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_verProcType_patterns_, ))
    validate_verProcType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xJustType(self, value):
        # Validate type xJustType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 256:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xJustType' % {"value" : value} )
            if len(str(value)) < 15:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xJustType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xJustType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xJustType_patterns_, ))
    validate_xJustType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.cUF is not None or
            self.cNF is not None or
            self.natOp is not None or
            self.mod is not None or
            self.serie is not None or
            self.nNF is not None or
            self.dhEmi is not None or
            self.dhSaiEnt is not None or
            self.tpNF is not None or
            self.idDest is not None or
            self.cMunFG is not None or
            self.tpImp is not None or
            self.tpEmis is not None or
            self.cDV is not None or
            self.tpAmb is not None or
            self.finNFe is not None or
            self.indFinal is not None or
            self.indPres is not None or
            self.procEmi is not None or
            self.verProc is not None or
            self.dhCont is not None or
            self.xJust is not None or
            self.NFref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cUF>%s</cUF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), eol_))
        if self.cNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cNF>%s</cNF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cNF), input_name='cNF')), eol_))
        if self.natOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<natOp>%s</natOp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.natOp), input_name='natOp')), eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<mod>%s</mod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<serie>%s</serie>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), eol_))
        if self.nNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nNF>%s</nNF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nNF), input_name='nNF')), eol_))
        if self.dhEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dhEmi>%s</dhEmi>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dhEmi), input_name='dhEmi')), eol_))
        if self.dhSaiEnt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dhSaiEnt>%s</dhSaiEnt>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dhSaiEnt), input_name='dhSaiEnt')), eol_))
        if self.tpNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpNF>%s</tpNF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpNF), input_name='tpNF')), eol_))
        if self.idDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<idDest>%s</idDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.idDest), input_name='idDest')), eol_))
        if self.cMunFG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMunFG>%s</cMunFG>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMunFG), input_name='cMunFG')), eol_))
        if self.tpImp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpImp>%s</tpImp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpImp), input_name='tpImp')), eol_))
        if self.tpEmis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpEmis>%s</tpEmis>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpEmis), input_name='tpEmis')), eol_))
        if self.cDV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cDV>%s</cDV>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cDV), input_name='cDV')), eol_))
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpAmb>%s</tpAmb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), eol_))
        if self.finNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<finNFe>%s</finNFe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.finNFe), input_name='finNFe')), eol_))
        if self.indFinal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indFinal>%s</indFinal>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indFinal), input_name='indFinal')), eol_))
        if self.indPres is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indPres>%s</indPres>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indPres), input_name='indPres')), eol_))
        if self.procEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<procEmi>%s</procEmi>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.procEmi), input_name='procEmi')), eol_))
        if self.verProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<verProc>%s</verProc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.verProc), input_name='verProc')), eol_))
        if self.dhCont is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dhCont>%s</dhCont>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dhCont), input_name='dhCont')), eol_))
        if self.xJust is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xJust>%s</xJust>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xJust), input_name='xJust')), eol_))
        for NFref_ in self.NFref:
            NFref_.export(outfile, level, namespace_, name_='NFref', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'cNF':
            cNF_ = child_.text
            cNF_ = self.gds_validate_string(cNF_, node, 'cNF')
            self.cNF = cNF_
            # validate type cNFType
            self.validate_cNFType(self.cNF)
        elif nodeName_ == 'natOp':
            natOp_ = child_.text
            natOp_ = self.gds_validate_string(natOp_, node, 'natOp')
            self.natOp = natOp_
            # validate type natOpType
            self.validate_natOpType(self.natOp)
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type TMod
            self.validate_TMod(self.mod)
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'nNF':
            nNF_ = child_.text
            nNF_ = self.gds_validate_string(nNF_, node, 'nNF')
            self.nNF = nNF_
            # validate type TNF
            self.validate_TNF(self.nNF)
        elif nodeName_ == 'dhEmi':
            dhEmi_ = child_.text
            dhEmi_ = self.gds_validate_string(dhEmi_, node, 'dhEmi')
            self.dhEmi = dhEmi_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhEmi)
        elif nodeName_ == 'dhSaiEnt':
            dhSaiEnt_ = child_.text
            dhSaiEnt_ = self.gds_validate_string(dhSaiEnt_, node, 'dhSaiEnt')
            self.dhSaiEnt = dhSaiEnt_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhSaiEnt)
        elif nodeName_ == 'tpNF':
            tpNF_ = child_.text
            tpNF_ = self.gds_validate_string(tpNF_, node, 'tpNF')
            self.tpNF = tpNF_
            # validate type tpNFType
            self.validate_tpNFType(self.tpNF)
        elif nodeName_ == 'idDest':
            idDest_ = child_.text
            idDest_ = self.gds_validate_string(idDest_, node, 'idDest')
            self.idDest = idDest_
            # validate type idDestType
            self.validate_idDestType(self.idDest)
        elif nodeName_ == 'cMunFG':
            cMunFG_ = child_.text
            cMunFG_ = self.gds_validate_string(cMunFG_, node, 'cMunFG')
            self.cMunFG = cMunFG_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunFG)
        elif nodeName_ == 'tpImp':
            tpImp_ = child_.text
            tpImp_ = self.gds_validate_string(tpImp_, node, 'tpImp')
            self.tpImp = tpImp_
            # validate type tpImpType
            self.validate_tpImpType(self.tpImp)
        elif nodeName_ == 'tpEmis':
            tpEmis_ = child_.text
            tpEmis_ = self.gds_validate_string(tpEmis_, node, 'tpEmis')
            self.tpEmis = tpEmis_
            # validate type tpEmisType
            self.validate_tpEmisType(self.tpEmis)
        elif nodeName_ == 'cDV':
            cDV_ = child_.text
            cDV_ = self.gds_validate_string(cDV_, node, 'cDV')
            self.cDV = cDV_
            # validate type cDVType
            self.validate_cDVType(self.cDV)
        elif nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'finNFe':
            finNFe_ = child_.text
            finNFe_ = self.gds_validate_string(finNFe_, node, 'finNFe')
            self.finNFe = finNFe_
            # validate type TFinNFe
            self.validate_TFinNFe(self.finNFe)
        elif nodeName_ == 'indFinal':
            indFinal_ = child_.text
            indFinal_ = self.gds_validate_string(indFinal_, node, 'indFinal')
            self.indFinal = indFinal_
            # validate type indFinalType
            self.validate_indFinalType(self.indFinal)
        elif nodeName_ == 'indPres':
            indPres_ = child_.text
            indPres_ = self.gds_validate_string(indPres_, node, 'indPres')
            self.indPres = indPres_
            # validate type indPresType
            self.validate_indPresType(self.indPres)
        elif nodeName_ == 'procEmi':
            procEmi_ = child_.text
            procEmi_ = self.gds_validate_string(procEmi_, node, 'procEmi')
            self.procEmi = procEmi_
            # validate type TProcEmi
            self.validate_TProcEmi(self.procEmi)
        elif nodeName_ == 'verProc':
            verProc_ = child_.text
            verProc_ = self.gds_validate_string(verProc_, node, 'verProc')
            self.verProc = verProc_
            # validate type verProcType
            self.validate_verProcType(self.verProc)
        elif nodeName_ == 'dhCont':
            dhCont_ = child_.text
            dhCont_ = self.gds_validate_string(dhCont_, node, 'dhCont')
            self.dhCont = dhCont_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhCont)
        elif nodeName_ == 'xJust':
            xJust_ = child_.text
            xJust_ = self.gds_validate_string(xJust_, node, 'xJust')
            self.xJust = xJust_
            # validate type xJustType
            self.validate_xJustType(self.xJust)
        elif nodeName_ == 'NFref':
            obj_ = NFrefType.factory()
            obj_.build(child_)
            self.NFref.append(obj_)
            obj_.original_tagname_ = 'NFref'
# end class ideType


class NFrefType(GeneratedsSuper):
    """Grupo de infromações da NF referenciada"""
    subclass = None
    superclass = None
    def __init__(self, refNFe=None, refNF=None, refNFP=None, refCTe=None, refECF=None):
        self.original_tagname_ = None
        self.refNFe = refNFe
        self.validate_TChNFe(self.refNFe)
        self.refNF = refNF
        self.refNFP = refNFP
        self.refCTe = refCTe
        self.validate_TChNFe(self.refCTe)
        self.refECF = refECF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NFrefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NFrefType.subclass:
            return NFrefType.subclass(*args_, **kwargs_)
        else:
            return NFrefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [['^[0-9]{44}$']]
    def hasContent_(self):
        if (
            self.refNFe is not None or
            self.refNF is not None or
            self.refNFP is not None or
            self.refCTe is not None or
            self.refECF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NFrefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NFrefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NFrefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NFrefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NFrefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NFrefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.refNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<refNFe>%s</refNFe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.refNFe), input_name='refNFe')), eol_))
        if self.refNF is not None:
            self.refNF.export(outfile, level, namespace_, name_='refNF', pretty_print=pretty_print)
        if self.refNFP is not None:
            self.refNFP.export(outfile, level, namespace_, name_='refNFP', pretty_print=pretty_print)
        if self.refCTe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<refCTe>%s</refCTe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.refCTe), input_name='refCTe')), eol_))
        if self.refECF is not None:
            self.refECF.export(outfile, level, namespace_, name_='refECF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'refNFe':
            refNFe_ = child_.text
            refNFe_ = self.gds_validate_string(refNFe_, node, 'refNFe')
            self.refNFe = refNFe_
            # validate type TChNFe
            self.validate_TChNFe(self.refNFe)
        elif nodeName_ == 'refNF':
            obj_ = refNFType.factory()
            obj_.build(child_)
            self.refNF = obj_
            obj_.original_tagname_ = 'refNF'
        elif nodeName_ == 'refNFP':
            obj_ = refNFPType.factory()
            obj_.build(child_)
            self.refNFP = obj_
            obj_.original_tagname_ = 'refNFP'
        elif nodeName_ == 'refCTe':
            refCTe_ = child_.text
            refCTe_ = self.gds_validate_string(refCTe_, node, 'refCTe')
            self.refCTe = refCTe_
            # validate type TChNFe
            self.validate_TChNFe(self.refCTe)
        elif nodeName_ == 'refECF':
            obj_ = refECFType.factory()
            obj_.build(child_)
            self.refECF = obj_
            obj_.original_tagname_ = 'refECF'
# end class NFrefType


class refNFType(GeneratedsSuper):
    """Dados da NF modelo 1/1A referenciada ou NF modelo 2 referenciada"""
    subclass = None
    superclass = None
    def __init__(self, cUF=None, AAMM=None, CNPJ=None, mod=None, serie=None, nNF=None):
        self.original_tagname_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.AAMM = AAMM
        self.validate_AAMMType(self.AAMM)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.mod = mod
        self.validate_modType(self.mod)
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.nNF = nNF
        self.validate_TNF(self.nNF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refNFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refNFType.subclass:
            return refNFType.subclass(*args_, **kwargs_)
        else:
            return refNFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_AAMMType(self, value):
        # Validate type AAMMType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AAMMType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AAMMType_patterns_, ))
    validate_AAMMType_patterns_ = [['^[0-9]{2}[0]{1}[1-9]{1}$|^[0-9]{2}[1]{1}[0-2]{1}$']]
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_modType(self, value):
        # Validate type modType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modType' % {"value" : value.encode("utf-8")} )
    def validate_TSerie(self, value):
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TSerie_patterns_, ))
    validate_TSerie_patterns_ = [['^0$|^[1-9]{1}[0-9]{0,2}$']]
    def validate_TNF(self, value):
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TNF_patterns_, ))
    validate_TNF_patterns_ = [['^[1-9]{1}[0-9]{0,8}$']]
    def hasContent_(self):
        if (
            self.cUF is not None or
            self.AAMM is not None or
            self.CNPJ is not None or
            self.mod is not None or
            self.serie is not None or
            self.nNF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='refNFType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refNFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='refNFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='refNFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='refNFType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='refNFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cUF>%s</cUF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), eol_))
        if self.AAMM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AAMM>%s</AAMM>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AAMM), input_name='AAMM')), eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<mod>%s</mod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<serie>%s</serie>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), eol_))
        if self.nNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nNF>%s</nNF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nNF), input_name='nNF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'AAMM':
            AAMM_ = child_.text
            AAMM_ = self.gds_validate_string(AAMM_, node, 'AAMM')
            self.AAMM = AAMM_
            # validate type AAMMType
            self.validate_AAMMType(self.AAMM)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type modType
            self.validate_modType(self.mod)
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'nNF':
            nNF_ = child_.text
            nNF_ = self.gds_validate_string(nNF_, node, 'nNF')
            self.nNF = nNF_
            # validate type TNF
            self.validate_TNF(self.nNF)
# end class refNFType


class refNFPType(GeneratedsSuper):
    """Grupo com as informações NF de produtor referenciada"""
    subclass = None
    superclass = None
    def __init__(self, cUF=None, AAMM=None, CNPJ=None, CPF=None, IE=None, mod=None, serie=None, nNF=None):
        self.original_tagname_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.AAMM = AAMM
        self.validate_AAMMType1(self.AAMM)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.IE = IE
        self.validate_TIeDest(self.IE)
        self.mod = mod
        self.validate_modType2(self.mod)
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.nNF = nNF
        self.validate_TNF(self.nNF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refNFPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refNFPType.subclass:
            return refNFPType.subclass(*args_, **kwargs_)
        else:
            return refNFPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_AAMMType1(self, value):
        # Validate type AAMMType1, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AAMMType1_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AAMMType1_patterns_, ))
    validate_AAMMType1_patterns_ = [['^[0-9]{2}[0]{1}[1-9]{1}$|^[0-9]{2}[1]{1}[0-2]{1}$']]
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def validate_TIeDest(self, value):
        # Validate type TIeDest, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TIeDest' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeDest_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIeDest_patterns_, ))
    validate_TIeDest_patterns_ = [['^ISENTO$|^[0-9]{2,14}$']]
    def validate_modType2(self, value):
        # Validate type modType2, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '04']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modType2' % {"value" : value.encode("utf-8")} )
    def validate_TSerie(self, value):
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TSerie_patterns_, ))
    validate_TSerie_patterns_ = [['^0$|^[1-9]{1}[0-9]{0,2}$']]
    def validate_TNF(self, value):
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TNF_patterns_, ))
    validate_TNF_patterns_ = [['^[1-9]{1}[0-9]{0,8}$']]
    def hasContent_(self):
        if (
            self.cUF is not None or
            self.AAMM is not None or
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.mod is not None or
            self.serie is not None or
            self.nNF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='refNFPType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refNFPType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='refNFPType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='refNFPType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='refNFPType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='refNFPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cUF>%s</cUF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), eol_))
        if self.AAMM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AAMM>%s</AAMM>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AAMM), input_name='AAMM')), eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IE>%s</IE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<mod>%s</mod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<serie>%s</serie>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), eol_))
        if self.nNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nNF>%s</nNF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nNF), input_name='nNF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'AAMM':
            AAMM_ = child_.text
            AAMM_ = self.gds_validate_string(AAMM_, node, 'AAMM')
            self.AAMM = AAMM_
            # validate type AAMMType1
            self.validate_AAMMType1(self.AAMM)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIeDest
            self.validate_TIeDest(self.IE)
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type modType2
            self.validate_modType2(self.mod)
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'nNF':
            nNF_ = child_.text
            nNF_ = self.gds_validate_string(nNF_, node, 'nNF')
            self.nNF = nNF_
            # validate type TNF
            self.validate_TNF(self.nNF)
# end class refNFPType


class refECFType(GeneratedsSuper):
    """Grupo do Cupom Fiscal vinculado à NF-e"""
    subclass = None
    superclass = None
    def __init__(self, mod=None, nECF=None, nCOO=None):
        self.original_tagname_ = None
        self.mod = mod
        self.validate_modType3(self.mod)
        self.nECF = nECF
        self.validate_nECFType(self.nECF)
        self.nCOO = nCOO
        self.validate_nCOOType(self.nCOO)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refECFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refECFType.subclass:
            return refECFType.subclass(*args_, **kwargs_)
        else:
            return refECFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_modType3(self, value):
        # Validate type modType3, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['2B', '2C', '2D']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modType3' % {"value" : value.encode("utf-8")} )
    def validate_nECFType(self, value):
        # Validate type nECFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nECFType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nECFType_patterns_, ))
    validate_nECFType_patterns_ = [['^[0-9]{1,3}$']]
    def validate_nCOOType(self, value):
        # Validate type nCOOType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nCOOType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nCOOType_patterns_, ))
    validate_nCOOType_patterns_ = [['^[0-9]{1,6}$']]
    def hasContent_(self):
        if (
            self.mod is not None or
            self.nECF is not None or
            self.nCOO is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='refECFType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refECFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='refECFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='refECFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='refECFType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='refECFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<mod>%s</mod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), eol_))
        if self.nECF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nECF>%s</nECF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nECF), input_name='nECF')), eol_))
        if self.nCOO is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nCOO>%s</nCOO>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nCOO), input_name='nCOO')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type modType3
            self.validate_modType3(self.mod)
        elif nodeName_ == 'nECF':
            nECF_ = child_.text
            nECF_ = self.gds_validate_string(nECF_, node, 'nECF')
            self.nECF = nECF_
            # validate type nECFType
            self.validate_nECFType(self.nECF)
        elif nodeName_ == 'nCOO':
            nCOO_ = child_.text
            nCOO_ = self.gds_validate_string(nCOO_, node, 'nCOO')
            self.nCOO = nCOO_
            # validate type nCOOType
            self.validate_nCOOType(self.nCOO)
# end class refECFType


class emitType(GeneratedsSuper):
    """Identificação do emitente"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xNome=None, xFant=None, enderEmit=None, IE=None, IEST=None, IM=None, CNAE=None, CRT=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.xNome = xNome
        self.validate_xNomeType(self.xNome)
        self.xFant = xFant
        self.validate_xFantType(self.xFant)
        self.enderEmit = enderEmit
        self.IE = IE
        self.validate_TIe(self.IE)
        self.IEST = IEST
        self.validate_TIeST(self.IEST)
        self.IM = IM
        self.validate_IMType(self.IM)
        self.CNAE = CNAE
        self.validate_CNAEType(self.CNAE)
        self.CRT = CRT
        self.validate_CRTType(self.CRT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emitType.subclass:
            return emitType.subclass(*args_, **kwargs_)
        else:
            return emitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def validate_xNomeType(self, value):
        # Validate type xNomeType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeType_patterns_, ))
    validate_xNomeType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xFantType(self, value):
        # Validate type xFantType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xFantType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xFantType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xFantType_patterns_, ))
    validate_xFantType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TIe(self, value):
        # Validate type TIe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TIe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TIe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIe_patterns_, ))
    validate_TIe_patterns_ = [['^[0-9]{2,14}$|^ISENTO$']]
    def validate_TIeST(self, value):
        # Validate type TIeST, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TIeST' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeST_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIeST_patterns_, ))
    validate_TIeST_patterns_ = [['^[0-9]{2,14}$']]
    def validate_IMType(self, value):
        # Validate type IMType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on IMType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on IMType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_IMType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IMType_patterns_, ))
    validate_IMType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_CNAEType(self, value):
        # Validate type CNAEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CNAEType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CNAEType_patterns_, ))
    validate_CNAEType_patterns_ = [['^[0-9]{7}$']]
    def validate_CRTType(self, value):
        # Validate type CRTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CRTType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.enderEmit is not None or
            self.IE is not None or
            self.IEST is not None or
            self.IM is not None or
            self.CNAE is not None or
            self.CRT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emitType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emitType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='emitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNome>%s</xNome>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), eol_))
        if self.xFant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xFant>%s</xFant>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xFant), input_name='xFant')), eol_))
        if self.enderEmit is not None:
            self.enderEmit.export(outfile, level, namespace_, name_='enderEmit', pretty_print=pretty_print)
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IE>%s</IE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), eol_))
        if self.IEST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IEST>%s</IEST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IEST), input_name='IEST')), eol_))
        if self.IM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IM>%s</IM>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IM), input_name='IM')), eol_))
        if self.CNAE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNAE>%s</CNAE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNAE), input_name='CNAE')), eol_))
        if self.CRT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CRT>%s</CRT>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CRT), input_name='CRT')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType
            self.validate_xNomeType(self.xNome)
        elif nodeName_ == 'xFant':
            xFant_ = child_.text
            xFant_ = self.gds_validate_string(xFant_, node, 'xFant')
            self.xFant = xFant_
            # validate type xFantType
            self.validate_xFantType(self.xFant)
        elif nodeName_ == 'enderEmit':
            obj_ = TEnderEmi.factory()
            obj_.build(child_)
            self.enderEmit = obj_
            obj_.original_tagname_ = 'enderEmit'
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIe
            self.validate_TIe(self.IE)
        elif nodeName_ == 'IEST':
            IEST_ = child_.text
            IEST_ = self.gds_validate_string(IEST_, node, 'IEST')
            self.IEST = IEST_
            # validate type TIeST
            self.validate_TIeST(self.IEST)
        elif nodeName_ == 'IM':
            IM_ = child_.text
            IM_ = self.gds_validate_string(IM_, node, 'IM')
            self.IM = IM_
            # validate type IMType
            self.validate_IMType(self.IM)
        elif nodeName_ == 'CNAE':
            CNAE_ = child_.text
            CNAE_ = self.gds_validate_string(CNAE_, node, 'CNAE')
            self.CNAE = CNAE_
            # validate type CNAEType
            self.validate_CNAEType(self.CNAE)
        elif nodeName_ == 'CRT':
            CRT_ = child_.text
            CRT_ = self.gds_validate_string(CRT_, node, 'CRT')
            self.CRT = CRT_
            # validate type CRTType
            self.validate_CRTType(self.CRT)
# end class emitType


class avulsaType(GeneratedsSuper):
    """Emissão de avulsa, informar os dados do Fisco emitente"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, xOrgao=None, matr=None, xAgente=None, fone=None, UF=None, nDAR=None, dEmi=None, vDAR=None, repEmi=None, dPag=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.xOrgao = xOrgao
        self.validate_xOrgaoType(self.xOrgao)
        self.matr = matr
        self.validate_matrType(self.matr)
        self.xAgente = xAgente
        self.validate_xAgenteType(self.xAgente)
        self.fone = fone
        self.validate_foneType(self.fone)
        self.UF = UF
        self.validate_TUfEmi(self.UF)
        self.nDAR = nDAR
        self.validate_nDARType(self.nDAR)
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.vDAR = vDAR
        self.validate_TDec_1302(self.vDAR)
        self.repEmi = repEmi
        self.validate_repEmiType(self.repEmi)
        self.dPag = dPag
        self.validate_TData(self.dPag)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, avulsaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if avulsaType.subclass:
            return avulsaType.subclass(*args_, **kwargs_)
        else:
            return avulsaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_xOrgaoType(self, value):
        # Validate type xOrgaoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xOrgaoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xOrgaoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xOrgaoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xOrgaoType_patterns_, ))
    validate_xOrgaoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_matrType(self, value):
        # Validate type matrType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on matrType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on matrType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_matrType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_matrType_patterns_, ))
    validate_matrType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xAgenteType(self, value):
        # Validate type xAgenteType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xAgenteType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xAgenteType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xAgenteType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xAgenteType_patterns_, ))
    validate_xAgenteType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_foneType(self, value):
        # Validate type foneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_foneType_patterns_, ))
    validate_foneType_patterns_ = [['^[0-9]{6,14}$']]
    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {"value" : value.encode("utf-8")} )
    def validate_nDARType(self, value):
        # Validate type nDARType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nDARType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nDARType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nDARType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nDARType_patterns_, ))
    validate_nDARType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_repEmiType(self, value):
        # Validate type repEmiType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on repEmiType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on repEmiType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_repEmiType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_repEmiType_patterns_, ))
    validate_repEmiType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.xOrgao is not None or
            self.matr is not None or
            self.xAgente is not None or
            self.fone is not None or
            self.UF is not None or
            self.nDAR is not None or
            self.dEmi is not None or
            self.vDAR is not None or
            self.repEmi is not None or
            self.dPag is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='avulsaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('avulsaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='avulsaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='avulsaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='avulsaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='avulsaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.xOrgao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xOrgao>%s</xOrgao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xOrgao), input_name='xOrgao')), eol_))
        if self.matr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<matr>%s</matr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.matr), input_name='matr')), eol_))
        if self.xAgente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xAgente>%s</xAgente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xAgente), input_name='xAgente')), eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fone>%s</fone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
        if self.nDAR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nDAR>%s</nDAR>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nDAR), input_name='nDAR')), eol_))
        if self.dEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dEmi>%s</dEmi>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), eol_))
        if self.vDAR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDAR>%s</vDAR>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDAR), input_name='vDAR')), eol_))
        if self.repEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<repEmi>%s</repEmi>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.repEmi), input_name='repEmi')), eol_))
        if self.dPag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dPag>%s</dPag>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dPag), input_name='dPag')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'xOrgao':
            xOrgao_ = child_.text
            xOrgao_ = self.gds_validate_string(xOrgao_, node, 'xOrgao')
            self.xOrgao = xOrgao_
            # validate type xOrgaoType
            self.validate_xOrgaoType(self.xOrgao)
        elif nodeName_ == 'matr':
            matr_ = child_.text
            matr_ = self.gds_validate_string(matr_, node, 'matr')
            self.matr = matr_
            # validate type matrType
            self.validate_matrType(self.matr)
        elif nodeName_ == 'xAgente':
            xAgente_ = child_.text
            xAgente_ = self.gds_validate_string(xAgente_, node, 'xAgente')
            self.xAgente = xAgente_
            # validate type xAgenteType
            self.validate_xAgenteType(self.xAgente)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType
            self.validate_foneType(self.fone)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UF)
        elif nodeName_ == 'nDAR':
            nDAR_ = child_.text
            nDAR_ = self.gds_validate_string(nDAR_, node, 'nDAR')
            self.nDAR = nDAR_
            # validate type nDARType
            self.validate_nDARType(self.nDAR)
        elif nodeName_ == 'dEmi':
            dEmi_ = child_.text
            dEmi_ = self.gds_validate_string(dEmi_, node, 'dEmi')
            self.dEmi = dEmi_
            # validate type TData
            self.validate_TData(self.dEmi)
        elif nodeName_ == 'vDAR':
            vDAR_ = child_.text
            vDAR_ = self.gds_validate_string(vDAR_, node, 'vDAR')
            self.vDAR = vDAR_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDAR)
        elif nodeName_ == 'repEmi':
            repEmi_ = child_.text
            repEmi_ = self.gds_validate_string(repEmi_, node, 'repEmi')
            self.repEmi = repEmi_
            # validate type repEmiType
            self.validate_repEmiType(self.repEmi)
        elif nodeName_ == 'dPag':
            dPag_ = child_.text
            dPag_ = self.gds_validate_string(dPag_, node, 'dPag')
            self.dPag = dPag_
            # validate type TData
            self.validate_TData(self.dPag)
# end class avulsaType


class destType(GeneratedsSuper):
    """Identificação do Destinatário"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, idEstrangeiro=None, xNome=None, enderDest=None, indIEDest=None, IE=None, ISUF=None, IM=None, email=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.idEstrangeiro = idEstrangeiro
        self.validate_idEstrangeiroType(self.idEstrangeiro)
        self.xNome = xNome
        self.validate_xNomeType4(self.xNome)
        self.enderDest = enderDest
        self.indIEDest = indIEDest
        self.validate_indIEDestType(self.indIEDest)
        self.IE = IE
        self.validate_TIeDestNaoIsento(self.IE)
        self.ISUF = ISUF
        self.validate_ISUFType(self.ISUF)
        self.IM = IM
        self.validate_IMType5(self.IM)
        self.email = email
        self.validate_emailType(self.email)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, destType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if destType.subclass:
            return destType.subclass(*args_, **kwargs_)
        else:
            return destType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def validate_idEstrangeiroType(self, value):
        # Validate type idEstrangeiroType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_idEstrangeiroType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_idEstrangeiroType_patterns_, ))
    validate_idEstrangeiroType_patterns_ = [['^([!-ÿ]{0}$|^[!-ÿ]{5,20})?$']]
    def validate_xNomeType4(self, value):
        # Validate type xNomeType4, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeType4' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeType4' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType4_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeType4_patterns_, ))
    validate_xNomeType4_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_indIEDestType(self, value):
        # Validate type indIEDestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indIEDestType' % {"value" : value.encode("utf-8")} )
    def validate_TIeDestNaoIsento(self, value):
        # Validate type TIeDestNaoIsento, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TIeDestNaoIsento' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeDestNaoIsento_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIeDestNaoIsento_patterns_, ))
    validate_TIeDestNaoIsento_patterns_ = [['^[0-9]{2,14}$']]
    def validate_ISUFType(self, value):
        # Validate type ISUFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ISUFType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ISUFType_patterns_, ))
    validate_ISUFType_patterns_ = [['^[0-9]{8,9}$']]
    def validate_IMType5(self, value):
        # Validate type IMType5, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on IMType5' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on IMType5' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_IMType5_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IMType5_patterns_, ))
    validate_IMType5_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_emailType(self, value):
        # Validate type emailType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on emailType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on emailType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_emailType_patterns_, ))
    validate_emailType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.idEstrangeiro is not None or
            self.xNome is not None or
            self.enderDest is not None or
            self.indIEDest is not None or
            self.IE is not None or
            self.ISUF is not None or
            self.IM is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='destType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('destType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='destType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='destType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='destType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='destType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
        if self.idEstrangeiro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<idEstrangeiro>%s</idEstrangeiro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.idEstrangeiro), input_name='idEstrangeiro')), eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNome>%s</xNome>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), eol_))
        if self.enderDest is not None:
            self.enderDest.export(outfile, level, namespace_, name_='enderDest', pretty_print=pretty_print)
        if self.indIEDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indIEDest>%s</indIEDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indIEDest), input_name='indIEDest')), eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IE>%s</IE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), eol_))
        if self.ISUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ISUF>%s</ISUF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ISUF), input_name='ISUF')), eol_))
        if self.IM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IM>%s</IM>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IM), input_name='IM')), eol_))
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<email>%s</email>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'idEstrangeiro':
            idEstrangeiro_ = child_.text
            idEstrangeiro_ = self.gds_validate_string(idEstrangeiro_, node, 'idEstrangeiro')
            self.idEstrangeiro = idEstrangeiro_
            # validate type idEstrangeiroType
            self.validate_idEstrangeiroType(self.idEstrangeiro)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType4
            self.validate_xNomeType4(self.xNome)
        elif nodeName_ == 'enderDest':
            obj_ = TEndereco.factory()
            obj_.build(child_)
            self.enderDest = obj_
            obj_.original_tagname_ = 'enderDest'
        elif nodeName_ == 'indIEDest':
            indIEDest_ = child_.text
            indIEDest_ = self.gds_validate_string(indIEDest_, node, 'indIEDest')
            self.indIEDest = indIEDest_
            # validate type indIEDestType
            self.validate_indIEDestType(self.indIEDest)
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIeDestNaoIsento
            self.validate_TIeDestNaoIsento(self.IE)
        elif nodeName_ == 'ISUF':
            ISUF_ = child_.text
            ISUF_ = self.gds_validate_string(ISUF_, node, 'ISUF')
            self.ISUF = ISUF_
            # validate type ISUFType
            self.validate_ISUFType(self.ISUF)
        elif nodeName_ == 'IM':
            IM_ = child_.text
            IM_ = self.gds_validate_string(IM_, node, 'IM')
            self.IM = IM_
            # validate type IMType5
            self.validate_IMType5(self.IM)
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            # validate type emailType
            self.validate_emailType(self.email)
# end class destType


class autXMLType(GeneratedsSuper):
    """Pessoas autorizadas para o download do XML da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, autXMLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if autXMLType.subclass:
            return autXMLType.subclass(*args_, **kwargs_)
        else:
            return autXMLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='autXMLType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('autXMLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='autXMLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='autXMLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='autXMLType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='autXMLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
# end class autXMLType


class detType(GeneratedsSuper):
    """Dados dos detalhes da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, nItem=None, prod=None, imposto=None, impostoDevol=None, infAdProd=None):
        self.original_tagname_ = None
        self.nItem = _cast(None, nItem)
        self.prod = prod
        self.imposto = imposto
        self.impostoDevol = impostoDevol
        self.infAdProd = infAdProd
        self.validate_infAdProdType(self.infAdProd)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detType.subclass:
            return detType.subclass(*args_, **kwargs_)
        else:
            return detType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_infAdProdType(self, value):
        # Validate type infAdProdType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 500:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on infAdProdType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on infAdProdType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_infAdProdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_infAdProdType_patterns_, ))
    validate_infAdProdType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.prod is not None or
            self.imposto is not None or
            self.impostoDevol is not None or
            self.infAdProd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='detType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='detType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='detType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='detType'):
        if self.nItem is not None and 'nItem' not in already_processed:
            already_processed.add('nItem')
            outfile.write(' nItem=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nItem), input_name='nItem')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='detType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.prod is not None:
            self.prod.export(outfile, level, namespace_, name_='prod', pretty_print=pretty_print)
        if self.imposto is not None:
            self.imposto.export(outfile, level, namespace_, name_='imposto', pretty_print=pretty_print)
        if self.impostoDevol is not None:
            self.impostoDevol.export(outfile, level, namespace_, name_='impostoDevol', pretty_print=pretty_print)
        if self.infAdProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<infAdProd>%s</infAdProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.infAdProd), input_name='infAdProd')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nItem', node)
        if value is not None and 'nItem' not in already_processed:
            already_processed.add('nItem')
            self.nItem = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'prod':
            obj_ = prodType.factory()
            obj_.build(child_)
            self.prod = obj_
            obj_.original_tagname_ = 'prod'
        elif nodeName_ == 'imposto':
            obj_ = impostoType.factory()
            obj_.build(child_)
            self.imposto = obj_
            obj_.original_tagname_ = 'imposto'
        elif nodeName_ == 'impostoDevol':
            obj_ = impostoDevolType.factory()
            obj_.build(child_)
            self.impostoDevol = obj_
            obj_.original_tagname_ = 'impostoDevol'
        elif nodeName_ == 'infAdProd':
            infAdProd_ = child_.text
            infAdProd_ = self.gds_validate_string(infAdProd_, node, 'infAdProd')
            self.infAdProd = infAdProd_
            # validate type infAdProdType
            self.validate_infAdProdType(self.infAdProd)
# end class detType


class prodType(GeneratedsSuper):
    """Dados dos produtos e serviços da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, cProd=None, cEAN=None, xProd=None, NCM=None, NVE=None, CEST=None, indEscala=None, CNPJFab=None, cBenef=None, EXTIPI=None, CFOP=None, uCom=None, qCom=None, vUnCom=None, vProd=None, cEANTrib=None, uTrib=None, qTrib=None, vUnTrib=None, vFrete=None, vSeg=None, vDesc=None, vOutro=None, indTot=None, DI=None, detExport=None, xPed=None, nItemPed=None, nFCI=None, rastro=None, veicProd=None, med=None, arma=None, comb=None, nRECOPI=None):
        self.original_tagname_ = None
        self.cProd = cProd
        self.validate_cProdType(self.cProd)
        self.cEAN = cEAN
        self.validate_cEANType(self.cEAN)
        self.xProd = xProd
        self.validate_xProdType(self.xProd)
        self.NCM = NCM
        self.validate_NCMType(self.NCM)
        if NVE is None:
            self.NVE = []
        else:
            self.NVE = NVE
        self.CEST = CEST
        self.validate_CESTType(self.CEST)
        self.indEscala = indEscala
        self.validate_indEscalaType(self.indEscala)
        self.CNPJFab = CNPJFab
        self.validate_TCnpj(self.CNPJFab)
        self.cBenef = cBenef
        self.validate_cBenefType(self.cBenef)
        self.EXTIPI = EXTIPI
        self.validate_EXTIPIType(self.EXTIPI)
        self.CFOP = CFOP
        self.validate_CFOPType(self.CFOP)
        self.uCom = uCom
        self.validate_uComType(self.uCom)
        self.qCom = qCom
        self.validate_TDec_1104v(self.qCom)
        self.vUnCom = vUnCom
        self.validate_TDec_1110v(self.vUnCom)
        self.vProd = vProd
        self.validate_TDec_1302(self.vProd)
        self.cEANTrib = cEANTrib
        self.validate_cEANTribType(self.cEANTrib)
        self.uTrib = uTrib
        self.validate_uTribType(self.uTrib)
        self.qTrib = qTrib
        self.validate_TDec_1104v(self.qTrib)
        self.vUnTrib = vUnTrib
        self.validate_TDec_1110v(self.vUnTrib)
        self.vFrete = vFrete
        self.validate_TDec_1302Opc(self.vFrete)
        self.vSeg = vSeg
        self.validate_TDec_1302Opc(self.vSeg)
        self.vDesc = vDesc
        self.validate_TDec_1302Opc(self.vDesc)
        self.vOutro = vOutro
        self.validate_TDec_1302Opc(self.vOutro)
        self.indTot = indTot
        self.validate_indTotType(self.indTot)
        if DI is None:
            self.DI = []
        else:
            self.DI = DI
        if detExport is None:
            self.detExport = []
        else:
            self.detExport = detExport
        self.xPed = xPed
        self.validate_xPedType(self.xPed)
        self.nItemPed = nItemPed
        self.validate_nItemPedType(self.nItemPed)
        self.nFCI = nFCI
        self.validate_TGuid(self.nFCI)
        if rastro is None:
            self.rastro = []
        else:
            self.rastro = rastro
        self.veicProd = veicProd
        self.med = med
        if arma is None:
            self.arma = []
        else:
            self.arma = arma
        self.comb = comb
        self.nRECOPI = nRECOPI
        self.validate_nRECOPIType(self.nRECOPI)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, prodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if prodType.subclass:
            return prodType.subclass(*args_, **kwargs_)
        else:
            return prodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_cProdType(self, value):
        # Validate type cProdType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cProdType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cProdType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cProdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cProdType_patterns_, ))
    validate_cProdType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_cEANType(self, value):
        # Validate type cEANType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cEANType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cEANType_patterns_, ))
    validate_cEANType_patterns_ = [['^SEM GTIN$|^[0-9]{0}$|^[0-9]{8}$|^[0-9]{12,14}$']]
    def validate_xProdType(self, value):
        # Validate type xProdType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xProdType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xProdType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xProdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xProdType_patterns_, ))
    validate_xProdType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_NCMType(self, value):
        # Validate type NCMType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NCMType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NCMType_patterns_, ))
    validate_NCMType_patterns_ = [['^[0-9]{2}$|^[0-9]{8}$']]
    def validate_NVEType(self, value):
        # Validate type NVEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NVEType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NVEType_patterns_, ))
    validate_NVEType_patterns_ = [['^[A-Z]{2}[0-9]{4}$']]
    def validate_CESTType(self, value):
        # Validate type CESTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CESTType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CESTType_patterns_, ))
    validate_CESTType_patterns_ = [['^[0-9]{7}$']]
    def validate_indEscalaType(self, value):
        # Validate type indEscalaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['S', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indEscalaType' % {"value" : value.encode("utf-8")} )
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_cBenefType(self, value):
        # Validate type cBenefType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cBenefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cBenefType_patterns_, ))
    validate_cBenefType_patterns_ = [['^([!-ÿ]{8}$|^[!-ÿ]{10}$|^SEM CBENEF)?$']]
    def validate_EXTIPIType(self, value):
        # Validate type EXTIPIType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_EXTIPIType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_EXTIPIType_patterns_, ))
    validate_EXTIPIType_patterns_ = [['^[0-9]{2,3}$']]
    def validate_CFOPType(self, value):
        # Validate type CFOPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CFOPType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CFOPType_patterns_, ))
    validate_CFOPType_patterns_ = [['^[1,2,3,5,6,7]{1}[0-9]{3}$']]
    def validate_uComType(self, value):
        # Validate type uComType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on uComType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on uComType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_uComType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_uComType_patterns_, ))
    validate_uComType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1110v(self, value):
        # Validate type TDec_1110v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1110v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1110v_patterns_, ))
    validate_TDec_1110v_patterns_ = [['^0$|^0\\.[0-9]{1,10}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,10})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_cEANTribType(self, value):
        # Validate type cEANTribType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cEANTribType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cEANTribType_patterns_, ))
    validate_cEANTribType_patterns_ = [['^SEM GTIN$|^[0-9]{0}$|^[0-9]{8}$|^[0-9]{12,14}$']]
    def validate_uTribType(self, value):
        # Validate type uTribType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on uTribType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on uTribType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_uTribType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_uTribType_patterns_, ))
    validate_uTribType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_indTotType(self, value):
        # Validate type indTotType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indTotType' % {"value" : value.encode("utf-8")} )
    def validate_xPedType(self, value):
        # Validate type xPedType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xPedType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xPedType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xPedType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xPedType_patterns_, ))
    validate_xPedType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nItemPedType(self, value):
        # Validate type nItemPedType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nItemPedType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nItemPedType_patterns_, ))
    validate_nItemPedType_patterns_ = [['^[0-9]{1,6}$']]
    def validate_TGuid(self, value):
        # Validate type TGuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TGuid_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TGuid_patterns_, ))
    validate_TGuid_patterns_ = [['^[A-F0-9]{8}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{12}$']]
    def validate_nRECOPIType(self, value):
        # Validate type nRECOPIType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nRECOPIType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nRECOPIType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nRECOPIType_patterns_, ))
    validate_nRECOPIType_patterns_ = [['^[0-9]{20}$']]
    def hasContent_(self):
        if (
            self.cProd is not None or
            self.cEAN is not None or
            self.xProd is not None or
            self.NCM is not None or
            self.NVE or
            self.CEST is not None or
            self.indEscala is not None or
            self.CNPJFab is not None or
            self.cBenef is not None or
            self.EXTIPI is not None or
            self.CFOP is not None or
            self.uCom is not None or
            self.qCom is not None or
            self.vUnCom is not None or
            self.vProd is not None or
            self.cEANTrib is not None or
            self.uTrib is not None or
            self.qTrib is not None or
            self.vUnTrib is not None or
            self.vFrete is not None or
            self.vSeg is not None or
            self.vDesc is not None or
            self.vOutro is not None or
            self.indTot is not None or
            self.DI or
            self.detExport or
            self.xPed is not None or
            self.nItemPed is not None or
            self.nFCI is not None or
            self.rastro or
            self.veicProd is not None or
            self.med is not None or
            self.arma or
            self.comb is not None or
            self.nRECOPI is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='prodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('prodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='prodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='prodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='prodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='prodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cProd>%s</cProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cProd), input_name='cProd')), eol_))
        if self.cEAN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cEAN>%s</cEAN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cEAN), input_name='cEAN')), eol_))
        if self.xProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xProd>%s</xProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xProd), input_name='xProd')), eol_))
        if self.NCM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NCM>%s</NCM>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NCM), input_name='NCM')), eol_))
        for NVE_ in self.NVE:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NVE>%s</NVE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(NVE_), input_name='NVE')), eol_))
        if self.CEST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CEST>%s</CEST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CEST), input_name='CEST')), eol_))
        if self.indEscala is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indEscala>%s</indEscala>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indEscala), input_name='indEscala')), eol_))
        if self.CNPJFab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJFab>%s</CNPJFab>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJFab), input_name='CNPJFab')), eol_))
        if self.cBenef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cBenef>%s</cBenef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cBenef), input_name='cBenef')), eol_))
        if self.EXTIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EXTIPI>%s</EXTIPI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EXTIPI), input_name='EXTIPI')), eol_))
        if self.CFOP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CFOP>%s</CFOP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CFOP), input_name='CFOP')), eol_))
        if self.uCom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<uCom>%s</uCom>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.uCom), input_name='uCom')), eol_))
        if self.qCom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qCom>%s</qCom>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qCom), input_name='qCom')), eol_))
        if self.vUnCom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vUnCom>%s</vUnCom>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vUnCom), input_name='vUnCom')), eol_))
        if self.vProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vProd>%s</vProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vProd), input_name='vProd')), eol_))
        if self.cEANTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cEANTrib>%s</cEANTrib>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cEANTrib), input_name='cEANTrib')), eol_))
        if self.uTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<uTrib>%s</uTrib>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.uTrib), input_name='uTrib')), eol_))
        if self.qTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qTrib>%s</qTrib>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qTrib), input_name='qTrib')), eol_))
        if self.vUnTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vUnTrib>%s</vUnTrib>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vUnTrib), input_name='vUnTrib')), eol_))
        if self.vFrete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFrete>%s</vFrete>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFrete), input_name='vFrete')), eol_))
        if self.vSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vSeg>%s</vSeg>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vSeg), input_name='vSeg')), eol_))
        if self.vDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDesc>%s</vDesc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDesc), input_name='vDesc')), eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vOutro>%s</vOutro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vOutro), input_name='vOutro')), eol_))
        if self.indTot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indTot>%s</indTot>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indTot), input_name='indTot')), eol_))
        for DI_ in self.DI:
            DI_.export(outfile, level, namespace_, name_='DI', pretty_print=pretty_print)
        for detExport_ in self.detExport:
            detExport_.export(outfile, level, namespace_, name_='detExport', pretty_print=pretty_print)
        if self.xPed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xPed>%s</xPed>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xPed), input_name='xPed')), eol_))
        if self.nItemPed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nItemPed>%s</nItemPed>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nItemPed), input_name='nItemPed')), eol_))
        if self.nFCI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nFCI>%s</nFCI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nFCI), input_name='nFCI')), eol_))
        for rastro_ in self.rastro:
            rastro_.export(outfile, level, namespace_, name_='rastro', pretty_print=pretty_print)
        if self.veicProd is not None:
            self.veicProd.export(outfile, level, namespace_, name_='veicProd', pretty_print=pretty_print)
        if self.med is not None:
            self.med.export(outfile, level, namespace_, name_='med', pretty_print=pretty_print)
        for arma_ in self.arma:
            arma_.export(outfile, level, namespace_, name_='arma', pretty_print=pretty_print)
        if self.comb is not None:
            self.comb.export(outfile, level, namespace_, name_='comb', pretty_print=pretty_print)
        if self.nRECOPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nRECOPI>%s</nRECOPI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nRECOPI), input_name='nRECOPI')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cProd':
            cProd_ = child_.text
            cProd_ = self.gds_validate_string(cProd_, node, 'cProd')
            self.cProd = cProd_
            # validate type cProdType
            self.validate_cProdType(self.cProd)
        elif nodeName_ == 'cEAN':
            cEAN_ = child_.text
            cEAN_ = self.gds_validate_string(cEAN_, node, 'cEAN')
            self.cEAN = cEAN_
            # validate type cEANType
            self.validate_cEANType(self.cEAN)
        elif nodeName_ == 'xProd':
            xProd_ = child_.text
            xProd_ = self.gds_validate_string(xProd_, node, 'xProd')
            self.xProd = xProd_
            # validate type xProdType
            self.validate_xProdType(self.xProd)
        elif nodeName_ == 'NCM':
            NCM_ = child_.text
            NCM_ = self.gds_validate_string(NCM_, node, 'NCM')
            self.NCM = NCM_
            # validate type NCMType
            self.validate_NCMType(self.NCM)
        elif nodeName_ == 'NVE':
            NVE_ = child_.text
            NVE_ = self.gds_validate_string(NVE_, node, 'NVE')
            self.NVE.append(NVE_)
            # validate type NVEType
            self.validate_NVEType(self.NVE[-1])
        elif nodeName_ == 'CEST':
            CEST_ = child_.text
            CEST_ = self.gds_validate_string(CEST_, node, 'CEST')
            self.CEST = CEST_
            # validate type CESTType
            self.validate_CESTType(self.CEST)
        elif nodeName_ == 'indEscala':
            indEscala_ = child_.text
            indEscala_ = self.gds_validate_string(indEscala_, node, 'indEscala')
            self.indEscala = indEscala_
            # validate type indEscalaType
            self.validate_indEscalaType(self.indEscala)
        elif nodeName_ == 'CNPJFab':
            CNPJFab_ = child_.text
            CNPJFab_ = self.gds_validate_string(CNPJFab_, node, 'CNPJFab')
            self.CNPJFab = CNPJFab_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJFab)
        elif nodeName_ == 'cBenef':
            cBenef_ = child_.text
            cBenef_ = self.gds_validate_string(cBenef_, node, 'cBenef')
            self.cBenef = cBenef_
            # validate type cBenefType
            self.validate_cBenefType(self.cBenef)
        elif nodeName_ == 'EXTIPI':
            EXTIPI_ = child_.text
            EXTIPI_ = self.gds_validate_string(EXTIPI_, node, 'EXTIPI')
            self.EXTIPI = EXTIPI_
            # validate type EXTIPIType
            self.validate_EXTIPIType(self.EXTIPI)
        elif nodeName_ == 'CFOP':
            CFOP_ = child_.text
            CFOP_ = self.gds_validate_string(CFOP_, node, 'CFOP')
            self.CFOP = CFOP_
            # validate type CFOPType
            self.validate_CFOPType(self.CFOP)
        elif nodeName_ == 'uCom':
            uCom_ = child_.text
            uCom_ = self.gds_validate_string(uCom_, node, 'uCom')
            self.uCom = uCom_
            # validate type uComType
            self.validate_uComType(self.uCom)
        elif nodeName_ == 'qCom':
            qCom_ = child_.text
            qCom_ = self.gds_validate_string(qCom_, node, 'qCom')
            self.qCom = qCom_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.qCom)
        elif nodeName_ == 'vUnCom':
            vUnCom_ = child_.text
            vUnCom_ = self.gds_validate_string(vUnCom_, node, 'vUnCom')
            self.vUnCom = vUnCom_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.vUnCom)
        elif nodeName_ == 'vProd':
            vProd_ = child_.text
            vProd_ = self.gds_validate_string(vProd_, node, 'vProd')
            self.vProd = vProd_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vProd)
        elif nodeName_ == 'cEANTrib':
            cEANTrib_ = child_.text
            cEANTrib_ = self.gds_validate_string(cEANTrib_, node, 'cEANTrib')
            self.cEANTrib = cEANTrib_
            # validate type cEANTribType
            self.validate_cEANTribType(self.cEANTrib)
        elif nodeName_ == 'uTrib':
            uTrib_ = child_.text
            uTrib_ = self.gds_validate_string(uTrib_, node, 'uTrib')
            self.uTrib = uTrib_
            # validate type uTribType
            self.validate_uTribType(self.uTrib)
        elif nodeName_ == 'qTrib':
            qTrib_ = child_.text
            qTrib_ = self.gds_validate_string(qTrib_, node, 'qTrib')
            self.qTrib = qTrib_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.qTrib)
        elif nodeName_ == 'vUnTrib':
            vUnTrib_ = child_.text
            vUnTrib_ = self.gds_validate_string(vUnTrib_, node, 'vUnTrib')
            self.vUnTrib = vUnTrib_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.vUnTrib)
        elif nodeName_ == 'vFrete':
            vFrete_ = child_.text
            vFrete_ = self.gds_validate_string(vFrete_, node, 'vFrete')
            self.vFrete = vFrete_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vFrete)
        elif nodeName_ == 'vSeg':
            vSeg_ = child_.text
            vSeg_ = self.gds_validate_string(vSeg_, node, 'vSeg')
            self.vSeg = vSeg_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vSeg)
        elif nodeName_ == 'vDesc':
            vDesc_ = child_.text
            vDesc_ = self.gds_validate_string(vDesc_, node, 'vDesc')
            self.vDesc = vDesc_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDesc)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOutro)
        elif nodeName_ == 'indTot':
            indTot_ = child_.text
            indTot_ = self.gds_validate_string(indTot_, node, 'indTot')
            self.indTot = indTot_
            # validate type indTotType
            self.validate_indTotType(self.indTot)
        elif nodeName_ == 'DI':
            obj_ = DIType.factory()
            obj_.build(child_)
            self.DI.append(obj_)
            obj_.original_tagname_ = 'DI'
        elif nodeName_ == 'detExport':
            obj_ = detExportType.factory()
            obj_.build(child_)
            self.detExport.append(obj_)
            obj_.original_tagname_ = 'detExport'
        elif nodeName_ == 'xPed':
            xPed_ = child_.text
            xPed_ = self.gds_validate_string(xPed_, node, 'xPed')
            self.xPed = xPed_
            # validate type xPedType
            self.validate_xPedType(self.xPed)
        elif nodeName_ == 'nItemPed':
            nItemPed_ = child_.text
            nItemPed_ = self.gds_validate_string(nItemPed_, node, 'nItemPed')
            self.nItemPed = nItemPed_
            # validate type nItemPedType
            self.validate_nItemPedType(self.nItemPed)
        elif nodeName_ == 'nFCI':
            nFCI_ = child_.text
            nFCI_ = self.gds_validate_string(nFCI_, node, 'nFCI')
            self.nFCI = nFCI_
            # validate type TGuid
            self.validate_TGuid(self.nFCI)
        elif nodeName_ == 'rastro':
            obj_ = rastroType.factory()
            obj_.build(child_)
            self.rastro.append(obj_)
            obj_.original_tagname_ = 'rastro'
        elif nodeName_ == 'veicProd':
            obj_ = veicProdType.factory()
            obj_.build(child_)
            self.veicProd = obj_
            obj_.original_tagname_ = 'veicProd'
        elif nodeName_ == 'med':
            obj_ = medType.factory()
            obj_.build(child_)
            self.med = obj_
            obj_.original_tagname_ = 'med'
        elif nodeName_ == 'arma':
            obj_ = armaType.factory()
            obj_.build(child_)
            self.arma.append(obj_)
            obj_.original_tagname_ = 'arma'
        elif nodeName_ == 'comb':
            obj_ = combType.factory()
            obj_.build(child_)
            self.comb = obj_
            obj_.original_tagname_ = 'comb'
        elif nodeName_ == 'nRECOPI':
            nRECOPI_ = child_.text
            nRECOPI_ = self.gds_validate_string(nRECOPI_, node, 'nRECOPI')
            self.nRECOPI = nRECOPI_
            # validate type nRECOPIType
            self.validate_nRECOPIType(self.nRECOPI)
# end class prodType


class DIType(GeneratedsSuper):
    """Delcaração de Importação
    (NT 2011/004)"""
    subclass = None
    superclass = None
    def __init__(self, nDI=None, dDI=None, xLocDesemb=None, UFDesemb=None, dDesemb=None, tpViaTransp=None, vAFRMM=None, tpIntermedio=None, CNPJ=None, UFTerceiro=None, cExportador=None, adi=None):
        self.original_tagname_ = None
        self.nDI = nDI
        self.validate_nDIType(self.nDI)
        self.dDI = dDI
        self.validate_TData(self.dDI)
        self.xLocDesemb = xLocDesemb
        self.validate_xLocDesembType(self.xLocDesemb)
        self.UFDesemb = UFDesemb
        self.validate_TUfEmi(self.UFDesemb)
        self.dDesemb = dDesemb
        self.validate_TData(self.dDesemb)
        self.tpViaTransp = tpViaTransp
        self.validate_tpViaTranspType(self.tpViaTransp)
        self.vAFRMM = vAFRMM
        self.validate_TDec_1302(self.vAFRMM)
        self.tpIntermedio = tpIntermedio
        self.validate_tpIntermedioType(self.tpIntermedio)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.UFTerceiro = UFTerceiro
        self.validate_TUfEmi(self.UFTerceiro)
        self.cExportador = cExportador
        self.validate_cExportadorType(self.cExportador)
        if adi is None:
            self.adi = []
        else:
            self.adi = adi
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DIType.subclass:
            return DIType.subclass(*args_, **kwargs_)
        else:
            return DIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nDIType(self, value):
        # Validate type nDIType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nDIType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nDIType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nDIType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nDIType_patterns_, ))
    validate_nDIType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]
    def validate_xLocDesembType(self, value):
        # Validate type xLocDesembType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLocDesembType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLocDesembType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLocDesembType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLocDesembType_patterns_, ))
    validate_xLocDesembType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {"value" : value.encode("utf-8")} )
    def validate_tpViaTranspType(self, value):
        # Validate type tpViaTranspType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpViaTranspType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_tpIntermedioType(self, value):
        # Validate type tpIntermedioType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpIntermedioType' % {"value" : value.encode("utf-8")} )
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_cExportadorType(self, value):
        # Validate type cExportadorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cExportadorType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cExportadorType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cExportadorType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cExportadorType_patterns_, ))
    validate_cExportadorType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.nDI is not None or
            self.dDI is not None or
            self.xLocDesemb is not None or
            self.UFDesemb is not None or
            self.dDesemb is not None or
            self.tpViaTransp is not None or
            self.vAFRMM is not None or
            self.tpIntermedio is not None or
            self.CNPJ is not None or
            self.UFTerceiro is not None or
            self.cExportador is not None or
            self.adi
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DIType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DIType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nDI>%s</nDI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nDI), input_name='nDI')), eol_))
        if self.dDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dDI>%s</dDI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dDI), input_name='dDI')), eol_))
        if self.xLocDesemb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLocDesemb>%s</xLocDesemb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLocDesemb), input_name='xLocDesemb')), eol_))
        if self.UFDesemb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UFDesemb>%s</UFDesemb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UFDesemb), input_name='UFDesemb')), eol_))
        if self.dDesemb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dDesemb>%s</dDesemb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dDesemb), input_name='dDesemb')), eol_))
        if self.tpViaTransp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpViaTransp>%s</tpViaTransp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpViaTransp), input_name='tpViaTransp')), eol_))
        if self.vAFRMM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vAFRMM>%s</vAFRMM>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vAFRMM), input_name='vAFRMM')), eol_))
        if self.tpIntermedio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpIntermedio>%s</tpIntermedio>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpIntermedio), input_name='tpIntermedio')), eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.UFTerceiro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UFTerceiro>%s</UFTerceiro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UFTerceiro), input_name='UFTerceiro')), eol_))
        if self.cExportador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cExportador>%s</cExportador>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cExportador), input_name='cExportador')), eol_))
        for adi_ in self.adi:
            adi_.export(outfile, level, namespace_, name_='adi', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nDI':
            nDI_ = child_.text
            nDI_ = self.gds_validate_string(nDI_, node, 'nDI')
            self.nDI = nDI_
            # validate type nDIType
            self.validate_nDIType(self.nDI)
        elif nodeName_ == 'dDI':
            dDI_ = child_.text
            dDI_ = self.gds_validate_string(dDI_, node, 'dDI')
            self.dDI = dDI_
            # validate type TData
            self.validate_TData(self.dDI)
        elif nodeName_ == 'xLocDesemb':
            xLocDesemb_ = child_.text
            xLocDesemb_ = self.gds_validate_string(xLocDesemb_, node, 'xLocDesemb')
            self.xLocDesemb = xLocDesemb_
            # validate type xLocDesembType
            self.validate_xLocDesembType(self.xLocDesemb)
        elif nodeName_ == 'UFDesemb':
            UFDesemb_ = child_.text
            UFDesemb_ = self.gds_validate_string(UFDesemb_, node, 'UFDesemb')
            self.UFDesemb = UFDesemb_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UFDesemb)
        elif nodeName_ == 'dDesemb':
            dDesemb_ = child_.text
            dDesemb_ = self.gds_validate_string(dDesemb_, node, 'dDesemb')
            self.dDesemb = dDesemb_
            # validate type TData
            self.validate_TData(self.dDesemb)
        elif nodeName_ == 'tpViaTransp':
            tpViaTransp_ = child_.text
            tpViaTransp_ = self.gds_validate_string(tpViaTransp_, node, 'tpViaTransp')
            self.tpViaTransp = tpViaTransp_
            # validate type tpViaTranspType
            self.validate_tpViaTranspType(self.tpViaTransp)
        elif nodeName_ == 'vAFRMM':
            vAFRMM_ = child_.text
            vAFRMM_ = self.gds_validate_string(vAFRMM_, node, 'vAFRMM')
            self.vAFRMM = vAFRMM_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vAFRMM)
        elif nodeName_ == 'tpIntermedio':
            tpIntermedio_ = child_.text
            tpIntermedio_ = self.gds_validate_string(tpIntermedio_, node, 'tpIntermedio')
            self.tpIntermedio = tpIntermedio_
            # validate type tpIntermedioType
            self.validate_tpIntermedioType(self.tpIntermedio)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'UFTerceiro':
            UFTerceiro_ = child_.text
            UFTerceiro_ = self.gds_validate_string(UFTerceiro_, node, 'UFTerceiro')
            self.UFTerceiro = UFTerceiro_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UFTerceiro)
        elif nodeName_ == 'cExportador':
            cExportador_ = child_.text
            cExportador_ = self.gds_validate_string(cExportador_, node, 'cExportador')
            self.cExportador = cExportador_
            # validate type cExportadorType
            self.validate_cExportadorType(self.cExportador)
        elif nodeName_ == 'adi':
            obj_ = adiType.factory()
            obj_.build(child_)
            self.adi.append(obj_)
            obj_.original_tagname_ = 'adi'
# end class DIType


class adiType(GeneratedsSuper):
    """Adições (NT 2011/004)"""
    subclass = None
    superclass = None
    def __init__(self, nAdicao=None, nSeqAdic=None, cFabricante=None, vDescDI=None, nDraw=None):
        self.original_tagname_ = None
        self.nAdicao = nAdicao
        self.validate_nAdicaoType(self.nAdicao)
        self.nSeqAdic = nSeqAdic
        self.validate_nSeqAdicType(self.nSeqAdic)
        self.cFabricante = cFabricante
        self.validate_cFabricanteType(self.cFabricante)
        self.vDescDI = vDescDI
        self.validate_TDec_1302Opc(self.vDescDI)
        self.nDraw = nDraw
        self.validate_nDrawType(self.nDraw)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adiType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adiType.subclass:
            return adiType.subclass(*args_, **kwargs_)
        else:
            return adiType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nAdicaoType(self, value):
        # Validate type nAdicaoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nAdicaoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nAdicaoType_patterns_, ))
    validate_nAdicaoType_patterns_ = [['^[1-9]{1}[0-9]{0,2}$']]
    def validate_nSeqAdicType(self, value):
        # Validate type nSeqAdicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nSeqAdicType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nSeqAdicType_patterns_, ))
    validate_nSeqAdicType_patterns_ = [['^[1-9]{1}[0-9]{0,2}$']]
    def validate_cFabricanteType(self, value):
        # Validate type cFabricanteType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cFabricanteType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cFabricanteType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cFabricanteType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cFabricanteType_patterns_, ))
    validate_cFabricanteType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_nDrawType(self, value):
        # Validate type nDrawType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nDrawType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nDrawType_patterns_, ))
    validate_nDrawType_patterns_ = [['^[0-9]{0,11}$']]
    def hasContent_(self):
        if (
            self.nAdicao is not None or
            self.nSeqAdic is not None or
            self.cFabricante is not None or
            self.vDescDI is not None or
            self.nDraw is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='adiType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adiType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='adiType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='adiType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='adiType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='adiType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nAdicao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nAdicao>%s</nAdicao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nAdicao), input_name='nAdicao')), eol_))
        if self.nSeqAdic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nSeqAdic>%s</nSeqAdic>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nSeqAdic), input_name='nSeqAdic')), eol_))
        if self.cFabricante is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cFabricante>%s</cFabricante>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cFabricante), input_name='cFabricante')), eol_))
        if self.vDescDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDescDI>%s</vDescDI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDescDI), input_name='vDescDI')), eol_))
        if self.nDraw is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nDraw>%s</nDraw>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nDraw), input_name='nDraw')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nAdicao':
            nAdicao_ = child_.text
            nAdicao_ = self.gds_validate_string(nAdicao_, node, 'nAdicao')
            self.nAdicao = nAdicao_
            # validate type nAdicaoType
            self.validate_nAdicaoType(self.nAdicao)
        elif nodeName_ == 'nSeqAdic':
            nSeqAdic_ = child_.text
            nSeqAdic_ = self.gds_validate_string(nSeqAdic_, node, 'nSeqAdic')
            self.nSeqAdic = nSeqAdic_
            # validate type nSeqAdicType
            self.validate_nSeqAdicType(self.nSeqAdic)
        elif nodeName_ == 'cFabricante':
            cFabricante_ = child_.text
            cFabricante_ = self.gds_validate_string(cFabricante_, node, 'cFabricante')
            self.cFabricante = cFabricante_
            # validate type cFabricanteType
            self.validate_cFabricanteType(self.cFabricante)
        elif nodeName_ == 'vDescDI':
            vDescDI_ = child_.text
            vDescDI_ = self.gds_validate_string(vDescDI_, node, 'vDescDI')
            self.vDescDI = vDescDI_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescDI)
        elif nodeName_ == 'nDraw':
            nDraw_ = child_.text
            nDraw_ = self.gds_validate_string(nDraw_, node, 'nDraw')
            self.nDraw = nDraw_
            # validate type nDrawType
            self.validate_nDrawType(self.nDraw)
# end class adiType


class detExportType(GeneratedsSuper):
    """Detalhe da exportação"""
    subclass = None
    superclass = None
    def __init__(self, nDraw=None, exportInd=None):
        self.original_tagname_ = None
        self.nDraw = nDraw
        self.validate_nDrawType6(self.nDraw)
        self.exportInd = exportInd
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detExportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detExportType.subclass:
            return detExportType.subclass(*args_, **kwargs_)
        else:
            return detExportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nDrawType6(self, value):
        # Validate type nDrawType6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nDrawType6_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nDrawType6_patterns_, ))
    validate_nDrawType6_patterns_ = [['^[0-9]{0,11}$']]
    def hasContent_(self):
        if (
            self.nDraw is not None or
            self.exportInd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='detExportType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detExportType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='detExportType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='detExportType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='detExportType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='detExportType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDraw is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nDraw>%s</nDraw>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nDraw), input_name='nDraw')), eol_))
        if self.exportInd is not None:
            self.exportInd.export(outfile, level, namespace_, name_='exportInd', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nDraw':
            nDraw_ = child_.text
            nDraw_ = self.gds_validate_string(nDraw_, node, 'nDraw')
            self.nDraw = nDraw_
            # validate type nDrawType6
            self.validate_nDrawType6(self.nDraw)
        elif nodeName_ == 'exportInd':
            obj_ = exportIndType.factory()
            obj_.build(child_)
            self.exportInd = obj_
            obj_.original_tagname_ = 'exportInd'
# end class detExportType


class exportIndType(GeneratedsSuper):
    """Exportação indireta"""
    subclass = None
    superclass = None
    def __init__(self, nRE=None, chNFe=None, qExport=None):
        self.original_tagname_ = None
        self.nRE = nRE
        self.validate_nREType(self.nRE)
        self.chNFe = chNFe
        self.validate_TChNFe(self.chNFe)
        self.qExport = qExport
        self.validate_TDec_1104v(self.qExport)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exportIndType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exportIndType.subclass:
            return exportIndType.subclass(*args_, **kwargs_)
        else:
            return exportIndType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nREType(self, value):
        # Validate type nREType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nREType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nREType_patterns_, ))
    validate_nREType_patterns_ = [['^[0-9]{0,12}$']]
    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [['^[0-9]{44}$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def hasContent_(self):
        if (
            self.nRE is not None or
            self.chNFe is not None or
            self.qExport is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exportIndType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exportIndType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exportIndType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exportIndType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exportIndType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='exportIndType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nRE>%s</nRE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nRE), input_name='nRE')), eol_))
        if self.chNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<chNFe>%s</chNFe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.chNFe), input_name='chNFe')), eol_))
        if self.qExport is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qExport>%s</qExport>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qExport), input_name='qExport')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nRE':
            nRE_ = child_.text
            nRE_ = self.gds_validate_string(nRE_, node, 'nRE')
            self.nRE = nRE_
            # validate type nREType
            self.validate_nREType(self.nRE)
        elif nodeName_ == 'chNFe':
            chNFe_ = child_.text
            chNFe_ = self.gds_validate_string(chNFe_, node, 'chNFe')
            self.chNFe = chNFe_
            # validate type TChNFe
            self.validate_TChNFe(self.chNFe)
        elif nodeName_ == 'qExport':
            qExport_ = child_.text
            qExport_ = self.gds_validate_string(qExport_, node, 'qExport')
            self.qExport = qExport_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.qExport)
# end class exportIndType


class rastroType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nLote=None, qLote=None, dFab=None, dVal=None, cAgreg=None):
        self.original_tagname_ = None
        self.nLote = nLote
        self.validate_nLoteType(self.nLote)
        self.qLote = qLote
        self.validate_TDec_0803v(self.qLote)
        self.dFab = dFab
        self.validate_TData(self.dFab)
        self.dVal = dVal
        self.validate_TData(self.dVal)
        self.cAgreg = cAgreg
        self.validate_cAgregType(self.cAgreg)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rastroType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rastroType.subclass:
            return rastroType.subclass(*args_, **kwargs_)
        else:
            return rastroType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nLoteType(self, value):
        # Validate type nLoteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nLoteType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nLoteType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0803v(self, value):
        # Validate type TDec_0803v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0803v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0803v_patterns_, ))
    validate_TDec_0803v_patterns_ = [['^0$|^0\\.[0-9]{3}$|^[1-9]{1}[0-9]{0,7}(\\.[0-9]{1,3})?$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]
    def validate_cAgregType(self, value):
        # Validate type cAgregType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cAgregType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cAgregType_patterns_, ))
    validate_cAgregType_patterns_ = [['^[0-9]{1,20}$']]
    def hasContent_(self):
        if (
            self.nLote is not None or
            self.qLote is not None or
            self.dFab is not None or
            self.dVal is not None or
            self.cAgreg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='rastroType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rastroType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rastroType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='rastroType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='rastroType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='rastroType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nLote>%s</nLote>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nLote), input_name='nLote')), eol_))
        if self.qLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qLote>%s</qLote>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qLote), input_name='qLote')), eol_))
        if self.dFab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dFab>%s</dFab>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dFab), input_name='dFab')), eol_))
        if self.dVal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dVal>%s</dVal>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dVal), input_name='dVal')), eol_))
        if self.cAgreg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cAgreg>%s</cAgreg>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cAgreg), input_name='cAgreg')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLote':
            nLote_ = child_.text
            nLote_ = self.gds_validate_string(nLote_, node, 'nLote')
            self.nLote = nLote_
            # validate type nLoteType
            self.validate_nLoteType(self.nLote)
        elif nodeName_ == 'qLote':
            qLote_ = child_.text
            qLote_ = self.gds_validate_string(qLote_, node, 'qLote')
            self.qLote = qLote_
            # validate type TDec_0803v
            self.validate_TDec_0803v(self.qLote)
        elif nodeName_ == 'dFab':
            dFab_ = child_.text
            dFab_ = self.gds_validate_string(dFab_, node, 'dFab')
            self.dFab = dFab_
            # validate type TData
            self.validate_TData(self.dFab)
        elif nodeName_ == 'dVal':
            dVal_ = child_.text
            dVal_ = self.gds_validate_string(dVal_, node, 'dVal')
            self.dVal = dVal_
            # validate type TData
            self.validate_TData(self.dVal)
        elif nodeName_ == 'cAgreg':
            cAgreg_ = child_.text
            cAgreg_ = self.gds_validate_string(cAgreg_, node, 'cAgreg')
            self.cAgreg = cAgreg_
            # validate type cAgregType
            self.validate_cAgregType(self.cAgreg)
# end class rastroType


class veicProdType(GeneratedsSuper):
    """Veículos novos"""
    subclass = None
    superclass = None
    def __init__(self, tpOp=None, chassi=None, cCor=None, xCor=None, pot=None, cilin=None, pesoL=None, pesoB=None, nSerie=None, tpComb=None, nMotor=None, CMT=None, dist=None, anoMod=None, anoFab=None, tpPint=None, tpVeic=None, espVeic=None, VIN=None, condVeic=None, cMod=None, cCorDENATRAN=None, lota=None, tpRest=None):
        self.original_tagname_ = None
        self.tpOp = tpOp
        self.validate_tpOpType(self.tpOp)
        self.chassi = chassi
        self.validate_chassiType(self.chassi)
        self.cCor = cCor
        self.validate_cCorType(self.cCor)
        self.xCor = xCor
        self.validate_xCorType(self.xCor)
        self.pot = pot
        self.validate_potType(self.pot)
        self.cilin = cilin
        self.validate_cilinType(self.cilin)
        self.pesoL = pesoL
        self.validate_pesoLType(self.pesoL)
        self.pesoB = pesoB
        self.validate_pesoBType(self.pesoB)
        self.nSerie = nSerie
        self.validate_nSerieType(self.nSerie)
        self.tpComb = tpComb
        self.validate_tpCombType(self.tpComb)
        self.nMotor = nMotor
        self.validate_nMotorType(self.nMotor)
        self.CMT = CMT
        self.validate_CMTType(self.CMT)
        self.dist = dist
        self.validate_distType(self.dist)
        self.anoMod = anoMod
        self.validate_anoModType(self.anoMod)
        self.anoFab = anoFab
        self.validate_anoFabType(self.anoFab)
        self.tpPint = tpPint
        self.validate_tpPintType(self.tpPint)
        self.tpVeic = tpVeic
        self.validate_tpVeicType(self.tpVeic)
        self.espVeic = espVeic
        self.validate_espVeicType(self.espVeic)
        self.VIN = VIN
        self.validate_VINType(self.VIN)
        self.condVeic = condVeic
        self.validate_condVeicType(self.condVeic)
        self.cMod = cMod
        self.validate_cModType(self.cMod)
        self.cCorDENATRAN = cCorDENATRAN
        self.validate_cCorDENATRANType(self.cCorDENATRAN)
        self.lota = lota
        self.validate_lotaType(self.lota)
        self.tpRest = tpRest
        self.validate_tpRestType(self.tpRest)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, veicProdType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if veicProdType.subclass:
            return veicProdType.subclass(*args_, **kwargs_)
        else:
            return veicProdType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpOpType(self, value):
        # Validate type tpOpType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpOpType' % {"value" : value.encode("utf-8")} )
    def validate_chassiType(self, value):
        # Validate type chassiType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 17:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on chassiType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_chassiType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_chassiType_patterns_, ))
    validate_chassiType_patterns_ = [['^[A-Z0-9]+$']]
    def validate_cCorType(self, value):
        # Validate type cCorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cCorType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cCorType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cCorType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cCorType_patterns_, ))
    validate_cCorType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xCorType(self, value):
        # Validate type xCorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCorType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCorType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCorType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCorType_patterns_, ))
    validate_xCorType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_potType(self, value):
        # Validate type potType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on potType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on potType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_potType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_potType_patterns_, ))
    validate_potType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_cilinType(self, value):
        # Validate type cilinType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cilinType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cilinType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cilinType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cilinType_patterns_, ))
    validate_cilinType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_pesoLType(self, value):
        # Validate type pesoLType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on pesoLType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on pesoLType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_pesoLType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_pesoLType_patterns_, ))
    validate_pesoLType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_pesoBType(self, value):
        # Validate type pesoBType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on pesoBType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on pesoBType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_pesoBType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_pesoBType_patterns_, ))
    validate_pesoBType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nSerieType(self, value):
        # Validate type nSerieType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nSerieType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nSerieType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nSerieType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nSerieType_patterns_, ))
    validate_nSerieType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_tpCombType(self, value):
        # Validate type tpCombType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCombType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCombType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCombType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCombType_patterns_, ))
    validate_tpCombType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nMotorType(self, value):
        # Validate type nMotorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 21:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nMotorType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nMotorType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nMotorType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nMotorType_patterns_, ))
    validate_nMotorType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_CMTType(self, value):
        # Validate type CMTType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CMTType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CMTType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_CMTType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CMTType_patterns_, ))
    validate_CMTType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_distType(self, value):
        # Validate type distType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on distType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on distType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_distType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_distType_patterns_, ))
    validate_distType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_anoModType(self, value):
        # Validate type anoModType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_anoModType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_anoModType_patterns_, ))
    validate_anoModType_patterns_ = [['^[0-9]{4}$']]
    def validate_anoFabType(self, value):
        # Validate type anoFabType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_anoFabType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_anoFabType_patterns_, ))
    validate_anoFabType_patterns_ = [['^[0-9]{4}$']]
    def validate_tpPintType(self, value):
        # Validate type tpPintType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on tpPintType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpPintType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpPintType_patterns_, ))
    validate_tpPintType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_tpVeicType(self, value):
        # Validate type tpVeicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpVeicType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpVeicType_patterns_, ))
    validate_tpVeicType_patterns_ = [['^[0-9]{1,2}$']]
    def validate_espVeicType(self, value):
        # Validate type espVeicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_espVeicType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_espVeicType_patterns_, ))
    validate_espVeicType_patterns_ = [['^[0-9]{1}$']]
    def validate_VINType(self, value):
        # Validate type VINType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['R', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VINType' % {"value" : value.encode("utf-8")} )
            if len(str(value)) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on VINType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_VINType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_VINType_patterns_, ))
    validate_VINType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_condVeicType(self, value):
        # Validate type condVeicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on condVeicType' % {"value" : value.encode("utf-8")} )
    def validate_cModType(self, value):
        # Validate type cModType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cModType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cModType_patterns_, ))
    validate_cModType_patterns_ = [['^[0-9]{1,6}$']]
    def validate_cCorDENATRANType(self, value):
        # Validate type cCorDENATRANType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cCorDENATRANType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cCorDENATRANType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cCorDENATRANType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cCorDENATRANType_patterns_, ))
    validate_cCorDENATRANType_patterns_ = [['^[0-9]{1,2}$']]
    def validate_lotaType(self, value):
        # Validate type lotaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on lotaType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on lotaType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_lotaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_lotaType_patterns_, ))
    validate_lotaType_patterns_ = [['^[0-9]{1,3}$']]
    def validate_tpRestType(self, value):
        # Validate type tpRestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpRestType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.tpOp is not None or
            self.chassi is not None or
            self.cCor is not None or
            self.xCor is not None or
            self.pot is not None or
            self.cilin is not None or
            self.pesoL is not None or
            self.pesoB is not None or
            self.nSerie is not None or
            self.tpComb is not None or
            self.nMotor is not None or
            self.CMT is not None or
            self.dist is not None or
            self.anoMod is not None or
            self.anoFab is not None or
            self.tpPint is not None or
            self.tpVeic is not None or
            self.espVeic is not None or
            self.VIN is not None or
            self.condVeic is not None or
            self.cMod is not None or
            self.cCorDENATRAN is not None or
            self.lota is not None or
            self.tpRest is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='veicProdType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('veicProdType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='veicProdType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='veicProdType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='veicProdType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='veicProdType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpOp>%s</tpOp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpOp), input_name='tpOp')), eol_))
        if self.chassi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<chassi>%s</chassi>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.chassi), input_name='chassi')), eol_))
        if self.cCor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cCor>%s</cCor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cCor), input_name='cCor')), eol_))
        if self.xCor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xCor>%s</xCor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xCor), input_name='xCor')), eol_))
        if self.pot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pot>%s</pot>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pot), input_name='pot')), eol_))
        if self.cilin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cilin>%s</cilin>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cilin), input_name='cilin')), eol_))
        if self.pesoL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pesoL>%s</pesoL>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pesoL), input_name='pesoL')), eol_))
        if self.pesoB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pesoB>%s</pesoB>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pesoB), input_name='pesoB')), eol_))
        if self.nSerie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nSerie>%s</nSerie>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nSerie), input_name='nSerie')), eol_))
        if self.tpComb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpComb>%s</tpComb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpComb), input_name='tpComb')), eol_))
        if self.nMotor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nMotor>%s</nMotor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nMotor), input_name='nMotor')), eol_))
        if self.CMT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CMT>%s</CMT>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CMT), input_name='CMT')), eol_))
        if self.dist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dist>%s</dist>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dist), input_name='dist')), eol_))
        if self.anoMod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<anoMod>%s</anoMod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.anoMod), input_name='anoMod')), eol_))
        if self.anoFab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<anoFab>%s</anoFab>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.anoFab), input_name='anoFab')), eol_))
        if self.tpPint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpPint>%s</tpPint>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpPint), input_name='tpPint')), eol_))
        if self.tpVeic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpVeic>%s</tpVeic>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpVeic), input_name='tpVeic')), eol_))
        if self.espVeic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<espVeic>%s</espVeic>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.espVeic), input_name='espVeic')), eol_))
        if self.VIN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VIN>%s</VIN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VIN), input_name='VIN')), eol_))
        if self.condVeic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<condVeic>%s</condVeic>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.condVeic), input_name='condVeic')), eol_))
        if self.cMod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMod>%s</cMod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMod), input_name='cMod')), eol_))
        if self.cCorDENATRAN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cCorDENATRAN>%s</cCorDENATRAN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cCorDENATRAN), input_name='cCorDENATRAN')), eol_))
        if self.lota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<lota>%s</lota>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.lota), input_name='lota')), eol_))
        if self.tpRest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpRest>%s</tpRest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpRest), input_name='tpRest')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpOp':
            tpOp_ = child_.text
            tpOp_ = self.gds_validate_string(tpOp_, node, 'tpOp')
            self.tpOp = tpOp_
            # validate type tpOpType
            self.validate_tpOpType(self.tpOp)
        elif nodeName_ == 'chassi':
            chassi_ = child_.text
            chassi_ = self.gds_validate_string(chassi_, node, 'chassi')
            self.chassi = chassi_
            # validate type chassiType
            self.validate_chassiType(self.chassi)
        elif nodeName_ == 'cCor':
            cCor_ = child_.text
            cCor_ = self.gds_validate_string(cCor_, node, 'cCor')
            self.cCor = cCor_
            # validate type cCorType
            self.validate_cCorType(self.cCor)
        elif nodeName_ == 'xCor':
            xCor_ = child_.text
            xCor_ = self.gds_validate_string(xCor_, node, 'xCor')
            self.xCor = xCor_
            # validate type xCorType
            self.validate_xCorType(self.xCor)
        elif nodeName_ == 'pot':
            pot_ = child_.text
            pot_ = self.gds_validate_string(pot_, node, 'pot')
            self.pot = pot_
            # validate type potType
            self.validate_potType(self.pot)
        elif nodeName_ == 'cilin':
            cilin_ = child_.text
            cilin_ = self.gds_validate_string(cilin_, node, 'cilin')
            self.cilin = cilin_
            # validate type cilinType
            self.validate_cilinType(self.cilin)
        elif nodeName_ == 'pesoL':
            pesoL_ = child_.text
            pesoL_ = self.gds_validate_string(pesoL_, node, 'pesoL')
            self.pesoL = pesoL_
            # validate type pesoLType
            self.validate_pesoLType(self.pesoL)
        elif nodeName_ == 'pesoB':
            pesoB_ = child_.text
            pesoB_ = self.gds_validate_string(pesoB_, node, 'pesoB')
            self.pesoB = pesoB_
            # validate type pesoBType
            self.validate_pesoBType(self.pesoB)
        elif nodeName_ == 'nSerie':
            nSerie_ = child_.text
            nSerie_ = self.gds_validate_string(nSerie_, node, 'nSerie')
            self.nSerie = nSerie_
            # validate type nSerieType
            self.validate_nSerieType(self.nSerie)
        elif nodeName_ == 'tpComb':
            tpComb_ = child_.text
            tpComb_ = self.gds_validate_string(tpComb_, node, 'tpComb')
            self.tpComb = tpComb_
            # validate type tpCombType
            self.validate_tpCombType(self.tpComb)
        elif nodeName_ == 'nMotor':
            nMotor_ = child_.text
            nMotor_ = self.gds_validate_string(nMotor_, node, 'nMotor')
            self.nMotor = nMotor_
            # validate type nMotorType
            self.validate_nMotorType(self.nMotor)
        elif nodeName_ == 'CMT':
            CMT_ = child_.text
            CMT_ = self.gds_validate_string(CMT_, node, 'CMT')
            self.CMT = CMT_
            # validate type CMTType
            self.validate_CMTType(self.CMT)
        elif nodeName_ == 'dist':
            dist_ = child_.text
            dist_ = self.gds_validate_string(dist_, node, 'dist')
            self.dist = dist_
            # validate type distType
            self.validate_distType(self.dist)
        elif nodeName_ == 'anoMod':
            anoMod_ = child_.text
            anoMod_ = self.gds_validate_string(anoMod_, node, 'anoMod')
            self.anoMod = anoMod_
            # validate type anoModType
            self.validate_anoModType(self.anoMod)
        elif nodeName_ == 'anoFab':
            anoFab_ = child_.text
            anoFab_ = self.gds_validate_string(anoFab_, node, 'anoFab')
            self.anoFab = anoFab_
            # validate type anoFabType
            self.validate_anoFabType(self.anoFab)
        elif nodeName_ == 'tpPint':
            tpPint_ = child_.text
            tpPint_ = self.gds_validate_string(tpPint_, node, 'tpPint')
            self.tpPint = tpPint_
            # validate type tpPintType
            self.validate_tpPintType(self.tpPint)
        elif nodeName_ == 'tpVeic':
            tpVeic_ = child_.text
            tpVeic_ = self.gds_validate_string(tpVeic_, node, 'tpVeic')
            self.tpVeic = tpVeic_
            # validate type tpVeicType
            self.validate_tpVeicType(self.tpVeic)
        elif nodeName_ == 'espVeic':
            espVeic_ = child_.text
            espVeic_ = self.gds_validate_string(espVeic_, node, 'espVeic')
            self.espVeic = espVeic_
            # validate type espVeicType
            self.validate_espVeicType(self.espVeic)
        elif nodeName_ == 'VIN':
            VIN_ = child_.text
            VIN_ = self.gds_validate_string(VIN_, node, 'VIN')
            self.VIN = VIN_
            # validate type VINType
            self.validate_VINType(self.VIN)
        elif nodeName_ == 'condVeic':
            condVeic_ = child_.text
            condVeic_ = self.gds_validate_string(condVeic_, node, 'condVeic')
            self.condVeic = condVeic_
            # validate type condVeicType
            self.validate_condVeicType(self.condVeic)
        elif nodeName_ == 'cMod':
            cMod_ = child_.text
            cMod_ = self.gds_validate_string(cMod_, node, 'cMod')
            self.cMod = cMod_
            # validate type cModType
            self.validate_cModType(self.cMod)
        elif nodeName_ == 'cCorDENATRAN':
            cCorDENATRAN_ = child_.text
            cCorDENATRAN_ = self.gds_validate_string(cCorDENATRAN_, node, 'cCorDENATRAN')
            self.cCorDENATRAN = cCorDENATRAN_
            # validate type cCorDENATRANType
            self.validate_cCorDENATRANType(self.cCorDENATRAN)
        elif nodeName_ == 'lota':
            lota_ = child_.text
            lota_ = self.gds_validate_string(lota_, node, 'lota')
            self.lota = lota_
            # validate type lotaType
            self.validate_lotaType(self.lota)
        elif nodeName_ == 'tpRest':
            tpRest_ = child_.text
            tpRest_ = self.gds_validate_string(tpRest_, node, 'tpRest')
            self.tpRest = tpRest_
            # validate type tpRestType
            self.validate_tpRestType(self.tpRest)
# end class veicProdType


class medType(GeneratedsSuper):
    """grupo do detalhamento de Medicamentos e de matérias-primas
    farmacêuticas"""
    subclass = None
    superclass = None
    def __init__(self, cProdANVISA=None, xMotivoIsencao=None, vPMC=None):
        self.original_tagname_ = None
        self.cProdANVISA = cProdANVISA
        self.validate_cProdANVISAType(self.cProdANVISA)
        self.xMotivoIsencao = xMotivoIsencao
        self.validate_xMotivoIsencaoType(self.xMotivoIsencao)
        self.vPMC = vPMC
        self.validate_TDec_1302(self.vPMC)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, medType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if medType.subclass:
            return medType.subclass(*args_, **kwargs_)
        else:
            return medType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_cProdANVISAType(self, value):
        # Validate type cProdANVISAType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cProdANVISAType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cProdANVISAType_patterns_, ))
    validate_cProdANVISAType_patterns_ = [['^[0-9]{13}$|^ISENTO$'], ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xMotivoIsencaoType(self, value):
        # Validate type xMotivoIsencaoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMotivoIsencaoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMotivoIsencaoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMotivoIsencaoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMotivoIsencaoType_patterns_, ))
    validate_xMotivoIsencaoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.cProdANVISA is not None or
            self.xMotivoIsencao is not None or
            self.vPMC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='medType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('medType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='medType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='medType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='medType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='medType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cProdANVISA is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cProdANVISA>%s</cProdANVISA>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cProdANVISA), input_name='cProdANVISA')), eol_))
        if self.xMotivoIsencao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMotivoIsencao>%s</xMotivoIsencao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMotivoIsencao), input_name='xMotivoIsencao')), eol_))
        if self.vPMC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vPMC>%s</vPMC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vPMC), input_name='vPMC')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cProdANVISA':
            cProdANVISA_ = child_.text
            cProdANVISA_ = self.gds_validate_string(cProdANVISA_, node, 'cProdANVISA')
            self.cProdANVISA = cProdANVISA_
            # validate type cProdANVISAType
            self.validate_cProdANVISAType(self.cProdANVISA)
        elif nodeName_ == 'xMotivoIsencao':
            xMotivoIsencao_ = child_.text
            xMotivoIsencao_ = self.gds_validate_string(xMotivoIsencao_, node, 'xMotivoIsencao')
            self.xMotivoIsencao = xMotivoIsencao_
            # validate type xMotivoIsencaoType
            self.validate_xMotivoIsencaoType(self.xMotivoIsencao)
        elif nodeName_ == 'vPMC':
            vPMC_ = child_.text
            vPMC_ = self.gds_validate_string(vPMC_, node, 'vPMC')
            self.vPMC = vPMC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPMC)
# end class medType


class armaType(GeneratedsSuper):
    """Armamentos"""
    subclass = None
    superclass = None
    def __init__(self, tpArma=None, nSerie=None, nCano=None, descr=None):
        self.original_tagname_ = None
        self.tpArma = tpArma
        self.validate_tpArmaType(self.tpArma)
        self.nSerie = nSerie
        self.validate_nSerieType7(self.nSerie)
        self.nCano = nCano
        self.validate_nCanoType(self.nCano)
        self.descr = descr
        self.validate_descrType(self.descr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, armaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if armaType.subclass:
            return armaType.subclass(*args_, **kwargs_)
        else:
            return armaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpArmaType(self, value):
        # Validate type tpArmaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpArmaType' % {"value" : value.encode("utf-8")} )
    def validate_nSerieType7(self, value):
        # Validate type nSerieType7, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nSerieType7' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nSerieType7' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nSerieType7_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nSerieType7_patterns_, ))
    validate_nSerieType7_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nCanoType(self, value):
        # Validate type nCanoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nCanoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nCanoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nCanoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nCanoType_patterns_, ))
    validate_nCanoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_descrType(self, value):
        # Validate type descrType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 256:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descrType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descrType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_descrType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_descrType_patterns_, ))
    validate_descrType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.tpArma is not None or
            self.nSerie is not None or
            self.nCano is not None or
            self.descr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='armaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('armaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='armaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='armaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='armaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='armaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpArma is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpArma>%s</tpArma>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpArma), input_name='tpArma')), eol_))
        if self.nSerie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nSerie>%s</nSerie>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nSerie), input_name='nSerie')), eol_))
        if self.nCano is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nCano>%s</nCano>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nCano), input_name='nCano')), eol_))
        if self.descr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<descr>%s</descr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.descr), input_name='descr')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpArma':
            tpArma_ = child_.text
            tpArma_ = self.gds_validate_string(tpArma_, node, 'tpArma')
            self.tpArma = tpArma_
            # validate type tpArmaType
            self.validate_tpArmaType(self.tpArma)
        elif nodeName_ == 'nSerie':
            nSerie_ = child_.text
            nSerie_ = self.gds_validate_string(nSerie_, node, 'nSerie')
            self.nSerie = nSerie_
            # validate type nSerieType7
            self.validate_nSerieType7(self.nSerie)
        elif nodeName_ == 'nCano':
            nCano_ = child_.text
            nCano_ = self.gds_validate_string(nCano_, node, 'nCano')
            self.nCano = nCano_
            # validate type nCanoType
            self.validate_nCanoType(self.nCano)
        elif nodeName_ == 'descr':
            descr_ = child_.text
            descr_ = self.gds_validate_string(descr_, node, 'descr')
            self.descr = descr_
            # validate type descrType
            self.validate_descrType(self.descr)
# end class armaType


class combType(GeneratedsSuper):
    """Informar apenas para operações com combustíveis líquidos"""
    subclass = None
    superclass = None
    def __init__(self, cProdANP=None, descANP=None, pGLP=None, pGNn=None, pGNi=None, vPart=None, CODIF=None, qTemp=None, UFCons=None, CIDE=None, encerrante=None):
        self.original_tagname_ = None
        self.cProdANP = cProdANP
        self.validate_cProdANPType(self.cProdANP)
        self.descANP = descANP
        self.validate_descANPType(self.descANP)
        self.pGLP = pGLP
        self.validate_TDec_0302a04Max100(self.pGLP)
        self.pGNn = pGNn
        self.validate_TDec_0302a04Max100(self.pGNn)
        self.pGNi = pGNi
        self.validate_TDec_0302a04Max100(self.pGNi)
        self.vPart = vPart
        self.validate_TDec_1302(self.vPart)
        self.CODIF = CODIF
        self.validate_CODIFType(self.CODIF)
        self.qTemp = qTemp
        self.validate_TDec_1204temperatura(self.qTemp)
        self.UFCons = UFCons
        self.validate_TUf(self.UFCons)
        self.CIDE = CIDE
        self.encerrante = encerrante
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, combType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if combType.subclass:
            return combType.subclass(*args_, **kwargs_)
        else:
            return combType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_cProdANPType(self, value):
        # Validate type cProdANPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cProdANPType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cProdANPType_patterns_, ))
    validate_cProdANPType_patterns_ = [['^[0-9]{9}$']]
    def validate_descANPType(self, value):
        # Validate type descANPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 95:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descANPType' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descANPType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04Max100(self, value):
        # Validate type TDec_0302a04Max100, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Max100_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Max100_patterns_, ))
    validate_TDec_0302a04Max100_patterns_ = [['^0(\\.[0-9]{2,4})?$|^[1-9]{1}[0-9]{0,1}(\\.[0-9]{2,4})?$|^100(\\.0{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_CODIFType(self, value):
        # Validate type CODIFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CODIFType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CODIFType_patterns_, ))
    validate_CODIFType_patterns_ = [['^[0-9]{1,21}$']]
    def validate_TDec_1204temperatura(self, value):
        # Validate type TDec_1204temperatura, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204temperatura_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204temperatura_patterns_, ))
    validate_TDec_1204temperatura_patterns_ = [['^0\\.[1-9]{1}[0-9]{3}$|^0\\.[0-9]{3}[1-9]{1}$|^0\\.[0-9]{2}[1-9]{1}[0-9]{1}$|^0\\.[0-9]{1}[1-9]{1}[0-9]{2}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{4})?$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cProdANP is not None or
            self.descANP is not None or
            self.pGLP is not None or
            self.pGNn is not None or
            self.pGNi is not None or
            self.vPart is not None or
            self.CODIF is not None or
            self.qTemp is not None or
            self.UFCons is not None or
            self.CIDE is not None or
            self.encerrante is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='combType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('combType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='combType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='combType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='combType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='combType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cProdANP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cProdANP>%s</cProdANP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cProdANP), input_name='cProdANP')), eol_))
        if self.descANP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<descANP>%s</descANP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.descANP), input_name='descANP')), eol_))
        if self.pGLP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pGLP>%s</pGLP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pGLP), input_name='pGLP')), eol_))
        if self.pGNn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pGNn>%s</pGNn>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pGNn), input_name='pGNn')), eol_))
        if self.pGNi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pGNi>%s</pGNi>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pGNi), input_name='pGNi')), eol_))
        if self.vPart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vPart>%s</vPart>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vPart), input_name='vPart')), eol_))
        if self.CODIF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CODIF>%s</CODIF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CODIF), input_name='CODIF')), eol_))
        if self.qTemp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qTemp>%s</qTemp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qTemp), input_name='qTemp')), eol_))
        if self.UFCons is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UFCons>%s</UFCons>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UFCons), input_name='UFCons')), eol_))
        if self.CIDE is not None:
            self.CIDE.export(outfile, level, namespace_, name_='CIDE', pretty_print=pretty_print)
        if self.encerrante is not None:
            self.encerrante.export(outfile, level, namespace_, name_='encerrante', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cProdANP':
            cProdANP_ = child_.text
            cProdANP_ = self.gds_validate_string(cProdANP_, node, 'cProdANP')
            self.cProdANP = cProdANP_
            # validate type cProdANPType
            self.validate_cProdANPType(self.cProdANP)
        elif nodeName_ == 'descANP':
            descANP_ = child_.text
            descANP_ = self.gds_validate_string(descANP_, node, 'descANP')
            self.descANP = descANP_
            # validate type descANPType
            self.validate_descANPType(self.descANP)
        elif nodeName_ == 'pGLP':
            pGLP_ = child_.text
            pGLP_ = self.gds_validate_string(pGLP_, node, 'pGLP')
            self.pGLP = pGLP_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pGLP)
        elif nodeName_ == 'pGNn':
            pGNn_ = child_.text
            pGNn_ = self.gds_validate_string(pGNn_, node, 'pGNn')
            self.pGNn = pGNn_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pGNn)
        elif nodeName_ == 'pGNi':
            pGNi_ = child_.text
            pGNi_ = self.gds_validate_string(pGNi_, node, 'pGNi')
            self.pGNi = pGNi_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pGNi)
        elif nodeName_ == 'vPart':
            vPart_ = child_.text
            vPart_ = self.gds_validate_string(vPart_, node, 'vPart')
            self.vPart = vPart_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPart)
        elif nodeName_ == 'CODIF':
            CODIF_ = child_.text
            CODIF_ = self.gds_validate_string(CODIF_, node, 'CODIF')
            self.CODIF = CODIF_
            # validate type CODIFType
            self.validate_CODIFType(self.CODIF)
        elif nodeName_ == 'qTemp':
            qTemp_ = child_.text
            qTemp_ = self.gds_validate_string(qTemp_, node, 'qTemp')
            self.qTemp = qTemp_
            # validate type TDec_1204temperatura
            self.validate_TDec_1204temperatura(self.qTemp)
        elif nodeName_ == 'UFCons':
            UFCons_ = child_.text
            UFCons_ = self.gds_validate_string(UFCons_, node, 'UFCons')
            self.UFCons = UFCons_
            # validate type TUf
            self.validate_TUf(self.UFCons)
        elif nodeName_ == 'CIDE':
            obj_ = CIDEType.factory()
            obj_.build(child_)
            self.CIDE = obj_
            obj_.original_tagname_ = 'CIDE'
        elif nodeName_ == 'encerrante':
            obj_ = encerranteType.factory()
            obj_.build(child_)
            self.encerrante = obj_
            obj_.original_tagname_ = 'encerrante'
# end class combType


class CIDEType(GeneratedsSuper):
    """CIDE Combustíveis"""
    subclass = None
    superclass = None
    def __init__(self, qBCProd=None, vAliqProd=None, vCIDE=None):
        self.original_tagname_ = None
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104(self.vAliqProd)
        self.vCIDE = vCIDE
        self.validate_TDec_1302(self.vCIDE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CIDEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CIDEType.subclass:
            return CIDEType.subclass(*args_, **kwargs_)
        else:
            return CIDEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [['^0$|^0\\.[0-9]{4}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCIDE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CIDEType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CIDEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CIDEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CIDEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CIDEType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CIDEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qBCProd>%s</qBCProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vAliqProd>%s</vAliqProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), eol_))
        if self.vCIDE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vCIDE>%s</vCIDE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vCIDE), input_name='vCIDE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vAliqProd)
        elif nodeName_ == 'vCIDE':
            vCIDE_ = child_.text
            vCIDE_ = self.gds_validate_string(vCIDE_, node, 'vCIDE')
            self.vCIDE = vCIDE_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCIDE)
# end class CIDEType


class encerranteType(GeneratedsSuper):
    """ Informações do grupo de "encerrante" """
    subclass = None
    superclass = None
    def __init__(self, nBico=None, nBomba=None, nTanque=None, vEncIni=None, vEncFin=None):
        self.original_tagname_ = None
        self.nBico = nBico
        self.validate_nBicoType(self.nBico)
        self.nBomba = nBomba
        self.validate_nBombaType(self.nBomba)
        self.nTanque = nTanque
        self.validate_nTanqueType(self.nTanque)
        self.vEncIni = vEncIni
        self.validate_TDec_1203(self.vEncIni)
        self.vEncFin = vEncFin
        self.validate_TDec_1203(self.vEncFin)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, encerranteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if encerranteType.subclass:
            return encerranteType.subclass(*args_, **kwargs_)
        else:
            return encerranteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nBicoType(self, value):
        # Validate type nBicoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nBicoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nBicoType_patterns_, ))
    validate_nBicoType_patterns_ = [['^[0-9]{1,3}$']]
    def validate_nBombaType(self, value):
        # Validate type nBombaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nBombaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nBombaType_patterns_, ))
    validate_nBombaType_patterns_ = [['^[0-9]{1,3}$']]
    def validate_nTanqueType(self, value):
        # Validate type nTanqueType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nTanqueType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nTanqueType_patterns_, ))
    validate_nTanqueType_patterns_ = [['^[0-9]{1,3}$']]
    def validate_TDec_1203(self, value):
        # Validate type TDec_1203, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1203_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1203_patterns_, ))
    validate_TDec_1203_patterns_ = [['^0$|^0\\.[0-9]{3}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{3})?$']]
    def hasContent_(self):
        if (
            self.nBico is not None or
            self.nBomba is not None or
            self.nTanque is not None or
            self.vEncIni is not None or
            self.vEncFin is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='encerranteType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('encerranteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='encerranteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='encerranteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='encerranteType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='encerranteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nBico is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nBico>%s</nBico>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nBico), input_name='nBico')), eol_))
        if self.nBomba is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nBomba>%s</nBomba>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nBomba), input_name='nBomba')), eol_))
        if self.nTanque is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nTanque>%s</nTanque>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nTanque), input_name='nTanque')), eol_))
        if self.vEncIni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vEncIni>%s</vEncIni>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vEncIni), input_name='vEncIni')), eol_))
        if self.vEncFin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vEncFin>%s</vEncFin>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vEncFin), input_name='vEncFin')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nBico':
            nBico_ = child_.text
            nBico_ = self.gds_validate_string(nBico_, node, 'nBico')
            self.nBico = nBico_
            # validate type nBicoType
            self.validate_nBicoType(self.nBico)
        elif nodeName_ == 'nBomba':
            nBomba_ = child_.text
            nBomba_ = self.gds_validate_string(nBomba_, node, 'nBomba')
            self.nBomba = nBomba_
            # validate type nBombaType
            self.validate_nBombaType(self.nBomba)
        elif nodeName_ == 'nTanque':
            nTanque_ = child_.text
            nTanque_ = self.gds_validate_string(nTanque_, node, 'nTanque')
            self.nTanque = nTanque_
            # validate type nTanqueType
            self.validate_nTanqueType(self.nTanque)
        elif nodeName_ == 'vEncIni':
            vEncIni_ = child_.text
            vEncIni_ = self.gds_validate_string(vEncIni_, node, 'vEncIni')
            self.vEncIni = vEncIni_
            # validate type TDec_1203
            self.validate_TDec_1203(self.vEncIni)
        elif nodeName_ == 'vEncFin':
            vEncFin_ = child_.text
            vEncFin_ = self.gds_validate_string(vEncFin_, node, 'vEncFin')
            self.vEncFin = vEncFin_
            # validate type TDec_1203
            self.validate_TDec_1203(self.vEncFin)
# end class encerranteType


class impostoType(GeneratedsSuper):
    """Tributos incidentes nos produtos ou serviços da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, vTotTrib=None, ICMS=None, II=None, IPI=None, ISSQN=None, PIS=None, PISST=None, COFINS=None, COFINSST=None, ICMSUFDest=None):
        self.original_tagname_ = None
        self.vTotTrib = vTotTrib
        self.validate_TDec_1302(self.vTotTrib)
        self.ICMS = ICMS
        self.II = II
        self.IPI = IPI
        self.ISSQN = ISSQN
        self.PIS = PIS
        self.PISST = PISST
        self.COFINS = COFINS
        self.COFINSST = COFINSST
        self.ICMSUFDest = ICMSUFDest
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, impostoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if impostoType.subclass:
            return impostoType.subclass(*args_, **kwargs_)
        else:
            return impostoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vTotTrib is not None or
            self.ICMS is not None or
            self.II is not None or
            self.IPI is not None or
            self.ISSQN is not None or
            self.PIS is not None or
            self.PISST is not None or
            self.COFINS is not None or
            self.COFINSST is not None or
            self.ICMSUFDest is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='impostoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('impostoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='impostoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='impostoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='impostoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='impostoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vTotTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vTotTrib>%s</vTotTrib>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vTotTrib), input_name='vTotTrib')), eol_))
        if self.ICMS is not None:
            self.ICMS.export(outfile, level, namespace_, name_='ICMS', pretty_print=pretty_print)
        if self.II is not None:
            self.II.export(outfile, level, namespace_, name_='II', pretty_print=pretty_print)
        if self.IPI is not None:
            self.IPI.export(outfile, level, namespace_, name_='IPI', pretty_print=pretty_print)
        if self.ISSQN is not None:
            self.ISSQN.export(outfile, level, namespace_, name_='ISSQN', pretty_print=pretty_print)
        if self.PIS is not None:
            self.PIS.export(outfile, level, namespace_, name_='PIS', pretty_print=pretty_print)
        if self.PISST is not None:
            self.PISST.export(outfile, level, namespace_, name_='PISST', pretty_print=pretty_print)
        if self.COFINS is not None:
            self.COFINS.export(outfile, level, namespace_, name_='COFINS', pretty_print=pretty_print)
        if self.COFINSST is not None:
            self.COFINSST.export(outfile, level, namespace_, name_='COFINSST', pretty_print=pretty_print)
        if self.ICMSUFDest is not None:
            self.ICMSUFDest.export(outfile, level, namespace_, name_='ICMSUFDest', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vTotTrib':
            vTotTrib_ = child_.text
            vTotTrib_ = self.gds_validate_string(vTotTrib_, node, 'vTotTrib')
            self.vTotTrib = vTotTrib_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTotTrib)
        elif nodeName_ == 'ICMS':
            obj_ = ICMSType.factory()
            obj_.build(child_)
            self.ICMS = obj_
            obj_.original_tagname_ = 'ICMS'
        elif nodeName_ == 'II':
            obj_ = IIType.factory()
            obj_.build(child_)
            self.II = obj_
            obj_.original_tagname_ = 'II'
        elif nodeName_ == 'IPI':
            obj_ = TIpi.factory()
            obj_.build(child_)
            self.IPI = obj_
            obj_.original_tagname_ = 'IPI'
        elif nodeName_ == 'ISSQN':
            obj_ = ISSQNType.factory()
            obj_.build(child_)
            self.ISSQN = obj_
            obj_.original_tagname_ = 'ISSQN'
        elif nodeName_ == 'PIS':
            obj_ = PISType.factory()
            obj_.build(child_)
            self.PIS = obj_
            obj_.original_tagname_ = 'PIS'
        elif nodeName_ == 'PISST':
            obj_ = PISSTType.factory()
            obj_.build(child_)
            self.PISST = obj_
            obj_.original_tagname_ = 'PISST'
        elif nodeName_ == 'COFINS':
            obj_ = COFINSType.factory()
            obj_.build(child_)
            self.COFINS = obj_
            obj_.original_tagname_ = 'COFINS'
        elif nodeName_ == 'COFINSST':
            obj_ = COFINSSTType.factory()
            obj_.build(child_)
            self.COFINSST = obj_
            obj_.original_tagname_ = 'COFINSST'
        elif nodeName_ == 'ICMSUFDest':
            obj_ = ICMSUFDestType.factory()
            obj_.build(child_)
            self.ICMSUFDest = obj_
            obj_.original_tagname_ = 'ICMSUFDest'
# end class impostoType


class ICMSType(GeneratedsSuper):
    """Dados do ICMS Normal e ST"""
    subclass = None
    superclass = None
    def __init__(self, ICMS00=None, ICMS10=None, ICMS20=None, ICMS30=None, ICMS40=None, ICMS51=None, ICMS60=None, ICMS70=None, ICMS90=None, ICMSPart=None, ICMSST=None, ICMSSN101=None, ICMSSN102=None, ICMSSN201=None, ICMSSN202=None, ICMSSN500=None, ICMSSN900=None):
        self.original_tagname_ = None
        self.ICMS00 = ICMS00
        self.ICMS10 = ICMS10
        self.ICMS20 = ICMS20
        self.ICMS30 = ICMS30
        self.ICMS40 = ICMS40
        self.ICMS51 = ICMS51
        self.ICMS60 = ICMS60
        self.ICMS70 = ICMS70
        self.ICMS90 = ICMS90
        self.ICMSPart = ICMSPart
        self.ICMSST = ICMSST
        self.ICMSSN101 = ICMSSN101
        self.ICMSSN102 = ICMSSN102
        self.ICMSSN201 = ICMSSN201
        self.ICMSSN202 = ICMSSN202
        self.ICMSSN500 = ICMSSN500
        self.ICMSSN900 = ICMSSN900
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSType.subclass:
            return ICMSType.subclass(*args_, **kwargs_)
        else:
            return ICMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ICMS00 is not None or
            self.ICMS10 is not None or
            self.ICMS20 is not None or
            self.ICMS30 is not None or
            self.ICMS40 is not None or
            self.ICMS51 is not None or
            self.ICMS60 is not None or
            self.ICMS70 is not None or
            self.ICMS90 is not None or
            self.ICMSPart is not None or
            self.ICMSST is not None or
            self.ICMSSN101 is not None or
            self.ICMSSN102 is not None or
            self.ICMSSN201 is not None or
            self.ICMSSN202 is not None or
            self.ICMSSN500 is not None or
            self.ICMSSN900 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMS00 is not None:
            self.ICMS00.export(outfile, level, namespace_, name_='ICMS00', pretty_print=pretty_print)
        if self.ICMS10 is not None:
            self.ICMS10.export(outfile, level, namespace_, name_='ICMS10', pretty_print=pretty_print)
        if self.ICMS20 is not None:
            self.ICMS20.export(outfile, level, namespace_, name_='ICMS20', pretty_print=pretty_print)
        if self.ICMS30 is not None:
            self.ICMS30.export(outfile, level, namespace_, name_='ICMS30', pretty_print=pretty_print)
        if self.ICMS40 is not None:
            self.ICMS40.export(outfile, level, namespace_, name_='ICMS40', pretty_print=pretty_print)
        if self.ICMS51 is not None:
            self.ICMS51.export(outfile, level, namespace_, name_='ICMS51', pretty_print=pretty_print)
        if self.ICMS60 is not None:
            self.ICMS60.export(outfile, level, namespace_, name_='ICMS60', pretty_print=pretty_print)
        if self.ICMS70 is not None:
            self.ICMS70.export(outfile, level, namespace_, name_='ICMS70', pretty_print=pretty_print)
        if self.ICMS90 is not None:
            self.ICMS90.export(outfile, level, namespace_, name_='ICMS90', pretty_print=pretty_print)
        if self.ICMSPart is not None:
            self.ICMSPart.export(outfile, level, namespace_, name_='ICMSPart', pretty_print=pretty_print)
        if self.ICMSST is not None:
            self.ICMSST.export(outfile, level, namespace_, name_='ICMSST', pretty_print=pretty_print)
        if self.ICMSSN101 is not None:
            self.ICMSSN101.export(outfile, level, namespace_, name_='ICMSSN101', pretty_print=pretty_print)
        if self.ICMSSN102 is not None:
            self.ICMSSN102.export(outfile, level, namespace_, name_='ICMSSN102', pretty_print=pretty_print)
        if self.ICMSSN201 is not None:
            self.ICMSSN201.export(outfile, level, namespace_, name_='ICMSSN201', pretty_print=pretty_print)
        if self.ICMSSN202 is not None:
            self.ICMSSN202.export(outfile, level, namespace_, name_='ICMSSN202', pretty_print=pretty_print)
        if self.ICMSSN500 is not None:
            self.ICMSSN500.export(outfile, level, namespace_, name_='ICMSSN500', pretty_print=pretty_print)
        if self.ICMSSN900 is not None:
            self.ICMSSN900.export(outfile, level, namespace_, name_='ICMSSN900', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ICMS00':
            obj_ = ICMS00Type.factory()
            obj_.build(child_)
            self.ICMS00 = obj_
            obj_.original_tagname_ = 'ICMS00'
        elif nodeName_ == 'ICMS10':
            obj_ = ICMS10Type.factory()
            obj_.build(child_)
            self.ICMS10 = obj_
            obj_.original_tagname_ = 'ICMS10'
        elif nodeName_ == 'ICMS20':
            obj_ = ICMS20Type.factory()
            obj_.build(child_)
            self.ICMS20 = obj_
            obj_.original_tagname_ = 'ICMS20'
        elif nodeName_ == 'ICMS30':
            obj_ = ICMS30Type.factory()
            obj_.build(child_)
            self.ICMS30 = obj_
            obj_.original_tagname_ = 'ICMS30'
        elif nodeName_ == 'ICMS40':
            obj_ = ICMS40Type.factory()
            obj_.build(child_)
            self.ICMS40 = obj_
            obj_.original_tagname_ = 'ICMS40'
        elif nodeName_ == 'ICMS51':
            obj_ = ICMS51Type.factory()
            obj_.build(child_)
            self.ICMS51 = obj_
            obj_.original_tagname_ = 'ICMS51'
        elif nodeName_ == 'ICMS60':
            obj_ = ICMS60Type.factory()
            obj_.build(child_)
            self.ICMS60 = obj_
            obj_.original_tagname_ = 'ICMS60'
        elif nodeName_ == 'ICMS70':
            obj_ = ICMS70Type.factory()
            obj_.build(child_)
            self.ICMS70 = obj_
            obj_.original_tagname_ = 'ICMS70'
        elif nodeName_ == 'ICMS90':
            obj_ = ICMS90Type.factory()
            obj_.build(child_)
            self.ICMS90 = obj_
            obj_.original_tagname_ = 'ICMS90'
        elif nodeName_ == 'ICMSPart':
            obj_ = ICMSPartType.factory()
            obj_.build(child_)
            self.ICMSPart = obj_
            obj_.original_tagname_ = 'ICMSPart'
        elif nodeName_ == 'ICMSST':
            obj_ = ICMSSTType.factory()
            obj_.build(child_)
            self.ICMSST = obj_
            obj_.original_tagname_ = 'ICMSST'
        elif nodeName_ == 'ICMSSN101':
            obj_ = ICMSSN101Type.factory()
            obj_.build(child_)
            self.ICMSSN101 = obj_
            obj_.original_tagname_ = 'ICMSSN101'
        elif nodeName_ == 'ICMSSN102':
            obj_ = ICMSSN102Type.factory()
            obj_.build(child_)
            self.ICMSSN102 = obj_
            obj_.original_tagname_ = 'ICMSSN102'
        elif nodeName_ == 'ICMSSN201':
            obj_ = ICMSSN201Type.factory()
            obj_.build(child_)
            self.ICMSSN201 = obj_
            obj_.original_tagname_ = 'ICMSSN201'
        elif nodeName_ == 'ICMSSN202':
            obj_ = ICMSSN202Type.factory()
            obj_.build(child_)
            self.ICMSSN202 = obj_
            obj_.original_tagname_ = 'ICMSSN202'
        elif nodeName_ == 'ICMSSN500':
            obj_ = ICMSSN500Type.factory()
            obj_.build(child_)
            self.ICMSSN500 = obj_
            obj_.original_tagname_ = 'ICMSSN500'
        elif nodeName_ == 'ICMSSN900':
            obj_ = ICMSSN900Type.factory()
            obj_.build(child_)
            self.ICMSSN900 = obj_
            obj_.original_tagname_ = 'ICMSSN900'
# end class ICMSType


class ICMS00Type(GeneratedsSuper):
    """Tributação pelo ICMS
    00 - Tributada integralmente"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, vBC=None, pICMS=None, vICMS=None, pFCP=None, vFCP=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType(self.CST)
        self.modBC = modBC
        self.validate_modBCType(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS00Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS00Type.subclass:
            return ICMS00Type.subclass(*args_, **kwargs_)
        else:
            return ICMS00Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType(self, value):
        # Validate type CSTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['00']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType' % {"value" : value.encode("utf-8")} )
    def validate_modBCType(self, value):
        # Validate type modBCType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.pFCP is not None or
            self.vFCP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS00Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS00Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS00Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS00Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS00Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS00Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBC>%s</modBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMS>%s</pICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMS>%s</vICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCP>%s</pFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCP>%s</vFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType
            self.validate_CSTType(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType
            self.validate_modBCType(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
# end class ICMS00Type


class ICMS10Type(GeneratedsSuper):
    """Tributação pelo ICMS
    10 - Tributada e com cobrança do ICMS por substituição tributária"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, vBC=None, pICMS=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType8(self.CST)
        self.modBC = modBC
        self.validate_modBCType9(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.modBCST = modBCST
        self.validate_modBCSTType(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS10Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS10Type.subclass:
            return ICMS10Type.subclass(*args_, **kwargs_)
        else:
            return ICMS10Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType8(self, value):
        # Validate type CSTType8, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['10']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType8' % {"value" : value.encode("utf-8")} )
    def validate_modBCType9(self, value):
        # Validate type modBCType9, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType9' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_modBCSTType(self, value):
        # Validate type modBCSTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS10Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS10Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS10Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS10Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS10Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS10Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBC>%s</modBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMS>%s</pICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMS>%s</vICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCP>%s</vBCFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCP), input_name='vBCFCP')), eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCP>%s</pFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCP>%s</vFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBCST>%s</modBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pMVAST>%s</pMVAST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBCST>%s</pRedBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCST>%s</vBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSST>%s</pICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSST>%s</vICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCPST>%s</vBCFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCPST>%s</pFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPST>%s</vFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType8
            self.validate_CSTType8(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType9
            self.validate_modBCType9(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType
            self.validate_modBCSTType(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
# end class ICMS10Type


class ICMS20Type(GeneratedsSuper):
    """Tributção pelo ICMS
    20 - Com redução de base de cálculo"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, pRedBC=None, vBC=None, pICMS=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, vICMSDeson=None, motDesICMS=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType10(self.CST)
        self.modBC = modBC
        self.validate_modBCType11(self.modBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04(self.pRedBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType(self.motDesICMS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS20Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS20Type.subclass:
            return ICMS20Type.subclass(*args_, **kwargs_)
        else:
            return ICMS20Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType10(self, value):
        # Validate type CSTType10, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['20']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType10' % {"value" : value.encode("utf-8")} )
    def validate_modBCType11(self, value):
        # Validate type modBCType11, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType11' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_motDesICMSType(self, value):
        # Validate type motDesICMSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['3', '9', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS20Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS20Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS20Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS20Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS20Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS20Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBC>%s</modBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBC>%s</pRedBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMS>%s</pICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMS>%s</vICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCP>%s</vBCFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCP), input_name='vBCFCP')), eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCP>%s</pFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCP>%s</vFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSDeson>%s</vICMSDeson>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<motDesICMS>%s</motDesICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.motDesICMS), input_name='motDesICMS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType10
            self.validate_CSTType10(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType11
            self.validate_modBCType11(self.modBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pRedBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType
            self.validate_motDesICMSType(self.motDesICMS)
# end class ICMS20Type


class ICMS30Type(GeneratedsSuper):
    """Tributação pelo ICMS
    30 - Isenta ou não tributada e com cobrança do ICMS por substituição
    tributária"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, vICMSDeson=None, motDesICMS=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType12(self.CST)
        self.modBCST = modBCST
        self.validate_modBCSTType13(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType14(self.motDesICMS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS30Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS30Type.subclass:
            return ICMS30Type.subclass(*args_, **kwargs_)
        else:
            return ICMS30Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType12(self, value):
        # Validate type CSTType12, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['30']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType12' % {"value" : value.encode("utf-8")} )
    def validate_modBCSTType13(self, value):
        # Validate type modBCSTType13, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType13' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_motDesICMSType14(self, value):
        # Validate type motDesICMSType14, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['6', '7', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType14' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS30Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS30Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS30Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS30Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS30Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS30Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBCST>%s</modBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pMVAST>%s</pMVAST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBCST>%s</pRedBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCST>%s</vBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSST>%s</pICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSST>%s</vICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCPST>%s</vBCFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCPST>%s</pFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPST>%s</vFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSDeson>%s</vICMSDeson>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<motDesICMS>%s</motDesICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.motDesICMS), input_name='motDesICMS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType12
            self.validate_CSTType12(self.CST)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType13
            self.validate_modBCSTType13(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType14
            self.validate_motDesICMSType14(self.motDesICMS)
# end class ICMS30Type


class ICMS40Type(GeneratedsSuper):
    """Tributação pelo ICMS
    40 - Isenta
    41 - Não tributada
    50 - Suspensão"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, vICMSDeson=None, motDesICMS=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType15(self.CST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType16(self.motDesICMS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS40Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS40Type.subclass:
            return ICMS40Type.subclass(*args_, **kwargs_)
        else:
            return ICMS40Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType15(self, value):
        # Validate type CSTType15, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['40', '41', '50']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType15' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_motDesICMSType16(self, value):
        # Validate type motDesICMSType16, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '3', '4', '5', '6', '7', '8', '9', '10', '11', '16', '90']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType16' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS40Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS40Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS40Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS40Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS40Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS40Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSDeson>%s</vICMSDeson>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<motDesICMS>%s</motDesICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.motDesICMS), input_name='motDesICMS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType15
            self.validate_CSTType15(self.CST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType16
            self.validate_motDesICMSType16(self.motDesICMS)
# end class ICMS40Type


class ICMS51Type(GeneratedsSuper):
    """Tributção pelo ICMS
    51 - Diferimento
    A exigência do preenchimento das informações do ICMS diferido fica à
    critério de cada UF."""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, pRedBC=None, vBC=None, pICMS=None, vICMSOp=None, pDif=None, vICMSDif=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType17(self.CST)
        self.modBC = modBC
        self.validate_modBCType18(self.modBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04(self.pRedBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMSOp = vICMSOp
        self.validate_TDec_1302(self.vICMSOp)
        self.pDif = pDif
        self.validate_TDec_0302a04Max100(self.pDif)
        self.vICMSDif = vICMSDif
        self.validate_TDec_1302(self.vICMSDif)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS51Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS51Type.subclass:
            return ICMS51Type.subclass(*args_, **kwargs_)
        else:
            return ICMS51Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType17(self, value):
        # Validate type CSTType17, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['51']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType17' % {"value" : value.encode("utf-8")} )
    def validate_modBCType18(self, value):
        # Validate type modBCType18, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType18' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Max100(self, value):
        # Validate type TDec_0302a04Max100, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Max100_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Max100_patterns_, ))
    validate_TDec_0302a04Max100_patterns_ = [['^0(\\.[0-9]{2,4})?$|^[1-9]{1}[0-9]{0,1}(\\.[0-9]{2,4})?$|^100(\\.0{2,4})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMSOp is not None or
            self.pDif is not None or
            self.vICMSDif is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS51Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS51Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS51Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS51Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS51Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS51Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBC>%s</modBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBC>%s</pRedBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMS>%s</pICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), eol_))
        if self.vICMSOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSOp>%s</vICMSOp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSOp), input_name='vICMSOp')), eol_))
        if self.pDif is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pDif>%s</pDif>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pDif), input_name='pDif')), eol_))
        if self.vICMSDif is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSDif>%s</vICMSDif>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDif), input_name='vICMSDif')), eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMS>%s</vICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCP>%s</vBCFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCP), input_name='vBCFCP')), eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCP>%s</pFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCP>%s</vFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType17
            self.validate_CSTType17(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType18
            self.validate_modBCType18(self.modBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pRedBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMSOp':
            vICMSOp_ = child_.text
            vICMSOp_ = self.gds_validate_string(vICMSOp_, node, 'vICMSOp')
            self.vICMSOp = vICMSOp_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSOp)
        elif nodeName_ == 'pDif':
            pDif_ = child_.text
            pDif_ = self.gds_validate_string(pDif_, node, 'pDif')
            self.pDif = pDif_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pDif)
        elif nodeName_ == 'vICMSDif':
            vICMSDif_ = child_.text
            vICMSDif_ = self.gds_validate_string(vICMSDif_, node, 'vICMSDif')
            self.vICMSDif = vICMSDif_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDif)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
# end class ICMS51Type


class ICMS60Type(GeneratedsSuper):
    """Tributação pelo ICMS
    60 - ICMS cobrado anteriormente por substituição tributária"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, vBCSTRet=None, pST=None, vICMSSubstituto=None, vICMSSTRet=None, vBCFCPSTRet=None, pFCPSTRet=None, vFCPSTRet=None, pRedBCEfet=None, vBCEfet=None, pICMSEfet=None, vICMSEfet=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType19(self.CST)
        self.vBCSTRet = vBCSTRet
        self.validate_TDec_1302(self.vBCSTRet)
        self.pST = pST
        self.validate_TDec_0302a04Opc(self.pST)
        self.vICMSSubstituto = vICMSSubstituto
        self.validate_TDec_1302(self.vICMSSubstituto)
        self.vICMSSTRet = vICMSSTRet
        self.validate_TDec_1302(self.vICMSSTRet)
        self.vBCFCPSTRet = vBCFCPSTRet
        self.validate_TDec_1302(self.vBCFCPSTRet)
        self.pFCPSTRet = pFCPSTRet
        self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        self.vFCPSTRet = vFCPSTRet
        self.validate_TDec_1302(self.vFCPSTRet)
        self.pRedBCEfet = pRedBCEfet
        self.validate_TDec_0302a04Opc(self.pRedBCEfet)
        self.vBCEfet = vBCEfet
        self.validate_TDec_1302(self.vBCEfet)
        self.pICMSEfet = pICMSEfet
        self.validate_TDec_0302a04Opc(self.pICMSEfet)
        self.vICMSEfet = vICMSEfet
        self.validate_TDec_1302(self.vICMSEfet)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS60Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS60Type.subclass:
            return ICMS60Type.subclass(*args_, **kwargs_)
        else:
            return ICMS60Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType19(self, value):
        # Validate type CSTType19, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['60']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType19' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.vBCSTRet is not None or
            self.pST is not None or
            self.vICMSSubstituto is not None or
            self.vICMSSTRet is not None or
            self.vBCFCPSTRet is not None or
            self.pFCPSTRet is not None or
            self.vFCPSTRet is not None or
            self.pRedBCEfet is not None or
            self.vBCEfet is not None or
            self.pICMSEfet is not None or
            self.vICMSEfet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS60Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS60Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS60Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS60Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS60Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS60Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.vBCSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCSTRet>%s</vBCSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCSTRet), input_name='vBCSTRet')), eol_))
        if self.pST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pST>%s</pST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pST), input_name='pST')), eol_))
        if self.vICMSSubstituto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSSubstituto>%s</vICMSSubstituto>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSubstituto), input_name='vICMSSubstituto')), eol_))
        if self.vICMSSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSSTRet>%s</vICMSSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSTRet), input_name='vICMSSTRet')), eol_))
        if self.vBCFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCPSTRet>%s</vBCFCPSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPSTRet), input_name='vBCFCPSTRet')), eol_))
        if self.pFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCPSTRet>%s</pFCPSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCPSTRet), input_name='pFCPSTRet')), eol_))
        if self.vFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPSTRet>%s</vFCPSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPSTRet), input_name='vFCPSTRet')), eol_))
        if self.pRedBCEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBCEfet>%s</pRedBCEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCEfet), input_name='pRedBCEfet')), eol_))
        if self.vBCEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCEfet>%s</vBCEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCEfet), input_name='vBCEfet')), eol_))
        if self.pICMSEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSEfet>%s</pICMSEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSEfet), input_name='pICMSEfet')), eol_))
        if self.vICMSEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSEfet>%s</vICMSEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSEfet), input_name='vICMSEfet')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType19
            self.validate_CSTType19(self.CST)
        elif nodeName_ == 'vBCSTRet':
            vBCSTRet_ = child_.text
            vBCSTRet_ = self.gds_validate_string(vBCSTRet_, node, 'vBCSTRet')
            self.vBCSTRet = vBCSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTRet)
        elif nodeName_ == 'pST':
            pST_ = child_.text
            pST_ = self.gds_validate_string(pST_, node, 'pST')
            self.pST = pST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pST)
        elif nodeName_ == 'vICMSSubstituto':
            vICMSSubstituto_ = child_.text
            vICMSSubstituto_ = self.gds_validate_string(vICMSSubstituto_, node, 'vICMSSubstituto')
            self.vICMSSubstituto = vICMSSubstituto_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSubstituto)
        elif nodeName_ == 'vICMSSTRet':
            vICMSSTRet_ = child_.text
            vICMSSTRet_ = self.gds_validate_string(vICMSSTRet_, node, 'vICMSSTRet')
            self.vICMSSTRet = vICMSSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTRet)
        elif nodeName_ == 'vBCFCPSTRet':
            vBCFCPSTRet_ = child_.text
            vBCFCPSTRet_ = self.gds_validate_string(vBCFCPSTRet_, node, 'vBCFCPSTRet')
            self.vBCFCPSTRet = vBCFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPSTRet)
        elif nodeName_ == 'pFCPSTRet':
            pFCPSTRet_ = child_.text
            pFCPSTRet_ = self.gds_validate_string(pFCPSTRet_, node, 'pFCPSTRet')
            self.pFCPSTRet = pFCPSTRet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        elif nodeName_ == 'vFCPSTRet':
            vFCPSTRet_ = child_.text
            vFCPSTRet_ = self.gds_validate_string(vFCPSTRet_, node, 'vFCPSTRet')
            self.vFCPSTRet = vFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPSTRet)
        elif nodeName_ == 'pRedBCEfet':
            pRedBCEfet_ = child_.text
            pRedBCEfet_ = self.gds_validate_string(pRedBCEfet_, node, 'pRedBCEfet')
            self.pRedBCEfet = pRedBCEfet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCEfet)
        elif nodeName_ == 'vBCEfet':
            vBCEfet_ = child_.text
            vBCEfet_ = self.gds_validate_string(vBCEfet_, node, 'vBCEfet')
            self.vBCEfet = vBCEfet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCEfet)
        elif nodeName_ == 'pICMSEfet':
            pICMSEfet_ = child_.text
            pICMSEfet_ = self.gds_validate_string(pICMSEfet_, node, 'pICMSEfet')
            self.pICMSEfet = pICMSEfet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pICMSEfet)
        elif nodeName_ == 'vICMSEfet':
            vICMSEfet_ = child_.text
            vICMSEfet_ = self.gds_validate_string(vICMSEfet_, node, 'vICMSEfet')
            self.vICMSEfet = vICMSEfet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSEfet)
# end class ICMS60Type


class ICMS70Type(GeneratedsSuper):
    """Tributação pelo ICMS
    70 - Com redução de base de cálculo e cobrança do ICMS por substituição
    tributária"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, pRedBC=None, vBC=None, pICMS=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, vICMSDeson=None, motDesICMS=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType20(self.CST)
        self.modBC = modBC
        self.validate_modBCType21(self.modBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04(self.pRedBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.modBCST = modBCST
        self.validate_modBCSTType22(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType23(self.motDesICMS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS70Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS70Type.subclass:
            return ICMS70Type.subclass(*args_, **kwargs_)
        else:
            return ICMS70Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType20(self, value):
        # Validate type CSTType20, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['70']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType20' % {"value" : value.encode("utf-8")} )
    def validate_modBCType21(self, value):
        # Validate type modBCType21, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType21' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_modBCSTType22(self, value):
        # Validate type modBCSTType22, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType22' % {"value" : value.encode("utf-8")} )
    def validate_motDesICMSType23(self, value):
        # Validate type motDesICMSType23, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['3', '9', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType23' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS70Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS70Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS70Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS70Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS70Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS70Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBC>%s</modBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBC>%s</pRedBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMS>%s</pICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMS>%s</vICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCP>%s</vBCFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCP), input_name='vBCFCP')), eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCP>%s</pFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCP>%s</vFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBCST>%s</modBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pMVAST>%s</pMVAST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBCST>%s</pRedBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCST>%s</vBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSST>%s</pICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSST>%s</vICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCPST>%s</vBCFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCPST>%s</pFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPST>%s</vFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSDeson>%s</vICMSDeson>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<motDesICMS>%s</motDesICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.motDesICMS), input_name='motDesICMS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType20
            self.validate_CSTType20(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType21
            self.validate_modBCType21(self.modBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pRedBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType22
            self.validate_modBCSTType22(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType23
            self.validate_motDesICMSType23(self.motDesICMS)
# end class ICMS70Type


class ICMS90Type(GeneratedsSuper):
    """Tributação pelo ICMS
    90 - Outras"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, vBC=None, pRedBC=None, pICMS=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, vICMSDeson=None, motDesICMS=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType24(self.CST)
        self.modBC = modBC
        self.validate_modBCType25(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04Opc(self.pRedBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.modBCST = modBCST
        self.validate_modBCSTType26(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType27(self.motDesICMS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS90Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS90Type.subclass:
            return ICMS90Type.subclass(*args_, **kwargs_)
        else:
            return ICMS90Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType24(self, value):
        # Validate type CSTType24, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['90']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType24' % {"value" : value.encode("utf-8")} )
    def validate_modBCType25(self, value):
        # Validate type modBCType25, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType25' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_modBCSTType26(self, value):
        # Validate type modBCSTType26, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType26' % {"value" : value.encode("utf-8")} )
    def validate_motDesICMSType27(self, value):
        # Validate type motDesICMSType27, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['3', '9', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType27' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pRedBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS90Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS90Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS90Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS90Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS90Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS90Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBC>%s</modBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBC>%s</pRedBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMS>%s</pICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMS>%s</vICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCP>%s</vBCFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCP), input_name='vBCFCP')), eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCP>%s</pFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCP>%s</vFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBCST>%s</modBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pMVAST>%s</pMVAST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBCST>%s</pRedBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCST>%s</vBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSST>%s</pICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSST>%s</vICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCPST>%s</vBCFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCPST>%s</pFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPST>%s</vFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSDeson>%s</vICMSDeson>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<motDesICMS>%s</motDesICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.motDesICMS), input_name='motDesICMS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType24
            self.validate_CSTType24(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType25
            self.validate_modBCType25(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType26
            self.validate_modBCSTType26(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType27
            self.validate_motDesICMSType27(self.motDesICMS)
# end class ICMS90Type


class ICMSPartType(GeneratedsSuper):
    """Partilha do ICMS entre a UF de origem e UF de destino ou a UF definida
    na legislação
    Operação interestadual para consumidor final com partilha do ICMS
    devido na operação entre a UF de origem e a UF do destinatário ou
    ou a UF definida na legislação. (Ex. UF da concessionária de
    entrega do  veículos)"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, vBC=None, pRedBC=None, pICMS=None, vICMS=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, pBCOp=None, UFST=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType28(self.CST)
        self.modBC = modBC
        self.validate_modBCType29(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04Opc(self.pRedBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.modBCST = modBCST
        self.validate_modBCSTType30(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.pBCOp = pBCOp
        self.validate_TDec_0302a04Opc(self.pBCOp)
        self.UFST = UFST
        self.validate_TUf(self.UFST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSPartType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSPartType.subclass:
            return ICMSPartType.subclass(*args_, **kwargs_)
        else:
            return ICMSPartType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType28(self, value):
        # Validate type CSTType28, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['10', '90']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType28' % {"value" : value.encode("utf-8")} )
    def validate_modBCType29(self, value):
        # Validate type modBCType29, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType29' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_modBCSTType30(self, value):
        # Validate type modBCSTType30, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType30' % {"value" : value.encode("utf-8")} )
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pRedBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.pBCOp is not None or
            self.UFST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSPartType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSPartType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSPartType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSPartType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSPartType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSPartType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBC>%s</modBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBC>%s</pRedBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMS>%s</pICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMS>%s</vICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBCST>%s</modBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pMVAST>%s</pMVAST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBCST>%s</pRedBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCST>%s</vBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSST>%s</pICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSST>%s</vICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), eol_))
        if self.pBCOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pBCOp>%s</pBCOp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pBCOp), input_name='pBCOp')), eol_))
        if self.UFST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UFST>%s</UFST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UFST), input_name='UFST')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType28
            self.validate_CSTType28(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType29
            self.validate_modBCType29(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType30
            self.validate_modBCSTType30(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'pBCOp':
            pBCOp_ = child_.text
            pBCOp_ = self.gds_validate_string(pBCOp_, node, 'pBCOp')
            self.pBCOp = pBCOp_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pBCOp)
        elif nodeName_ == 'UFST':
            UFST_ = child_.text
            UFST_ = self.gds_validate_string(UFST_, node, 'UFST')
            self.UFST = UFST_
            # validate type TUf
            self.validate_TUf(self.UFST)
# end class ICMSPartType


class ICMSSTType(GeneratedsSuper):
    """Grupo de informação do ICMSST devido para a UF de destino, nas
    operações interestaduais de produtos que tiveram retenção
    antecipada de ICMS por ST na UF do remetente. Repasse via
    Substituto Tributário."""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, vBCSTRet=None, pST=None, vICMSSubstituto=None, vICMSSTRet=None, vBCFCPSTRet=None, pFCPSTRet=None, vFCPSTRet=None, vBCSTDest=None, vICMSSTDest=None, pRedBCEfet=None, vBCEfet=None, pICMSEfet=None, vICMSEfet=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType31(self.CST)
        self.vBCSTRet = vBCSTRet
        self.validate_TDec_1302(self.vBCSTRet)
        self.pST = pST
        self.validate_TDec_0302a04Opc(self.pST)
        self.vICMSSubstituto = vICMSSubstituto
        self.validate_TDec_1302(self.vICMSSubstituto)
        self.vICMSSTRet = vICMSSTRet
        self.validate_TDec_1302(self.vICMSSTRet)
        self.vBCFCPSTRet = vBCFCPSTRet
        self.validate_TDec_1302(self.vBCFCPSTRet)
        self.pFCPSTRet = pFCPSTRet
        self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        self.vFCPSTRet = vFCPSTRet
        self.validate_TDec_1302(self.vFCPSTRet)
        self.vBCSTDest = vBCSTDest
        self.validate_TDec_1302(self.vBCSTDest)
        self.vICMSSTDest = vICMSSTDest
        self.validate_TDec_1302(self.vICMSSTDest)
        self.pRedBCEfet = pRedBCEfet
        self.validate_TDec_0302a04Opc(self.pRedBCEfet)
        self.vBCEfet = vBCEfet
        self.validate_TDec_1302(self.vBCEfet)
        self.pICMSEfet = pICMSEfet
        self.validate_TDec_0302a04Opc(self.pICMSEfet)
        self.vICMSEfet = vICMSEfet
        self.validate_TDec_1302(self.vICMSEfet)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSTType.subclass:
            return ICMSSTType.subclass(*args_, **kwargs_)
        else:
            return ICMSSTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType31(self, value):
        # Validate type CSTType31, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['41', '60']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType31' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.vBCSTRet is not None or
            self.pST is not None or
            self.vICMSSubstituto is not None or
            self.vICMSSTRet is not None or
            self.vBCFCPSTRet is not None or
            self.pFCPSTRet is not None or
            self.vFCPSTRet is not None or
            self.vBCSTDest is not None or
            self.vICMSSTDest is not None or
            self.pRedBCEfet is not None or
            self.vBCEfet is not None or
            self.pICMSEfet is not None or
            self.vICMSEfet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSSTType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSSTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSSTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSSTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.vBCSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCSTRet>%s</vBCSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCSTRet), input_name='vBCSTRet')), eol_))
        if self.pST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pST>%s</pST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pST), input_name='pST')), eol_))
        if self.vICMSSubstituto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSSubstituto>%s</vICMSSubstituto>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSubstituto), input_name='vICMSSubstituto')), eol_))
        if self.vICMSSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSSTRet>%s</vICMSSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSTRet), input_name='vICMSSTRet')), eol_))
        if self.vBCFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCPSTRet>%s</vBCFCPSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPSTRet), input_name='vBCFCPSTRet')), eol_))
        if self.pFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCPSTRet>%s</pFCPSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCPSTRet), input_name='pFCPSTRet')), eol_))
        if self.vFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPSTRet>%s</vFCPSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPSTRet), input_name='vFCPSTRet')), eol_))
        if self.vBCSTDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCSTDest>%s</vBCSTDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCSTDest), input_name='vBCSTDest')), eol_))
        if self.vICMSSTDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSSTDest>%s</vICMSSTDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSTDest), input_name='vICMSSTDest')), eol_))
        if self.pRedBCEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBCEfet>%s</pRedBCEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCEfet), input_name='pRedBCEfet')), eol_))
        if self.vBCEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCEfet>%s</vBCEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCEfet), input_name='vBCEfet')), eol_))
        if self.pICMSEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSEfet>%s</pICMSEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSEfet), input_name='pICMSEfet')), eol_))
        if self.vICMSEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSEfet>%s</vICMSEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSEfet), input_name='vICMSEfet')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType31
            self.validate_CSTType31(self.CST)
        elif nodeName_ == 'vBCSTRet':
            vBCSTRet_ = child_.text
            vBCSTRet_ = self.gds_validate_string(vBCSTRet_, node, 'vBCSTRet')
            self.vBCSTRet = vBCSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTRet)
        elif nodeName_ == 'pST':
            pST_ = child_.text
            pST_ = self.gds_validate_string(pST_, node, 'pST')
            self.pST = pST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pST)
        elif nodeName_ == 'vICMSSubstituto':
            vICMSSubstituto_ = child_.text
            vICMSSubstituto_ = self.gds_validate_string(vICMSSubstituto_, node, 'vICMSSubstituto')
            self.vICMSSubstituto = vICMSSubstituto_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSubstituto)
        elif nodeName_ == 'vICMSSTRet':
            vICMSSTRet_ = child_.text
            vICMSSTRet_ = self.gds_validate_string(vICMSSTRet_, node, 'vICMSSTRet')
            self.vICMSSTRet = vICMSSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTRet)
        elif nodeName_ == 'vBCFCPSTRet':
            vBCFCPSTRet_ = child_.text
            vBCFCPSTRet_ = self.gds_validate_string(vBCFCPSTRet_, node, 'vBCFCPSTRet')
            self.vBCFCPSTRet = vBCFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPSTRet)
        elif nodeName_ == 'pFCPSTRet':
            pFCPSTRet_ = child_.text
            pFCPSTRet_ = self.gds_validate_string(pFCPSTRet_, node, 'pFCPSTRet')
            self.pFCPSTRet = pFCPSTRet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        elif nodeName_ == 'vFCPSTRet':
            vFCPSTRet_ = child_.text
            vFCPSTRet_ = self.gds_validate_string(vFCPSTRet_, node, 'vFCPSTRet')
            self.vFCPSTRet = vFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPSTRet)
        elif nodeName_ == 'vBCSTDest':
            vBCSTDest_ = child_.text
            vBCSTDest_ = self.gds_validate_string(vBCSTDest_, node, 'vBCSTDest')
            self.vBCSTDest = vBCSTDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTDest)
        elif nodeName_ == 'vICMSSTDest':
            vICMSSTDest_ = child_.text
            vICMSSTDest_ = self.gds_validate_string(vICMSSTDest_, node, 'vICMSSTDest')
            self.vICMSSTDest = vICMSSTDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTDest)
        elif nodeName_ == 'pRedBCEfet':
            pRedBCEfet_ = child_.text
            pRedBCEfet_ = self.gds_validate_string(pRedBCEfet_, node, 'pRedBCEfet')
            self.pRedBCEfet = pRedBCEfet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCEfet)
        elif nodeName_ == 'vBCEfet':
            vBCEfet_ = child_.text
            vBCEfet_ = self.gds_validate_string(vBCEfet_, node, 'vBCEfet')
            self.vBCEfet = vBCEfet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCEfet)
        elif nodeName_ == 'pICMSEfet':
            pICMSEfet_ = child_.text
            pICMSEfet_ = self.gds_validate_string(pICMSEfet_, node, 'pICMSEfet')
            self.pICMSEfet = pICMSEfet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pICMSEfet)
        elif nodeName_ == 'vICMSEfet':
            vICMSEfet_ = child_.text
            vICMSEfet_ = self.gds_validate_string(vICMSEfet_, node, 'vICMSEfet')
            self.vICMSEfet = vICMSEfet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSEfet)
# end class ICMSSTType


class ICMSSN101Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL e CSOSN=101 (v.2.0)"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None, pCredSN=None, vCredICMSSN=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType(self.CSOSN)
        self.pCredSN = pCredSN
        self.validate_TDec_0302a04(self.pCredSN)
        self.vCredICMSSN = vCredICMSSN
        self.validate_TDec_1302(self.vCredICMSSN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN101Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN101Type.subclass:
            return ICMSSN101Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN101Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType(self, value):
        # Validate type CSOSNType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['101']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.pCredSN is not None or
            self.vCredICMSSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSSN101Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN101Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSSN101Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSSN101Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSSN101Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSSN101Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CSOSN>%s</CSOSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), eol_))
        if self.pCredSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pCredSN>%s</pCredSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pCredSN), input_name='pCredSN')), eol_))
        if self.vCredICMSSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vCredICMSSN>%s</vCredICMSSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vCredICMSSN), input_name='vCredICMSSN')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType
            self.validate_CSOSNType(self.CSOSN)
        elif nodeName_ == 'pCredSN':
            pCredSN_ = child_.text
            pCredSN_ = self.gds_validate_string(pCredSN_, node, 'pCredSN')
            self.pCredSN = pCredSN_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCredSN)
        elif nodeName_ == 'vCredICMSSN':
            vCredICMSSN_ = child_.text
            vCredICMSSN_ = self.gds_validate_string(vCredICMSSN_, node, 'vCredICMSSN')
            self.vCredICMSSN = vCredICMSSN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCredICMSSN)
# end class ICMSSN101Type


class ICMSSN102Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL e CSOSN=102, 103, 300 ou 400
    (v.2.0))"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType32(self.CSOSN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN102Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN102Type.subclass:
            return ICMSSN102Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN102Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType32(self, value):
        # Validate type CSOSNType32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['102', '103', '300', '400']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType32' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSSN102Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN102Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSSN102Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSSN102Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSSN102Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSSN102Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CSOSN>%s</CSOSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType32
            self.validate_CSOSNType32(self.CSOSN)
# end class ICMSSN102Type


class ICMSSN201Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL e CSOSN=201 (v.2.0)"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, pCredSN=None, vCredICMSSN=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType33(self.CSOSN)
        self.modBCST = modBCST
        self.validate_modBCSTType34(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.pCredSN = pCredSN
        self.validate_TDec_0302a04(self.pCredSN)
        self.vCredICMSSN = vCredICMSSN
        self.validate_TDec_1302(self.vCredICMSSN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN201Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN201Type.subclass:
            return ICMSSN201Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN201Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType33(self, value):
        # Validate type CSOSNType33, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['201']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType33' % {"value" : value.encode("utf-8")} )
    def validate_modBCSTType34(self, value):
        # Validate type modBCSTType34, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType34' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.pCredSN is not None or
            self.vCredICMSSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSSN201Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN201Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSSN201Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSSN201Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSSN201Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSSN201Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CSOSN>%s</CSOSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBCST>%s</modBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pMVAST>%s</pMVAST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBCST>%s</pRedBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCST>%s</vBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSST>%s</pICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSST>%s</vICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCPST>%s</vBCFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCPST>%s</pFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPST>%s</vFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), eol_))
        if self.pCredSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pCredSN>%s</pCredSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pCredSN), input_name='pCredSN')), eol_))
        if self.vCredICMSSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vCredICMSSN>%s</vCredICMSSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vCredICMSSN), input_name='vCredICMSSN')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType33
            self.validate_CSOSNType33(self.CSOSN)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType34
            self.validate_modBCSTType34(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'pCredSN':
            pCredSN_ = child_.text
            pCredSN_ = self.gds_validate_string(pCredSN_, node, 'pCredSN')
            self.pCredSN = pCredSN_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCredSN)
        elif nodeName_ == 'vCredICMSSN':
            vCredICMSSN_ = child_.text
            vCredICMSSN_ = self.gds_validate_string(vCredICMSSN_, node, 'vCredICMSSN')
            self.vCredICMSSN = vCredICMSSN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCredICMSSN)
# end class ICMSSN201Type


class ICMSSN202Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL e CSOSN=202 ou 203 (v.2.0)"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType35(self.CSOSN)
        self.modBCST = modBCST
        self.validate_modBCSTType36(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN202Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN202Type.subclass:
            return ICMSSN202Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN202Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType35(self, value):
        # Validate type CSOSNType35, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['202', '203']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType35' % {"value" : value.encode("utf-8")} )
    def validate_modBCSTType36(self, value):
        # Validate type modBCSTType36, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType36' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSSN202Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN202Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSSN202Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSSN202Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSSN202Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSSN202Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CSOSN>%s</CSOSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBCST>%s</modBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pMVAST>%s</pMVAST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBCST>%s</pRedBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCST>%s</vBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSST>%s</pICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSST>%s</vICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCPST>%s</vBCFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCPST>%s</pFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPST>%s</vFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType35
            self.validate_CSOSNType35(self.CSOSN)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType36
            self.validate_modBCSTType36(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
# end class ICMSSN202Type


class ICMSSN500Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL,CRT=1 – Simples Nacional e
    CSOSN=500 (v.2.0)"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None, vBCSTRet=None, pST=None, vICMSSubstituto=None, vICMSSTRet=None, vBCFCPSTRet=None, pFCPSTRet=None, vFCPSTRet=None, pRedBCEfet=None, vBCEfet=None, pICMSEfet=None, vICMSEfet=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType37(self.CSOSN)
        self.vBCSTRet = vBCSTRet
        self.validate_TDec_1302(self.vBCSTRet)
        self.pST = pST
        self.validate_TDec_0302a04Opc(self.pST)
        self.vICMSSubstituto = vICMSSubstituto
        self.validate_TDec_1302(self.vICMSSubstituto)
        self.vICMSSTRet = vICMSSTRet
        self.validate_TDec_1302(self.vICMSSTRet)
        self.vBCFCPSTRet = vBCFCPSTRet
        self.validate_TDec_1302(self.vBCFCPSTRet)
        self.pFCPSTRet = pFCPSTRet
        self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        self.vFCPSTRet = vFCPSTRet
        self.validate_TDec_1302(self.vFCPSTRet)
        self.pRedBCEfet = pRedBCEfet
        self.validate_TDec_0302a04Opc(self.pRedBCEfet)
        self.vBCEfet = vBCEfet
        self.validate_TDec_1302(self.vBCEfet)
        self.pICMSEfet = pICMSEfet
        self.validate_TDec_0302a04Opc(self.pICMSEfet)
        self.vICMSEfet = vICMSEfet
        self.validate_TDec_1302(self.vICMSEfet)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN500Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN500Type.subclass:
            return ICMSSN500Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN500Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType37(self, value):
        # Validate type CSOSNType37, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['500']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType37' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.vBCSTRet is not None or
            self.pST is not None or
            self.vICMSSubstituto is not None or
            self.vICMSSTRet is not None or
            self.vBCFCPSTRet is not None or
            self.pFCPSTRet is not None or
            self.vFCPSTRet is not None or
            self.pRedBCEfet is not None or
            self.vBCEfet is not None or
            self.pICMSEfet is not None or
            self.vICMSEfet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSSN500Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN500Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSSN500Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSSN500Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSSN500Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSSN500Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CSOSN>%s</CSOSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), eol_))
        if self.vBCSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCSTRet>%s</vBCSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCSTRet), input_name='vBCSTRet')), eol_))
        if self.pST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pST>%s</pST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pST), input_name='pST')), eol_))
        if self.vICMSSubstituto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSSubstituto>%s</vICMSSubstituto>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSubstituto), input_name='vICMSSubstituto')), eol_))
        if self.vICMSSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSSTRet>%s</vICMSSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSTRet), input_name='vICMSSTRet')), eol_))
        if self.vBCFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCPSTRet>%s</vBCFCPSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPSTRet), input_name='vBCFCPSTRet')), eol_))
        if self.pFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCPSTRet>%s</pFCPSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCPSTRet), input_name='pFCPSTRet')), eol_))
        if self.vFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPSTRet>%s</vFCPSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPSTRet), input_name='vFCPSTRet')), eol_))
        if self.pRedBCEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBCEfet>%s</pRedBCEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCEfet), input_name='pRedBCEfet')), eol_))
        if self.vBCEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCEfet>%s</vBCEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCEfet), input_name='vBCEfet')), eol_))
        if self.pICMSEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSEfet>%s</pICMSEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSEfet), input_name='pICMSEfet')), eol_))
        if self.vICMSEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSEfet>%s</vICMSEfet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSEfet), input_name='vICMSEfet')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType37
            self.validate_CSOSNType37(self.CSOSN)
        elif nodeName_ == 'vBCSTRet':
            vBCSTRet_ = child_.text
            vBCSTRet_ = self.gds_validate_string(vBCSTRet_, node, 'vBCSTRet')
            self.vBCSTRet = vBCSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTRet)
        elif nodeName_ == 'pST':
            pST_ = child_.text
            pST_ = self.gds_validate_string(pST_, node, 'pST')
            self.pST = pST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pST)
        elif nodeName_ == 'vICMSSubstituto':
            vICMSSubstituto_ = child_.text
            vICMSSubstituto_ = self.gds_validate_string(vICMSSubstituto_, node, 'vICMSSubstituto')
            self.vICMSSubstituto = vICMSSubstituto_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSubstituto)
        elif nodeName_ == 'vICMSSTRet':
            vICMSSTRet_ = child_.text
            vICMSSTRet_ = self.gds_validate_string(vICMSSTRet_, node, 'vICMSSTRet')
            self.vICMSSTRet = vICMSSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTRet)
        elif nodeName_ == 'vBCFCPSTRet':
            vBCFCPSTRet_ = child_.text
            vBCFCPSTRet_ = self.gds_validate_string(vBCFCPSTRet_, node, 'vBCFCPSTRet')
            self.vBCFCPSTRet = vBCFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPSTRet)
        elif nodeName_ == 'pFCPSTRet':
            pFCPSTRet_ = child_.text
            pFCPSTRet_ = self.gds_validate_string(pFCPSTRet_, node, 'pFCPSTRet')
            self.pFCPSTRet = pFCPSTRet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        elif nodeName_ == 'vFCPSTRet':
            vFCPSTRet_ = child_.text
            vFCPSTRet_ = self.gds_validate_string(vFCPSTRet_, node, 'vFCPSTRet')
            self.vFCPSTRet = vFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPSTRet)
        elif nodeName_ == 'pRedBCEfet':
            pRedBCEfet_ = child_.text
            pRedBCEfet_ = self.gds_validate_string(pRedBCEfet_, node, 'pRedBCEfet')
            self.pRedBCEfet = pRedBCEfet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCEfet)
        elif nodeName_ == 'vBCEfet':
            vBCEfet_ = child_.text
            vBCEfet_ = self.gds_validate_string(vBCEfet_, node, 'vBCEfet')
            self.vBCEfet = vBCEfet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCEfet)
        elif nodeName_ == 'pICMSEfet':
            pICMSEfet_ = child_.text
            pICMSEfet_ = self.gds_validate_string(pICMSEfet_, node, 'pICMSEfet')
            self.pICMSEfet = pICMSEfet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pICMSEfet)
        elif nodeName_ == 'vICMSEfet':
            vICMSEfet_ = child_.text
            vICMSEfet_ = self.gds_validate_string(vICMSEfet_, node, 'vICMSEfet')
            self.vICMSEfet = vICMSEfet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSEfet)
# end class ICMSSN500Type


class ICMSSN900Type(GeneratedsSuper):
    """Tributação do ICMS pelo SIMPLES NACIONAL, CRT=1 – Simples Nacional e
    CSOSN=900 (v2.0)"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None, modBC=None, vBC=None, pRedBC=None, pICMS=None, vICMS=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, pCredSN=None, vCredICMSSN=None):
        self.original_tagname_ = None
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType38(self.CSOSN)
        self.modBC = modBC
        self.validate_modBCType39(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04Opc(self.pRedBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.modBCST = modBCST
        self.validate_modBCSTType40(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.pCredSN = pCredSN
        self.validate_TDec_0302a04(self.pCredSN)
        self.vCredICMSSN = vCredICMSSN
        self.validate_TDec_1302(self.vCredICMSSN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN900Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN900Type.subclass:
            return ICMSSN900Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN900Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType38(self, value):
        # Validate type CSOSNType38, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['900']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType38' % {"value" : value.encode("utf-8")} )
    def validate_modBCType39(self, value):
        # Validate type modBCType39, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType39' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [['^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_modBCSTType40(self, value):
        # Validate type modBCSTType40, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType40' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pRedBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.pCredSN is not None or
            self.vCredICMSSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSSN900Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN900Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSSN900Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSSN900Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSSN900Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSSN900Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<orig>%s</orig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CSOSN>%s</CSOSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBC>%s</modBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBC>%s</pRedBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMS>%s</pICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMS>%s</vICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modBCST>%s</modBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pMVAST>%s</pMVAST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pRedBCST>%s</pRedBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCST>%s</vBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSST>%s</pICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSST>%s</vICMSST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCPST>%s</vBCFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCPST>%s</pFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPST>%s</vFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), eol_))
        if self.pCredSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pCredSN>%s</pCredSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pCredSN), input_name='pCredSN')), eol_))
        if self.vCredICMSSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vCredICMSSN>%s</vCredICMSSN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vCredICMSSN), input_name='vCredICMSSN')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType38
            self.validate_CSOSNType38(self.CSOSN)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType39
            self.validate_modBCType39(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType40
            self.validate_modBCSTType40(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'pCredSN':
            pCredSN_ = child_.text
            pCredSN_ = self.gds_validate_string(pCredSN_, node, 'pCredSN')
            self.pCredSN = pCredSN_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCredSN)
        elif nodeName_ == 'vCredICMSSN':
            vCredICMSSN_ = child_.text
            vCredICMSSN_ = self.gds_validate_string(vCredICMSSN_, node, 'vCredICMSSN')
            self.vCredICMSSN = vCredICMSSN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCredICMSSN)
# end class ICMSSN900Type


class IIType(GeneratedsSuper):
    """Dados do Imposto de Importação"""
    subclass = None
    superclass = None
    def __init__(self, vBC=None, vDespAdu=None, vII=None, vIOF=None):
        self.original_tagname_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vDespAdu = vDespAdu
        self.validate_TDec_1302(self.vDespAdu)
        self.vII = vII
        self.validate_TDec_1302(self.vII)
        self.vIOF = vIOF
        self.validate_TDec_1302(self.vIOF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IIType.subclass:
            return IIType.subclass(*args_, **kwargs_)
        else:
            return IIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vBC is not None or
            self.vDespAdu is not None or
            self.vII is not None or
            self.vIOF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IIType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IIType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.vDespAdu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDespAdu>%s</vDespAdu>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDespAdu), input_name='vDespAdu')), eol_))
        if self.vII is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vII>%s</vII>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vII), input_name='vII')), eol_))
        if self.vIOF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vIOF>%s</vIOF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vIOF), input_name='vIOF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'vDespAdu':
            vDespAdu_ = child_.text
            vDespAdu_ = self.gds_validate_string(vDespAdu_, node, 'vDespAdu')
            self.vDespAdu = vDespAdu_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDespAdu)
        elif nodeName_ == 'vII':
            vII_ = child_.text
            vII_ = self.gds_validate_string(vII_, node, 'vII')
            self.vII = vII_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vII)
        elif nodeName_ == 'vIOF':
            vIOF_ = child_.text
            vIOF_ = self.gds_validate_string(vIOF_, node, 'vIOF')
            self.vIOF = vIOF_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIOF)
# end class IIType


class ISSQNType(GeneratedsSuper):
    """ISSQN"""
    subclass = None
    superclass = None
    def __init__(self, vBC=None, vAliq=None, vISSQN=None, cMunFG=None, cListServ=None, vDeducao=None, vOutro=None, vDescIncond=None, vDescCond=None, vISSRet=None, indISS=None, cServico=None, cMun=None, cPais=None, nProcesso=None, indIncentivo=None):
        self.original_tagname_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vAliq = vAliq
        self.validate_TDec_0302a04(self.vAliq)
        self.vISSQN = vISSQN
        self.validate_TDec_1302(self.vISSQN)
        self.cMunFG = cMunFG
        self.validate_TCodMunIBGE(self.cMunFG)
        self.cListServ = cListServ
        self.validate_TCListServ(self.cListServ)
        self.vDeducao = vDeducao
        self.validate_TDec_1302Opc(self.vDeducao)
        self.vOutro = vOutro
        self.validate_TDec_1302Opc(self.vOutro)
        self.vDescIncond = vDescIncond
        self.validate_TDec_1302Opc(self.vDescIncond)
        self.vDescCond = vDescCond
        self.validate_TDec_1302Opc(self.vDescCond)
        self.vISSRet = vISSRet
        self.validate_TDec_1302Opc(self.vISSRet)
        self.indISS = indISS
        self.validate_indISSType(self.indISS)
        self.cServico = cServico
        self.validate_cServicoType(self.cServico)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.cPais = cPais
        self.validate_cPaisType(self.cPais)
        self.nProcesso = nProcesso
        self.validate_nProcessoType(self.nProcesso)
        self.indIncentivo = indIncentivo
        self.validate_indIncentivoType(self.indIncentivo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISSQNType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISSQNType.subclass:
            return ISSQNType.subclass(*args_, **kwargs_)
        else:
            return ISSQNType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_TCListServ(self, value):
        # Validate type TCListServ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01.01', '01.02', '01.03', '01.04', '01.05', '01.06', '01.07', '01.08', '01.09', '02.01', '03.02', '03.03', '03.04', '03.05', '04.01', '04.02', '04.03', '04.04', '04.05', '04.06', '04.07', '04.08', '04.09', '04.10', '04.11', '04.12', '04.13', '04.14', '04.15', '04.16', '04.17', '04.18', '04.19', '04.20', '04.21', '04.22', '04.23', '05.01', '05.02', '05.03', '05.04', '05.05', '05.06', '05.07', '05.08', '05.09', '06.01', '06.02', '06.03', '06.04', '06.05', '06.06', '07.01', '07.02', '07.03', '07.04', '07.05', '07.06', '07.07', '07.08', '07.09', '07.10', '07.11', '07.12', '07.13', '07.16', '07.17', '07.18', '07.19', '07.20', '07.21', '07.22', '08.01', '08.02', '09.01', '09.02', '09.03', '10.01', '10.02', '10.03', '10.04', '10.05', '10.06', '10.07', '10.08', '10.09', '10.10', '11.01', '11.02', '11.03', '11.04', '12.01', '12.02', '12.03', '12.04', '12.05', '12.06', '12.07', '12.08', '12.09', '12.10', '12.11', '12.12', '12.13', '12.14', '12.15', '12.16', '12.17', '13.02', '13.03', '13.04', '13.05', '14.01', '14.02', '14.03', '14.04', '14.05', '14.06', '14.07', '14.08', '14.09', '14.10', '14.11', '14.12', '14.13', '14.14', '15.01', '15.02', '15.03', '15.04', '15.05', '15.06', '15.07', '15.08', '15.09', '15.10', '15.11', '15.12', '15.13', '15.14', '15.15', '15.16', '15.17', '15.18', '16.01', '16.02', '17.01', '17.02', '17.03', '17.04', '17.05', '17.06', '17.08', '17.09', '17.10', '17.11', '17.12', '17.13', '17.14', '17.15', '17.16', '17.17', '17.18', '17.19', '17.20', '17.21', '17.22', '17.23', '17.24', '17.25', '18.01', '19.01', '20.01', '20.02', '20.03', '21.01', '22.01', '23.01', '24.01', '25.01', '25.02', '25.03', '25.04', '25.05', '26.01', '27.01', '28.01', '29.01', '30.01', '31.01', '32.01', '33.01', '34.01', '35.01', '36.01', '37.01', '38.01', '39.01', '40.01']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCListServ' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_indISSType(self, value):
        # Validate type indISSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indISSType' % {"value" : value.encode("utf-8")} )
    def validate_cServicoType(self, value):
        # Validate type cServicoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cServicoType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cServicoType' % {"value" : value.encode("utf-8")} )
    def validate_cPaisType(self, value):
        # Validate type cPaisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cPaisType_patterns_, ))
    validate_cPaisType_patterns_ = [['^[0-9]{1,4}$']]
    def validate_nProcessoType(self, value):
        # Validate type nProcessoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nProcessoType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nProcessoType' % {"value" : value.encode("utf-8")} )
    def validate_indIncentivoType(self, value):
        # Validate type indIncentivoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indIncentivoType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.vBC is not None or
            self.vAliq is not None or
            self.vISSQN is not None or
            self.cMunFG is not None or
            self.cListServ is not None or
            self.vDeducao is not None or
            self.vOutro is not None or
            self.vDescIncond is not None or
            self.vDescCond is not None or
            self.vISSRet is not None or
            self.indISS is not None or
            self.cServico is not None or
            self.cMun is not None or
            self.cPais is not None or
            self.nProcesso is not None or
            self.indIncentivo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ISSQNType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISSQNType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISSQNType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ISSQNType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ISSQNType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ISSQNType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.vAliq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vAliq>%s</vAliq>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vAliq), input_name='vAliq')), eol_))
        if self.vISSQN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vISSQN>%s</vISSQN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vISSQN), input_name='vISSQN')), eol_))
        if self.cMunFG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMunFG>%s</cMunFG>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMunFG), input_name='cMunFG')), eol_))
        if self.cListServ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cListServ>%s</cListServ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cListServ), input_name='cListServ')), eol_))
        if self.vDeducao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDeducao>%s</vDeducao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDeducao), input_name='vDeducao')), eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vOutro>%s</vOutro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vOutro), input_name='vOutro')), eol_))
        if self.vDescIncond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDescIncond>%s</vDescIncond>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDescIncond), input_name='vDescIncond')), eol_))
        if self.vDescCond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDescCond>%s</vDescCond>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDescCond), input_name='vDescCond')), eol_))
        if self.vISSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vISSRet>%s</vISSRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vISSRet), input_name='vISSRet')), eol_))
        if self.indISS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indISS>%s</indISS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indISS), input_name='indISS')), eol_))
        if self.cServico is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cServico>%s</cServico>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cServico), input_name='cServico')), eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMun>%s</cMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cPais>%s</cPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), eol_))
        if self.nProcesso is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nProcesso>%s</nProcesso>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nProcesso), input_name='nProcesso')), eol_))
        if self.indIncentivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indIncentivo>%s</indIncentivo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indIncentivo), input_name='indIncentivo')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'vAliq':
            vAliq_ = child_.text
            vAliq_ = self.gds_validate_string(vAliq_, node, 'vAliq')
            self.vAliq = vAliq_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.vAliq)
        elif nodeName_ == 'vISSQN':
            vISSQN_ = child_.text
            vISSQN_ = self.gds_validate_string(vISSQN_, node, 'vISSQN')
            self.vISSQN = vISSQN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vISSQN)
        elif nodeName_ == 'cMunFG':
            cMunFG_ = child_.text
            cMunFG_ = self.gds_validate_string(cMunFG_, node, 'cMunFG')
            self.cMunFG = cMunFG_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunFG)
        elif nodeName_ == 'cListServ':
            cListServ_ = child_.text
            cListServ_ = self.gds_validate_string(cListServ_, node, 'cListServ')
            self.cListServ = cListServ_
            # validate type TCListServ
            self.validate_TCListServ(self.cListServ)
        elif nodeName_ == 'vDeducao':
            vDeducao_ = child_.text
            vDeducao_ = self.gds_validate_string(vDeducao_, node, 'vDeducao')
            self.vDeducao = vDeducao_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDeducao)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOutro)
        elif nodeName_ == 'vDescIncond':
            vDescIncond_ = child_.text
            vDescIncond_ = self.gds_validate_string(vDescIncond_, node, 'vDescIncond')
            self.vDescIncond = vDescIncond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescIncond)
        elif nodeName_ == 'vDescCond':
            vDescCond_ = child_.text
            vDescCond_ = self.gds_validate_string(vDescCond_, node, 'vDescCond')
            self.vDescCond = vDescCond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescCond)
        elif nodeName_ == 'vISSRet':
            vISSRet_ = child_.text
            vISSRet_ = self.gds_validate_string(vISSRet_, node, 'vISSRet')
            self.vISSRet = vISSRet_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vISSRet)
        elif nodeName_ == 'indISS':
            indISS_ = child_.text
            indISS_ = self.gds_validate_string(indISS_, node, 'indISS')
            self.indISS = indISS_
            # validate type indISSType
            self.validate_indISSType(self.indISS)
        elif nodeName_ == 'cServico':
            cServico_ = child_.text
            cServico_ = self.gds_validate_string(cServico_, node, 'cServico')
            self.cServico = cServico_
            # validate type cServicoType
            self.validate_cServicoType(self.cServico)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType
            self.validate_cPaisType(self.cPais)
        elif nodeName_ == 'nProcesso':
            nProcesso_ = child_.text
            nProcesso_ = self.gds_validate_string(nProcesso_, node, 'nProcesso')
            self.nProcesso = nProcesso_
            # validate type nProcessoType
            self.validate_nProcessoType(self.nProcesso)
        elif nodeName_ == 'indIncentivo':
            indIncentivo_ = child_.text
            indIncentivo_ = self.gds_validate_string(indIncentivo_, node, 'indIncentivo')
            self.indIncentivo = indIncentivo_
            # validate type indIncentivoType
            self.validate_indIncentivoType(self.indIncentivo)
# end class ISSQNType


class PISType(GeneratedsSuper):
    """Dados do PIS"""
    subclass = None
    superclass = None
    def __init__(self, PISAliq=None, PISQtde=None, PISNT=None, PISOutr=None):
        self.original_tagname_ = None
        self.PISAliq = PISAliq
        self.PISQtde = PISQtde
        self.PISNT = PISNT
        self.PISOutr = PISOutr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISType.subclass:
            return PISType.subclass(*args_, **kwargs_)
        else:
            return PISType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.PISAliq is not None or
            self.PISQtde is not None or
            self.PISNT is not None or
            self.PISOutr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PISType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PISType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PISType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PISType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PISType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PISAliq is not None:
            self.PISAliq.export(outfile, level, namespace_, name_='PISAliq', pretty_print=pretty_print)
        if self.PISQtde is not None:
            self.PISQtde.export(outfile, level, namespace_, name_='PISQtde', pretty_print=pretty_print)
        if self.PISNT is not None:
            self.PISNT.export(outfile, level, namespace_, name_='PISNT', pretty_print=pretty_print)
        if self.PISOutr is not None:
            self.PISOutr.export(outfile, level, namespace_, name_='PISOutr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PISAliq':
            obj_ = PISAliqType.factory()
            obj_.build(child_)
            self.PISAliq = obj_
            obj_.original_tagname_ = 'PISAliq'
        elif nodeName_ == 'PISQtde':
            obj_ = PISQtdeType.factory()
            obj_.build(child_)
            self.PISQtde = obj_
            obj_.original_tagname_ = 'PISQtde'
        elif nodeName_ == 'PISNT':
            obj_ = PISNTType.factory()
            obj_.build(child_)
            self.PISNT = obj_
            obj_.original_tagname_ = 'PISNT'
        elif nodeName_ == 'PISOutr':
            obj_ = PISOutrType.factory()
            obj_.build(child_)
            self.PISOutr = obj_
            obj_.original_tagname_ = 'PISOutr'
# end class PISType


class PISAliqType(GeneratedsSuper):
    """Código de Situação Tributária do PIS.
     01 – Operação Tributável - Base de Cálculo = Valor da Operação
    Alíquota Normal (Cumulativo/Não Cumulativo);
    02 - Operação Tributável - Base de Calculo = Valor da Operação
    (Alíquota Diferenciada);"""
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pPIS=None, vPIS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType41(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pPIS = pPIS
        self.validate_TDec_0302a04(self.pPIS)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISAliqType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISAliqType.subclass:
            return PISAliqType.subclass(*args_, **kwargs_)
        else:
            return PISAliqType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CSTType41(self, value):
        # Validate type CSTType41, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType41' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pPIS is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PISAliqType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISAliqType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PISAliqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PISAliqType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PISAliqType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PISAliqType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pPIS>%s</pPIS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pPIS), input_name='pPIS')), eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vPIS>%s</vPIS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType41
            self.validate_CSTType41(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pPIS':
            pPIS_ = child_.text
            pPIS_ = self.gds_validate_string(pPIS_, node, 'pPIS')
            self.pPIS = pPIS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pPIS)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISAliqType


class PISQtdeType(GeneratedsSuper):
    """Código de Situação Tributária do PIS.
    03 - Operação Tributável - Base de Calculo = Quantidade Vendida x
    Alíquota por Unidade de Produto;"""
    subclass = None
    superclass = None
    def __init__(self, CST=None, qBCProd=None, vAliqProd=None, vPIS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType42(self.CST)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISQtdeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISQtdeType.subclass:
            return PISQtdeType.subclass(*args_, **kwargs_)
        else:
            return PISQtdeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CSTType42(self, value):
        # Validate type CSTType42, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['03']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType42' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PISQtdeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISQtdeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PISQtdeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PISQtdeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PISQtdeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PISQtdeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qBCProd>%s</qBCProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vAliqProd>%s</vAliqProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vPIS>%s</vPIS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType42
            self.validate_CSTType42(self.CST)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISQtdeType


class PISNTType(GeneratedsSuper):
    """Código de Situação Tributária do PIS.
    04 - Operação Tributável - Tributação Monofásica - (Alíquota Zero);
    06 - Operação Tributável - Alíquota Zero;
    07 - Operação Isenta da contribuição;
    08 - Operação Sem Incidência da contribuição;
    09 - Operação com suspensão da contribuição;"""
    subclass = None
    superclass = None
    def __init__(self, CST=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType43(self.CST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISNTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISNTType.subclass:
            return PISNTType.subclass(*args_, **kwargs_)
        else:
            return PISNTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CSTType43(self, value):
        # Validate type CSTType43, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['04', '05', '06', '07', '08', '09']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType43' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PISNTType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISNTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PISNTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PISNTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PISNTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PISNTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType43
            self.validate_CSTType43(self.CST)
# end class PISNTType


class PISOutrType(GeneratedsSuper):
    """Código de Situação Tributária do PIS.
    99 - Outras Operações."""
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pPIS=None, qBCProd=None, vAliqProd=None, vPIS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType44(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pPIS = pPIS
        self.validate_TDec_0302a04(self.pPIS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISOutrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISOutrType.subclass:
            return PISOutrType.subclass(*args_, **kwargs_)
        else:
            return PISOutrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CSTType44(self, value):
        # Validate type CSTType44, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['49', '50', '51', '52', '53', '54', '55', '56', '60', '61', '62', '63', '64', '65', '66', '67', '70', '71', '72', '73', '74', '75', '98', '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType44' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pPIS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PISOutrType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISOutrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PISOutrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PISOutrType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PISOutrType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PISOutrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pPIS>%s</pPIS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pPIS), input_name='pPIS')), eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qBCProd>%s</qBCProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vAliqProd>%s</vAliqProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vPIS>%s</vPIS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType44
            self.validate_CSTType44(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pPIS':
            pPIS_ = child_.text
            pPIS_ = self.gds_validate_string(pPIS_, node, 'pPIS')
            self.pPIS = pPIS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pPIS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISOutrType


class PISSTType(GeneratedsSuper):
    """Dados do PIS Substituição Tributária"""
    subclass = None
    superclass = None
    def __init__(self, vBC=None, pPIS=None, qBCProd=None, vAliqProd=None, vPIS=None):
        self.original_tagname_ = None
        self.vBC = vBC
        self.validate_TDec_1302Opc(self.vBC)
        self.pPIS = pPIS
        self.validate_TDec_0302a04(self.pPIS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104(self.vAliqProd)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISSTType.subclass:
            return PISSTType.subclass(*args_, **kwargs_)
        else:
            return PISSTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1204(self, value):
        # Validate type TDec_1204, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204_patterns_, ))
    validate_TDec_1204_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{4})?$']]
    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [['^0$|^0\\.[0-9]{4}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vBC is not None or
            self.pPIS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PISSTType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PISSTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PISSTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PISSTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PISSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pPIS>%s</pPIS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pPIS), input_name='pPIS')), eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qBCProd>%s</qBCProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vAliqProd>%s</vAliqProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vPIS>%s</vPIS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBC)
        elif nodeName_ == 'pPIS':
            pPIS_ = child_.text
            pPIS_ = self.gds_validate_string(pPIS_, node, 'pPIS')
            self.pPIS = pPIS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pPIS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204
            self.validate_TDec_1204(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vAliqProd)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISSTType


class COFINSType(GeneratedsSuper):
    """Dados do COFINS"""
    subclass = None
    superclass = None
    def __init__(self, COFINSAliq=None, COFINSQtde=None, COFINSNT=None, COFINSOutr=None):
        self.original_tagname_ = None
        self.COFINSAliq = COFINSAliq
        self.COFINSQtde = COFINSQtde
        self.COFINSNT = COFINSNT
        self.COFINSOutr = COFINSOutr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSType.subclass:
            return COFINSType.subclass(*args_, **kwargs_)
        else:
            return COFINSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.COFINSAliq is not None or
            self.COFINSQtde is not None or
            self.COFINSNT is not None or
            self.COFINSOutr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COFINSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COFINSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COFINSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COFINSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='COFINSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.COFINSAliq is not None:
            self.COFINSAliq.export(outfile, level, namespace_, name_='COFINSAliq', pretty_print=pretty_print)
        if self.COFINSQtde is not None:
            self.COFINSQtde.export(outfile, level, namespace_, name_='COFINSQtde', pretty_print=pretty_print)
        if self.COFINSNT is not None:
            self.COFINSNT.export(outfile, level, namespace_, name_='COFINSNT', pretty_print=pretty_print)
        if self.COFINSOutr is not None:
            self.COFINSOutr.export(outfile, level, namespace_, name_='COFINSOutr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'COFINSAliq':
            obj_ = COFINSAliqType.factory()
            obj_.build(child_)
            self.COFINSAliq = obj_
            obj_.original_tagname_ = 'COFINSAliq'
        elif nodeName_ == 'COFINSQtde':
            obj_ = COFINSQtdeType.factory()
            obj_.build(child_)
            self.COFINSQtde = obj_
            obj_.original_tagname_ = 'COFINSQtde'
        elif nodeName_ == 'COFINSNT':
            obj_ = COFINSNTType.factory()
            obj_.build(child_)
            self.COFINSNT = obj_
            obj_.original_tagname_ = 'COFINSNT'
        elif nodeName_ == 'COFINSOutr':
            obj_ = COFINSOutrType.factory()
            obj_.build(child_)
            self.COFINSOutr = obj_
            obj_.original_tagname_ = 'COFINSOutr'
# end class COFINSType


class COFINSAliqType(GeneratedsSuper):
    """Código de Situação Tributária do COFINS.
     01 – Operação Tributável - Base de Cálculo = Valor da Operação
    Alíquota Normal (Cumulativo/Não Cumulativo);
    02 - Operação Tributável - Base de Calculo = Valor da Operação
    (Alíquota Diferenciada);"""
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pCOFINS=None, vCOFINS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType45(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pCOFINS = pCOFINS
        self.validate_TDec_0302a04(self.pCOFINS)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSAliqType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSAliqType.subclass:
            return COFINSAliqType.subclass(*args_, **kwargs_)
        else:
            return COFINSAliqType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CSTType45(self, value):
        # Validate type CSTType45, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType45' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pCOFINS is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COFINSAliqType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSAliqType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COFINSAliqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COFINSAliqType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COFINSAliqType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='COFINSAliqType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pCOFINS>%s</pCOFINS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pCOFINS), input_name='pCOFINS')), eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vCOFINS>%s</vCOFINS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType45
            self.validate_CSTType45(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pCOFINS':
            pCOFINS_ = child_.text
            pCOFINS_ = self.gds_validate_string(pCOFINS_, node, 'pCOFINS')
            self.pCOFINS = pCOFINS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCOFINS)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSAliqType


class COFINSQtdeType(GeneratedsSuper):
    """Código de Situação Tributária do COFINS.
    03 - Operação Tributável - Base de Calculo = Quantidade Vendida x
    Alíquota por Unidade de Produto;"""
    subclass = None
    superclass = None
    def __init__(self, CST=None, qBCProd=None, vAliqProd=None, vCOFINS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType46(self.CST)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSQtdeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSQtdeType.subclass:
            return COFINSQtdeType.subclass(*args_, **kwargs_)
        else:
            return COFINSQtdeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CSTType46(self, value):
        # Validate type CSTType46, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['03']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType46' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COFINSQtdeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSQtdeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COFINSQtdeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COFINSQtdeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COFINSQtdeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='COFINSQtdeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qBCProd>%s</qBCProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vAliqProd>%s</vAliqProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vCOFINS>%s</vCOFINS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType46
            self.validate_CSTType46(self.CST)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSQtdeType


class COFINSNTType(GeneratedsSuper):
    """Código de Situação Tributária do COFINS:
    04 - Operação Tributável - Tributação Monofásica - (Alíquota Zero);
    06 - Operação Tributável - Alíquota Zero;
    07 - Operação Isenta da contribuição;
    08 - Operação Sem Incidência da contribuição;
    09 - Operação com suspensão da contribuição;"""
    subclass = None
    superclass = None
    def __init__(self, CST=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType47(self.CST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSNTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSNTType.subclass:
            return COFINSNTType.subclass(*args_, **kwargs_)
        else:
            return COFINSNTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CSTType47(self, value):
        # Validate type CSTType47, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['04', '05', '06', '07', '08', '09']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType47' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COFINSNTType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSNTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COFINSNTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COFINSNTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COFINSNTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='COFINSNTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType47
            self.validate_CSTType47(self.CST)
# end class COFINSNTType


class COFINSOutrType(GeneratedsSuper):
    """Código de Situação Tributária do COFINS:
    49 - Outras Operações de Saída
    50 - Operação com Direito a Crédito - Vinculada Exclusivamente a
    Receita Tributada no Mercado Interno
    51 - Operação com Direito a Crédito – Vinculada Exclusivamente a
    Receita Não Tributada no Mercado Interno
    52 - Operação com Direito a Crédito - Vinculada Exclusivamente a
    Receita de Exportação
    53 - Operação com Direito a Crédito - Vinculada a Receitas Tributadas e
    Não-Tributadas no Mercado Interno
    54 - Operação com Direito a Crédito - Vinculada a Receitas Tributadas
    no Mercado Interno e de Exportação
    55 - Operação com Direito a Crédito - Vinculada a Receitas Não-
    Tributadas no Mercado Interno e de Exportação
    56 - Operação com Direito a Crédito - Vinculada a Receitas Tributadas e
    Não-Tributadas no Mercado Interno, e de Exportação
    60 - Crédito Presumido - Operação de Aquisição Vinculada Exclusivamente
    a Receita Tributada no Mercado Interno
    61 - Crédito Presumido - Operação de Aquisição Vinculada Exclusivamente
    a Receita Não-Tributada no Mercado Interno
    62 - Crédito Presumido - Operação de Aquisição Vinculada Exclusivamente
    a Receita de Exportação
    63 - Crédito Presumido - Operação de Aquisição Vinculada a Receitas
    Tributadas e Não-Tributadas no Mercado Interno
    64 - Crédito Presumido - Operação de Aquisição Vinculada a Receitas
    Tributadas no Mercado Interno e de Exportação
    65 - Crédito Presumido - Operação de Aquisição Vinculada a Receitas
    Não-Tributadas no Mercado Interno e de Exportação
    66 - Crédito Presumido - Operação de Aquisição Vinculada a Receitas
    Tributadas e Não-Tributadas no Mercado Interno, e de Exportação
    67 - Crédito Presumido - Outras Operações
    70 - Operação de Aquisição sem Direito a Crédito
    71 - Operação de Aquisição com Isenção
    72 - Operação de Aquisição com Suspensão
    73 - Operação de Aquisição a Alíquota Zero
    74 - Operação de Aquisição sem Incidência da Contribuição
    75 - Operação de Aquisição por Substituição Tributária
    98 - Outras Operações de Entrada
    99 - Outras Operações."""
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pCOFINS=None, qBCProd=None, vAliqProd=None, vCOFINS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType48(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pCOFINS = pCOFINS
        self.validate_TDec_0302a04(self.pCOFINS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSOutrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSOutrType.subclass:
            return COFINSOutrType.subclass(*args_, **kwargs_)
        else:
            return COFINSOutrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CSTType48(self, value):
        # Validate type CSTType48, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['49', '50', '51', '52', '53', '54', '55', '56', '60', '61', '62', '63', '64', '65', '66', '67', '70', '71', '72', '73', '74', '75', '98', '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType48' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pCOFINS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COFINSOutrType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSOutrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COFINSOutrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COFINSOutrType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COFINSOutrType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='COFINSOutrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pCOFINS>%s</pCOFINS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pCOFINS), input_name='pCOFINS')), eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qBCProd>%s</qBCProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vAliqProd>%s</vAliqProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vCOFINS>%s</vCOFINS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType48
            self.validate_CSTType48(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pCOFINS':
            pCOFINS_ = child_.text
            pCOFINS_ = self.gds_validate_string(pCOFINS_, node, 'pCOFINS')
            self.pCOFINS = pCOFINS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCOFINS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSOutrType


class COFINSSTType(GeneratedsSuper):
    """Dados do COFINS da
    Substituição Tributaria;"""
    subclass = None
    superclass = None
    def __init__(self, vBC=None, pCOFINS=None, qBCProd=None, vAliqProd=None, vCOFINS=None):
        self.original_tagname_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pCOFINS = pCOFINS
        self.validate_TDec_0302a04(self.pCOFINS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104(self.vAliqProd)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSSTType.subclass:
            return COFINSSTType.subclass(*args_, **kwargs_)
        else:
            return COFINSSTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1204(self, value):
        # Validate type TDec_1204, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204_patterns_, ))
    validate_TDec_1204_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{4})?$']]
    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [['^0$|^0\\.[0-9]{4}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]
    def hasContent_(self):
        if (
            self.vBC is not None or
            self.pCOFINS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COFINSSTType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COFINSSTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COFINSSTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COFINSSTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='COFINSSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pCOFINS>%s</pCOFINS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pCOFINS), input_name='pCOFINS')), eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qBCProd>%s</qBCProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vAliqProd>%s</vAliqProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vCOFINS>%s</vCOFINS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pCOFINS':
            pCOFINS_ = child_.text
            pCOFINS_ = self.gds_validate_string(pCOFINS_, node, 'pCOFINS')
            self.pCOFINS = pCOFINS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCOFINS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204
            self.validate_TDec_1204(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vAliqProd)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSSTType


class ICMSUFDestType(GeneratedsSuper):
    """Grupo a ser informado nas vendas interestarduais para consumidor final,
    não contribuinte de ICMS"""
    subclass = None
    superclass = None
    def __init__(self, vBCUFDest=None, vBCFCPUFDest=None, pFCPUFDest=None, pICMSUFDest=None, pICMSInter=None, pICMSInterPart=None, vFCPUFDest=None, vICMSUFDest=None, vICMSUFRemet=None):
        self.original_tagname_ = None
        self.vBCUFDest = vBCUFDest
        self.validate_TDec_1302(self.vBCUFDest)
        self.vBCFCPUFDest = vBCFCPUFDest
        self.validate_TDec_1302(self.vBCFCPUFDest)
        self.pFCPUFDest = pFCPUFDest
        self.validate_TDec_0302a04(self.pFCPUFDest)
        self.pICMSUFDest = pICMSUFDest
        self.validate_TDec_0302a04(self.pICMSUFDest)
        self.pICMSInter = pICMSInter
        self.validate_pICMSInterType(self.pICMSInter)
        self.pICMSInterPart = pICMSInterPart
        self.validate_TDec_0302a04(self.pICMSInterPart)
        self.vFCPUFDest = vFCPUFDest
        self.validate_TDec_1302(self.vFCPUFDest)
        self.vICMSUFDest = vICMSUFDest
        self.validate_TDec_1302(self.vICMSUFDest)
        self.vICMSUFRemet = vICMSUFRemet
        self.validate_TDec_1302(self.vICMSUFRemet)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSUFDestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSUFDestType.subclass:
            return ICMSUFDestType.subclass(*args_, **kwargs_)
        else:
            return ICMSUFDestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_pICMSInterType(self, value):
        # Validate type pICMSInterType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['4.00', '7.00', '12.00']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on pICMSInterType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.vBCUFDest is not None or
            self.vBCFCPUFDest is not None or
            self.pFCPUFDest is not None or
            self.pICMSUFDest is not None or
            self.pICMSInter is not None or
            self.pICMSInterPart is not None or
            self.vFCPUFDest is not None or
            self.vICMSUFDest is not None or
            self.vICMSUFRemet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSUFDestType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSUFDestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSUFDestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSUFDestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSUFDestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSUFDestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBCUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCUFDest>%s</vBCUFDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCUFDest), input_name='vBCUFDest')), eol_))
        if self.vBCFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCFCPUFDest>%s</vBCFCPUFDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPUFDest), input_name='vBCFCPUFDest')), eol_))
        if self.pFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pFCPUFDest>%s</pFCPUFDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pFCPUFDest), input_name='pFCPUFDest')), eol_))
        if self.pICMSUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSUFDest>%s</pICMSUFDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSUFDest), input_name='pICMSUFDest')), eol_))
        if self.pICMSInter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSInter>%s</pICMSInter>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSInter), input_name='pICMSInter')), eol_))
        if self.pICMSInterPart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSInterPart>%s</pICMSInterPart>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSInterPart), input_name='pICMSInterPart')), eol_))
        if self.vFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPUFDest>%s</vFCPUFDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPUFDest), input_name='vFCPUFDest')), eol_))
        if self.vICMSUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSUFDest>%s</vICMSUFDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFDest), input_name='vICMSUFDest')), eol_))
        if self.vICMSUFRemet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSUFRemet>%s</vICMSUFRemet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFRemet), input_name='vICMSUFRemet')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBCUFDest':
            vBCUFDest_ = child_.text
            vBCUFDest_ = self.gds_validate_string(vBCUFDest_, node, 'vBCUFDest')
            self.vBCUFDest = vBCUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCUFDest)
        elif nodeName_ == 'vBCFCPUFDest':
            vBCFCPUFDest_ = child_.text
            vBCFCPUFDest_ = self.gds_validate_string(vBCFCPUFDest_, node, 'vBCFCPUFDest')
            self.vBCFCPUFDest = vBCFCPUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPUFDest)
        elif nodeName_ == 'pFCPUFDest':
            pFCPUFDest_ = child_.text
            pFCPUFDest_ = self.gds_validate_string(pFCPUFDest_, node, 'pFCPUFDest')
            self.pFCPUFDest = pFCPUFDest_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pFCPUFDest)
        elif nodeName_ == 'pICMSUFDest':
            pICMSUFDest_ = child_.text
            pICMSUFDest_ = self.gds_validate_string(pICMSUFDest_, node, 'pICMSUFDest')
            self.pICMSUFDest = pICMSUFDest_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSUFDest)
        elif nodeName_ == 'pICMSInter':
            pICMSInter_ = child_.text
            pICMSInter_ = self.gds_validate_string(pICMSInter_, node, 'pICMSInter')
            self.pICMSInter = pICMSInter_
            # validate type pICMSInterType
            self.validate_pICMSInterType(self.pICMSInter)
        elif nodeName_ == 'pICMSInterPart':
            pICMSInterPart_ = child_.text
            pICMSInterPart_ = self.gds_validate_string(pICMSInterPart_, node, 'pICMSInterPart')
            self.pICMSInterPart = pICMSInterPart_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSInterPart)
        elif nodeName_ == 'vFCPUFDest':
            vFCPUFDest_ = child_.text
            vFCPUFDest_ = self.gds_validate_string(vFCPUFDest_, node, 'vFCPUFDest')
            self.vFCPUFDest = vFCPUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPUFDest)
        elif nodeName_ == 'vICMSUFDest':
            vICMSUFDest_ = child_.text
            vICMSUFDest_ = self.gds_validate_string(vICMSUFDest_, node, 'vICMSUFDest')
            self.vICMSUFDest = vICMSUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFDest)
        elif nodeName_ == 'vICMSUFRemet':
            vICMSUFRemet_ = child_.text
            vICMSUFRemet_ = self.gds_validate_string(vICMSUFRemet_, node, 'vICMSUFRemet')
            self.vICMSUFRemet = vICMSUFRemet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFRemet)
# end class ICMSUFDestType


class impostoDevolType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pDevol=None, IPI=None):
        self.original_tagname_ = None
        self.pDevol = pDevol
        self.validate_TDec_0302Max100(self.pDevol)
        self.IPI = IPI
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, impostoDevolType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if impostoDevolType.subclass:
            return impostoDevolType.subclass(*args_, **kwargs_)
        else:
            return impostoDevolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_0302Max100(self, value):
        # Validate type TDec_0302Max100, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302Max100_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302Max100_patterns_, ))
    validate_TDec_0302Max100_patterns_ = [['^0(\\.[0-9]{2})?$|^100(\\.00)?$|^[1-9]{1}[0-9]{0,1}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.pDevol is not None or
            self.IPI is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='impostoDevolType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('impostoDevolType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='impostoDevolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='impostoDevolType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='impostoDevolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='impostoDevolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pDevol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pDevol>%s</pDevol>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pDevol), input_name='pDevol')), eol_))
        if self.IPI is not None:
            self.IPI.export(outfile, level, namespace_, name_='IPI', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pDevol':
            pDevol_ = child_.text
            pDevol_ = self.gds_validate_string(pDevol_, node, 'pDevol')
            self.pDevol = pDevol_
            # validate type TDec_0302Max100
            self.validate_TDec_0302Max100(self.pDevol)
        elif nodeName_ == 'IPI':
            obj_ = IPIType.factory()
            obj_.build(child_)
            self.IPI = obj_
            obj_.original_tagname_ = 'IPI'
# end class impostoDevolType


class IPIType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vIPIDevol=None):
        self.original_tagname_ = None
        self.vIPIDevol = vIPIDevol
        self.validate_TDec_1302(self.vIPIDevol)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPIType.subclass:
            return IPIType.subclass(*args_, **kwargs_)
        else:
            return IPIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vIPIDevol is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPIType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPIType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IPIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vIPIDevol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vIPIDevol>%s</vIPIDevol>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vIPIDevol), input_name='vIPIDevol')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vIPIDevol':
            vIPIDevol_ = child_.text
            vIPIDevol_ = self.gds_validate_string(vIPIDevol_, node, 'vIPIDevol')
            self.vIPIDevol = vIPIDevol_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPIDevol)
# end class IPIType


class totalType(GeneratedsSuper):
    """Dados dos totais da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, ICMSTot=None, ISSQNtot=None, retTrib=None):
        self.original_tagname_ = None
        self.ICMSTot = ICMSTot
        self.ISSQNtot = ISSQNtot
        self.retTrib = retTrib
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, totalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if totalType.subclass:
            return totalType.subclass(*args_, **kwargs_)
        else:
            return totalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ICMSTot is not None or
            self.ISSQNtot is not None or
            self.retTrib is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='totalType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('totalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='totalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='totalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='totalType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='totalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMSTot is not None:
            self.ICMSTot.export(outfile, level, namespace_, name_='ICMSTot', pretty_print=pretty_print)
        if self.ISSQNtot is not None:
            self.ISSQNtot.export(outfile, level, namespace_, name_='ISSQNtot', pretty_print=pretty_print)
        if self.retTrib is not None:
            self.retTrib.export(outfile, level, namespace_, name_='retTrib', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ICMSTot':
            obj_ = ICMSTotType.factory()
            obj_.build(child_)
            self.ICMSTot = obj_
            obj_.original_tagname_ = 'ICMSTot'
        elif nodeName_ == 'ISSQNtot':
            obj_ = ISSQNtotType.factory()
            obj_.build(child_)
            self.ISSQNtot = obj_
            obj_.original_tagname_ = 'ISSQNtot'
        elif nodeName_ == 'retTrib':
            obj_ = retTribType.factory()
            obj_.build(child_)
            self.retTrib = obj_
            obj_.original_tagname_ = 'retTrib'
# end class totalType


class ICMSTotType(GeneratedsSuper):
    """Totais referentes ao ICMS"""
    subclass = None
    superclass = None
    def __init__(self, vBC=None, vICMS=None, vICMSDeson=None, vFCPUFDest=None, vICMSUFDest=None, vICMSUFRemet=None, vFCP=None, vBCST=None, vST=None, vFCPST=None, vFCPSTRet=None, vProd=None, vFrete=None, vSeg=None, vDesc=None, vII=None, vIPI=None, vIPIDevol=None, vPIS=None, vCOFINS=None, vOutro=None, vNF=None, vTotTrib=None):
        self.original_tagname_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.vFCPUFDest = vFCPUFDest
        self.validate_TDec_1302(self.vFCPUFDest)
        self.vICMSUFDest = vICMSUFDest
        self.validate_TDec_1302(self.vICMSUFDest)
        self.vICMSUFRemet = vICMSUFRemet
        self.validate_TDec_1302(self.vICMSUFRemet)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.vST = vST
        self.validate_TDec_1302(self.vST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vFCPSTRet = vFCPSTRet
        self.validate_TDec_1302(self.vFCPSTRet)
        self.vProd = vProd
        self.validate_TDec_1302(self.vProd)
        self.vFrete = vFrete
        self.validate_TDec_1302(self.vFrete)
        self.vSeg = vSeg
        self.validate_TDec_1302(self.vSeg)
        self.vDesc = vDesc
        self.validate_TDec_1302(self.vDesc)
        self.vII = vII
        self.validate_TDec_1302(self.vII)
        self.vIPI = vIPI
        self.validate_TDec_1302(self.vIPI)
        self.vIPIDevol = vIPIDevol
        self.validate_TDec_1302(self.vIPIDevol)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
        self.vOutro = vOutro
        self.validate_TDec_1302(self.vOutro)
        self.vNF = vNF
        self.validate_TDec_1302(self.vNF)
        self.vTotTrib = vTotTrib
        self.validate_TDec_1302(self.vTotTrib)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSTotType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSTotType.subclass:
            return ICMSTotType.subclass(*args_, **kwargs_)
        else:
            return ICMSTotType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vBC is not None or
            self.vICMS is not None or
            self.vICMSDeson is not None or
            self.vFCPUFDest is not None or
            self.vICMSUFDest is not None or
            self.vICMSUFRemet is not None or
            self.vFCP is not None or
            self.vBCST is not None or
            self.vST is not None or
            self.vFCPST is not None or
            self.vFCPSTRet is not None or
            self.vProd is not None or
            self.vFrete is not None or
            self.vSeg is not None or
            self.vDesc is not None or
            self.vII is not None or
            self.vIPI is not None or
            self.vIPIDevol is not None or
            self.vPIS is not None or
            self.vCOFINS is not None or
            self.vOutro is not None or
            self.vNF is not None or
            self.vTotTrib is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSTotType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSTotType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSTotType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSTotType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSTotType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSTotType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMS>%s</vICMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSDeson>%s</vICMSDeson>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), eol_))
        if self.vFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPUFDest>%s</vFCPUFDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPUFDest), input_name='vFCPUFDest')), eol_))
        if self.vICMSUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSUFDest>%s</vICMSUFDest>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFDest), input_name='vICMSUFDest')), eol_))
        if self.vICMSUFRemet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSUFRemet>%s</vICMSUFRemet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFRemet), input_name='vICMSUFRemet')), eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCP>%s</vFCP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCST>%s</vBCST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), eol_))
        if self.vST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vST>%s</vST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vST), input_name='vST')), eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPST>%s</vFCPST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), eol_))
        if self.vFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFCPSTRet>%s</vFCPSTRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFCPSTRet), input_name='vFCPSTRet')), eol_))
        if self.vProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vProd>%s</vProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vProd), input_name='vProd')), eol_))
        if self.vFrete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFrete>%s</vFrete>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFrete), input_name='vFrete')), eol_))
        if self.vSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vSeg>%s</vSeg>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vSeg), input_name='vSeg')), eol_))
        if self.vDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDesc>%s</vDesc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDesc), input_name='vDesc')), eol_))
        if self.vII is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vII>%s</vII>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vII), input_name='vII')), eol_))
        if self.vIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vIPI>%s</vIPI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vIPI), input_name='vIPI')), eol_))
        if self.vIPIDevol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vIPIDevol>%s</vIPIDevol>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vIPIDevol), input_name='vIPIDevol')), eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vPIS>%s</vPIS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vCOFINS>%s</vCOFINS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vOutro>%s</vOutro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vOutro), input_name='vOutro')), eol_))
        if self.vNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vNF>%s</vNF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vNF), input_name='vNF')), eol_))
        if self.vTotTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vTotTrib>%s</vTotTrib>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vTotTrib), input_name='vTotTrib')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'vFCPUFDest':
            vFCPUFDest_ = child_.text
            vFCPUFDest_ = self.gds_validate_string(vFCPUFDest_, node, 'vFCPUFDest')
            self.vFCPUFDest = vFCPUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPUFDest)
        elif nodeName_ == 'vICMSUFDest':
            vICMSUFDest_ = child_.text
            vICMSUFDest_ = self.gds_validate_string(vICMSUFDest_, node, 'vICMSUFDest')
            self.vICMSUFDest = vICMSUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFDest)
        elif nodeName_ == 'vICMSUFRemet':
            vICMSUFRemet_ = child_.text
            vICMSUFRemet_ = self.gds_validate_string(vICMSUFRemet_, node, 'vICMSUFRemet')
            self.vICMSUFRemet = vICMSUFRemet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFRemet)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'vST':
            vST_ = child_.text
            vST_ = self.gds_validate_string(vST_, node, 'vST')
            self.vST = vST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vFCPSTRet':
            vFCPSTRet_ = child_.text
            vFCPSTRet_ = self.gds_validate_string(vFCPSTRet_, node, 'vFCPSTRet')
            self.vFCPSTRet = vFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPSTRet)
        elif nodeName_ == 'vProd':
            vProd_ = child_.text
            vProd_ = self.gds_validate_string(vProd_, node, 'vProd')
            self.vProd = vProd_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vProd)
        elif nodeName_ == 'vFrete':
            vFrete_ = child_.text
            vFrete_ = self.gds_validate_string(vFrete_, node, 'vFrete')
            self.vFrete = vFrete_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFrete)
        elif nodeName_ == 'vSeg':
            vSeg_ = child_.text
            vSeg_ = self.gds_validate_string(vSeg_, node, 'vSeg')
            self.vSeg = vSeg_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vSeg)
        elif nodeName_ == 'vDesc':
            vDesc_ = child_.text
            vDesc_ = self.gds_validate_string(vDesc_, node, 'vDesc')
            self.vDesc = vDesc_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDesc)
        elif nodeName_ == 'vII':
            vII_ = child_.text
            vII_ = self.gds_validate_string(vII_, node, 'vII')
            self.vII = vII_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vII)
        elif nodeName_ == 'vIPI':
            vIPI_ = child_.text
            vIPI_ = self.gds_validate_string(vIPI_, node, 'vIPI')
            self.vIPI = vIPI_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPI)
        elif nodeName_ == 'vIPIDevol':
            vIPIDevol_ = child_.text
            vIPIDevol_ = self.gds_validate_string(vIPIDevol_, node, 'vIPIDevol')
            self.vIPIDevol = vIPIDevol_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPIDevol)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vOutro)
        elif nodeName_ == 'vNF':
            vNF_ = child_.text
            vNF_ = self.gds_validate_string(vNF_, node, 'vNF')
            self.vNF = vNF_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vNF)
        elif nodeName_ == 'vTotTrib':
            vTotTrib_ = child_.text
            vTotTrib_ = self.gds_validate_string(vTotTrib_, node, 'vTotTrib')
            self.vTotTrib = vTotTrib_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTotTrib)
# end class ICMSTotType


class ISSQNtotType(GeneratedsSuper):
    """Totais referentes ao ISSQN"""
    subclass = None
    superclass = None
    def __init__(self, vServ=None, vBC=None, vISS=None, vPIS=None, vCOFINS=None, dCompet=None, vDeducao=None, vOutro=None, vDescIncond=None, vDescCond=None, vISSRet=None, cRegTrib=None):
        self.original_tagname_ = None
        self.vServ = vServ
        self.validate_TDec_1302Opc(self.vServ)
        self.vBC = vBC
        self.validate_TDec_1302Opc(self.vBC)
        self.vISS = vISS
        self.validate_TDec_1302Opc(self.vISS)
        self.vPIS = vPIS
        self.validate_TDec_1302Opc(self.vPIS)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302Opc(self.vCOFINS)
        self.dCompet = dCompet
        self.validate_TData(self.dCompet)
        self.vDeducao = vDeducao
        self.validate_TDec_1302Opc(self.vDeducao)
        self.vOutro = vOutro
        self.validate_TDec_1302Opc(self.vOutro)
        self.vDescIncond = vDescIncond
        self.validate_TDec_1302Opc(self.vDescIncond)
        self.vDescCond = vDescCond
        self.validate_TDec_1302Opc(self.vDescCond)
        self.vISSRet = vISSRet
        self.validate_TDec_1302Opc(self.vISSRet)
        self.cRegTrib = cRegTrib
        self.validate_cRegTribType(self.cRegTrib)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISSQNtotType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISSQNtotType.subclass:
            return ISSQNtotType.subclass(*args_, **kwargs_)
        else:
            return ISSQNtotType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]
    def validate_cRegTribType(self, value):
        # Validate type cRegTribType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cRegTribType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.vServ is not None or
            self.vBC is not None or
            self.vISS is not None or
            self.vPIS is not None or
            self.vCOFINS is not None or
            self.dCompet is not None or
            self.vDeducao is not None or
            self.vOutro is not None or
            self.vDescIncond is not None or
            self.vDescCond is not None or
            self.vISSRet is not None or
            self.cRegTrib is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ISSQNtotType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISSQNtotType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISSQNtotType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ISSQNtotType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ISSQNtotType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ISSQNtotType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vServ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vServ>%s</vServ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vServ), input_name='vServ')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.vISS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vISS>%s</vISS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vISS), input_name='vISS')), eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vPIS>%s</vPIS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vCOFINS>%s</vCOFINS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), eol_))
        if self.dCompet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dCompet>%s</dCompet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dCompet), input_name='dCompet')), eol_))
        if self.vDeducao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDeducao>%s</vDeducao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDeducao), input_name='vDeducao')), eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vOutro>%s</vOutro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vOutro), input_name='vOutro')), eol_))
        if self.vDescIncond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDescIncond>%s</vDescIncond>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDescIncond), input_name='vDescIncond')), eol_))
        if self.vDescCond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDescCond>%s</vDescCond>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDescCond), input_name='vDescCond')), eol_))
        if self.vISSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vISSRet>%s</vISSRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vISSRet), input_name='vISSRet')), eol_))
        if self.cRegTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cRegTrib>%s</cRegTrib>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cRegTrib), input_name='cRegTrib')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vServ':
            vServ_ = child_.text
            vServ_ = self.gds_validate_string(vServ_, node, 'vServ')
            self.vServ = vServ_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vServ)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBC)
        elif nodeName_ == 'vISS':
            vISS_ = child_.text
            vISS_ = self.gds_validate_string(vISS_, node, 'vISS')
            self.vISS = vISS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vISS)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vPIS)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vCOFINS)
        elif nodeName_ == 'dCompet':
            dCompet_ = child_.text
            dCompet_ = self.gds_validate_string(dCompet_, node, 'dCompet')
            self.dCompet = dCompet_
            # validate type TData
            self.validate_TData(self.dCompet)
        elif nodeName_ == 'vDeducao':
            vDeducao_ = child_.text
            vDeducao_ = self.gds_validate_string(vDeducao_, node, 'vDeducao')
            self.vDeducao = vDeducao_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDeducao)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOutro)
        elif nodeName_ == 'vDescIncond':
            vDescIncond_ = child_.text
            vDescIncond_ = self.gds_validate_string(vDescIncond_, node, 'vDescIncond')
            self.vDescIncond = vDescIncond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescIncond)
        elif nodeName_ == 'vDescCond':
            vDescCond_ = child_.text
            vDescCond_ = self.gds_validate_string(vDescCond_, node, 'vDescCond')
            self.vDescCond = vDescCond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescCond)
        elif nodeName_ == 'vISSRet':
            vISSRet_ = child_.text
            vISSRet_ = self.gds_validate_string(vISSRet_, node, 'vISSRet')
            self.vISSRet = vISSRet_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vISSRet)
        elif nodeName_ == 'cRegTrib':
            cRegTrib_ = child_.text
            cRegTrib_ = self.gds_validate_string(cRegTrib_, node, 'cRegTrib')
            self.cRegTrib = cRegTrib_
            # validate type cRegTribType
            self.validate_cRegTribType(self.cRegTrib)
# end class ISSQNtotType


class retTribType(GeneratedsSuper):
    """Retenção de Tributos Federais"""
    subclass = None
    superclass = None
    def __init__(self, vRetPIS=None, vRetCOFINS=None, vRetCSLL=None, vBCIRRF=None, vIRRF=None, vBCRetPrev=None, vRetPrev=None):
        self.original_tagname_ = None
        self.vRetPIS = vRetPIS
        self.validate_TDec_1302Opc(self.vRetPIS)
        self.vRetCOFINS = vRetCOFINS
        self.validate_TDec_1302Opc(self.vRetCOFINS)
        self.vRetCSLL = vRetCSLL
        self.validate_TDec_1302Opc(self.vRetCSLL)
        self.vBCIRRF = vBCIRRF
        self.validate_TDec_1302Opc(self.vBCIRRF)
        self.vIRRF = vIRRF
        self.validate_TDec_1302Opc(self.vIRRF)
        self.vBCRetPrev = vBCRetPrev
        self.validate_TDec_1302Opc(self.vBCRetPrev)
        self.vRetPrev = vRetPrev
        self.validate_TDec_1302Opc(self.vRetPrev)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, retTribType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if retTribType.subclass:
            return retTribType.subclass(*args_, **kwargs_)
        else:
            return retTribType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vRetPIS is not None or
            self.vRetCOFINS is not None or
            self.vRetCSLL is not None or
            self.vBCIRRF is not None or
            self.vIRRF is not None or
            self.vBCRetPrev is not None or
            self.vRetPrev is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='retTribType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('retTribType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='retTribType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='retTribType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='retTribType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='retTribType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vRetPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vRetPIS>%s</vRetPIS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vRetPIS), input_name='vRetPIS')), eol_))
        if self.vRetCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vRetCOFINS>%s</vRetCOFINS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vRetCOFINS), input_name='vRetCOFINS')), eol_))
        if self.vRetCSLL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vRetCSLL>%s</vRetCSLL>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vRetCSLL), input_name='vRetCSLL')), eol_))
        if self.vBCIRRF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCIRRF>%s</vBCIRRF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCIRRF), input_name='vBCIRRF')), eol_))
        if self.vIRRF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vIRRF>%s</vIRRF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vIRRF), input_name='vIRRF')), eol_))
        if self.vBCRetPrev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCRetPrev>%s</vBCRetPrev>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCRetPrev), input_name='vBCRetPrev')), eol_))
        if self.vRetPrev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vRetPrev>%s</vRetPrev>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vRetPrev), input_name='vRetPrev')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vRetPIS':
            vRetPIS_ = child_.text
            vRetPIS_ = self.gds_validate_string(vRetPIS_, node, 'vRetPIS')
            self.vRetPIS = vRetPIS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetPIS)
        elif nodeName_ == 'vRetCOFINS':
            vRetCOFINS_ = child_.text
            vRetCOFINS_ = self.gds_validate_string(vRetCOFINS_, node, 'vRetCOFINS')
            self.vRetCOFINS = vRetCOFINS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetCOFINS)
        elif nodeName_ == 'vRetCSLL':
            vRetCSLL_ = child_.text
            vRetCSLL_ = self.gds_validate_string(vRetCSLL_, node, 'vRetCSLL')
            self.vRetCSLL = vRetCSLL_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetCSLL)
        elif nodeName_ == 'vBCIRRF':
            vBCIRRF_ = child_.text
            vBCIRRF_ = self.gds_validate_string(vBCIRRF_, node, 'vBCIRRF')
            self.vBCIRRF = vBCIRRF_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBCIRRF)
        elif nodeName_ == 'vIRRF':
            vIRRF_ = child_.text
            vIRRF_ = self.gds_validate_string(vIRRF_, node, 'vIRRF')
            self.vIRRF = vIRRF_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vIRRF)
        elif nodeName_ == 'vBCRetPrev':
            vBCRetPrev_ = child_.text
            vBCRetPrev_ = self.gds_validate_string(vBCRetPrev_, node, 'vBCRetPrev')
            self.vBCRetPrev = vBCRetPrev_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBCRetPrev)
        elif nodeName_ == 'vRetPrev':
            vRetPrev_ = child_.text
            vRetPrev_ = self.gds_validate_string(vRetPrev_, node, 'vRetPrev')
            self.vRetPrev = vRetPrev_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetPrev)
# end class retTribType


class transpType(GeneratedsSuper):
    """Dados dos transportes da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, modFrete=None, transporta=None, retTransp=None, veicTransp=None, reboque=None, vagao=None, balsa=None, vol=None):
        self.original_tagname_ = None
        self.modFrete = modFrete
        self.validate_modFreteType(self.modFrete)
        self.transporta = transporta
        self.retTransp = retTransp
        self.veicTransp = veicTransp
        if reboque is None:
            self.reboque = []
        else:
            self.reboque = reboque
        self.vagao = vagao
        self.validate_vagaoType(self.vagao)
        self.balsa = balsa
        self.validate_balsaType(self.balsa)
        if vol is None:
            self.vol = []
        else:
            self.vol = vol
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transpType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transpType.subclass:
            return transpType.subclass(*args_, **kwargs_)
        else:
            return transpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_modFreteType(self, value):
        # Validate type modFreteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modFreteType' % {"value" : value.encode("utf-8")} )
    def validate_vagaoType(self, value):
        # Validate type vagaoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on vagaoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on vagaoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_vagaoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_vagaoType_patterns_, ))
    validate_vagaoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_balsaType(self, value):
        # Validate type balsaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on balsaType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on balsaType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_balsaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_balsaType_patterns_, ))
    validate_balsaType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.modFrete is not None or
            self.transporta is not None or
            self.retTransp is not None or
            self.veicTransp is not None or
            self.reboque or
            self.vagao is not None or
            self.balsa is not None or
            self.vol
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transpType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transpType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transpType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transpType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='transpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.modFrete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modFrete>%s</modFrete>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modFrete), input_name='modFrete')), eol_))
        if self.transporta is not None:
            self.transporta.export(outfile, level, namespace_, name_='transporta', pretty_print=pretty_print)
        if self.retTransp is not None:
            self.retTransp.export(outfile, level, namespace_, name_='retTransp', pretty_print=pretty_print)
        if self.veicTransp is not None:
            self.veicTransp.export(outfile, level, namespace_, name_='veicTransp', pretty_print=pretty_print)
        for reboque_ in self.reboque:
            reboque_.export(outfile, level, namespace_, name_='reboque', pretty_print=pretty_print)
        if self.vagao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vagao>%s</vagao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vagao), input_name='vagao')), eol_))
        if self.balsa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<balsa>%s</balsa>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.balsa), input_name='balsa')), eol_))
        for vol_ in self.vol:
            vol_.export(outfile, level, namespace_, name_='vol', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modFrete':
            modFrete_ = child_.text
            modFrete_ = self.gds_validate_string(modFrete_, node, 'modFrete')
            self.modFrete = modFrete_
            # validate type modFreteType
            self.validate_modFreteType(self.modFrete)
        elif nodeName_ == 'transporta':
            obj_ = transportaType.factory()
            obj_.build(child_)
            self.transporta = obj_
            obj_.original_tagname_ = 'transporta'
        elif nodeName_ == 'retTransp':
            obj_ = retTranspType.factory()
            obj_.build(child_)
            self.retTransp = obj_
            obj_.original_tagname_ = 'retTransp'
        elif nodeName_ == 'veicTransp':
            obj_ = TVeiculo.factory()
            obj_.build(child_)
            self.veicTransp = obj_
            obj_.original_tagname_ = 'veicTransp'
        elif nodeName_ == 'reboque':
            obj_ = TVeiculo.factory()
            obj_.build(child_)
            self.reboque.append(obj_)
            obj_.original_tagname_ = 'reboque'
        elif nodeName_ == 'vagao':
            vagao_ = child_.text
            vagao_ = self.gds_validate_string(vagao_, node, 'vagao')
            self.vagao = vagao_
            # validate type vagaoType
            self.validate_vagaoType(self.vagao)
        elif nodeName_ == 'balsa':
            balsa_ = child_.text
            balsa_ = self.gds_validate_string(balsa_, node, 'balsa')
            self.balsa = balsa_
            # validate type balsaType
            self.validate_balsaType(self.balsa)
        elif nodeName_ == 'vol':
            obj_ = volType.factory()
            obj_.build(child_)
            self.vol.append(obj_)
            obj_.original_tagname_ = 'vol'
# end class transpType


class transportaType(GeneratedsSuper):
    """Dados do transportador"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xNome=None, IE=None, xEnder=None, xMun=None, UF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.xNome = xNome
        self.validate_xNomeType49(self.xNome)
        self.IE = IE
        self.validate_TIeDest(self.IE)
        self.xEnder = xEnder
        self.validate_xEnderType(self.xEnder)
        self.xMun = xMun
        self.validate_xMunType(self.xMun)
        self.UF = UF
        self.validate_TUf(self.UF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transportaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transportaType.subclass:
            return transportaType.subclass(*args_, **kwargs_)
        else:
            return transportaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def validate_xNomeType49(self, value):
        # Validate type xNomeType49, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeType49' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeType49' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType49_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeType49_patterns_, ))
    validate_xNomeType49_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TIeDest(self, value):
        # Validate type TIeDest, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TIeDest' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeDest_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIeDest_patterns_, ))
    validate_TIeDest_patterns_ = [['^ISENTO$|^[0-9]{2,14}$']]
    def validate_xEnderType(self, value):
        # Validate type xEnderType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xEnderType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xEnderType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xEnderType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xEnderType_patterns_, ))
    validate_xEnderType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xMunType(self, value):
        # Validate type xMunType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType_patterns_, ))
    validate_xMunType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.IE is not None or
            self.xEnder is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transportaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transportaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transportaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transportaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transportaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='transportaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNome>%s</xNome>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IE>%s</IE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), eol_))
        if self.xEnder is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xEnder>%s</xEnder>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xEnder), input_name='xEnder')), eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMun>%s</xMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType49
            self.validate_xNomeType49(self.xNome)
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIeDest
            self.validate_TIeDest(self.IE)
        elif nodeName_ == 'xEnder':
            xEnder_ = child_.text
            xEnder_ = self.gds_validate_string(xEnder_, node, 'xEnder')
            self.xEnder = xEnder_
            # validate type xEnderType
            self.validate_xEnderType(self.xEnder)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType
            self.validate_xMunType(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
# end class transportaType


class retTranspType(GeneratedsSuper):
    """Dados da retenção  ICMS do Transporte"""
    subclass = None
    superclass = None
    def __init__(self, vServ=None, vBCRet=None, pICMSRet=None, vICMSRet=None, CFOP=None, cMunFG=None):
        self.original_tagname_ = None
        self.vServ = vServ
        self.validate_TDec_1302(self.vServ)
        self.vBCRet = vBCRet
        self.validate_TDec_1302(self.vBCRet)
        self.pICMSRet = pICMSRet
        self.validate_TDec_0302a04(self.pICMSRet)
        self.vICMSRet = vICMSRet
        self.validate_TDec_1302(self.vICMSRet)
        self.CFOP = CFOP
        self.validate_CFOPType50(self.CFOP)
        self.cMunFG = cMunFG
        self.validate_TCodMunIBGE(self.cMunFG)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, retTranspType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if retTranspType.subclass:
            return retTranspType.subclass(*args_, **kwargs_)
        else:
            return retTranspType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_CFOPType50(self, value):
        # Validate type CFOPType50, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CFOPType50_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CFOPType50_patterns_, ))
    validate_CFOPType50_patterns_ = [['^[1,2,3,5,6,7]{1}[0-9]{3}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def hasContent_(self):
        if (
            self.vServ is not None or
            self.vBCRet is not None or
            self.pICMSRet is not None or
            self.vICMSRet is not None or
            self.CFOP is not None or
            self.cMunFG is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='retTranspType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('retTranspType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='retTranspType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='retTranspType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='retTranspType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='retTranspType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vServ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vServ>%s</vServ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vServ), input_name='vServ')), eol_))
        if self.vBCRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBCRet>%s</vBCRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBCRet), input_name='vBCRet')), eol_))
        if self.pICMSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pICMSRet>%s</pICMSRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pICMSRet), input_name='pICMSRet')), eol_))
        if self.vICMSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vICMSRet>%s</vICMSRet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vICMSRet), input_name='vICMSRet')), eol_))
        if self.CFOP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CFOP>%s</CFOP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CFOP), input_name='CFOP')), eol_))
        if self.cMunFG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMunFG>%s</cMunFG>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMunFG), input_name='cMunFG')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vServ':
            vServ_ = child_.text
            vServ_ = self.gds_validate_string(vServ_, node, 'vServ')
            self.vServ = vServ_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vServ)
        elif nodeName_ == 'vBCRet':
            vBCRet_ = child_.text
            vBCRet_ = self.gds_validate_string(vBCRet_, node, 'vBCRet')
            self.vBCRet = vBCRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCRet)
        elif nodeName_ == 'pICMSRet':
            pICMSRet_ = child_.text
            pICMSRet_ = self.gds_validate_string(pICMSRet_, node, 'pICMSRet')
            self.pICMSRet = pICMSRet_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSRet)
        elif nodeName_ == 'vICMSRet':
            vICMSRet_ = child_.text
            vICMSRet_ = self.gds_validate_string(vICMSRet_, node, 'vICMSRet')
            self.vICMSRet = vICMSRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSRet)
        elif nodeName_ == 'CFOP':
            CFOP_ = child_.text
            CFOP_ = self.gds_validate_string(CFOP_, node, 'CFOP')
            self.CFOP = CFOP_
            # validate type CFOPType50
            self.validate_CFOPType50(self.CFOP)
        elif nodeName_ == 'cMunFG':
            cMunFG_ = child_.text
            cMunFG_ = self.gds_validate_string(cMunFG_, node, 'cMunFG')
            self.cMunFG = cMunFG_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunFG)
# end class retTranspType


class volType(GeneratedsSuper):
    """Dados dos volumes"""
    subclass = None
    superclass = None
    def __init__(self, qVol=None, esp=None, marca=None, nVol=None, pesoL=None, pesoB=None, lacres=None):
        self.original_tagname_ = None
        self.qVol = qVol
        self.validate_qVolType(self.qVol)
        self.esp = esp
        self.validate_espType(self.esp)
        self.marca = marca
        self.validate_marcaType(self.marca)
        self.nVol = nVol
        self.validate_nVolType(self.nVol)
        self.pesoL = pesoL
        self.validate_TDec_1203(self.pesoL)
        self.pesoB = pesoB
        self.validate_TDec_1203(self.pesoB)
        if lacres is None:
            self.lacres = []
        else:
            self.lacres = lacres
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, volType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if volType.subclass:
            return volType.subclass(*args_, **kwargs_)
        else:
            return volType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_qVolType(self, value):
        # Validate type qVolType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_qVolType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qVolType_patterns_, ))
    validate_qVolType_patterns_ = [['^[0-9]{1,15}$']]
    def validate_espType(self, value):
        # Validate type espType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on espType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on espType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_espType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_espType_patterns_, ))
    validate_espType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_marcaType(self, value):
        # Validate type marcaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on marcaType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on marcaType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_marcaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_marcaType_patterns_, ))
    validate_marcaType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nVolType(self, value):
        # Validate type nVolType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nVolType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nVolType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nVolType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nVolType_patterns_, ))
    validate_nVolType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TDec_1203(self, value):
        # Validate type TDec_1203, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1203_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1203_patterns_, ))
    validate_TDec_1203_patterns_ = [['^0$|^0\\.[0-9]{3}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{3})?$']]
    def hasContent_(self):
        if (
            self.qVol is not None or
            self.esp is not None or
            self.marca is not None or
            self.nVol is not None or
            self.pesoL is not None or
            self.pesoB is not None or
            self.lacres
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='volType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('volType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='volType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='volType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='volType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='volType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qVol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qVol>%s</qVol>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qVol), input_name='qVol')), eol_))
        if self.esp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<esp>%s</esp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.esp), input_name='esp')), eol_))
        if self.marca is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<marca>%s</marca>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.marca), input_name='marca')), eol_))
        if self.nVol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nVol>%s</nVol>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nVol), input_name='nVol')), eol_))
        if self.pesoL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pesoL>%s</pesoL>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pesoL), input_name='pesoL')), eol_))
        if self.pesoB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pesoB>%s</pesoB>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pesoB), input_name='pesoB')), eol_))
        for lacres_ in self.lacres:
            lacres_.export(outfile, level, namespace_, name_='lacres', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qVol':
            qVol_ = child_.text
            qVol_ = self.gds_validate_string(qVol_, node, 'qVol')
            self.qVol = qVol_
            # validate type qVolType
            self.validate_qVolType(self.qVol)
        elif nodeName_ == 'esp':
            esp_ = child_.text
            esp_ = self.gds_validate_string(esp_, node, 'esp')
            self.esp = esp_
            # validate type espType
            self.validate_espType(self.esp)
        elif nodeName_ == 'marca':
            marca_ = child_.text
            marca_ = self.gds_validate_string(marca_, node, 'marca')
            self.marca = marca_
            # validate type marcaType
            self.validate_marcaType(self.marca)
        elif nodeName_ == 'nVol':
            nVol_ = child_.text
            nVol_ = self.gds_validate_string(nVol_, node, 'nVol')
            self.nVol = nVol_
            # validate type nVolType
            self.validate_nVolType(self.nVol)
        elif nodeName_ == 'pesoL':
            pesoL_ = child_.text
            pesoL_ = self.gds_validate_string(pesoL_, node, 'pesoL')
            self.pesoL = pesoL_
            # validate type TDec_1203
            self.validate_TDec_1203(self.pesoL)
        elif nodeName_ == 'pesoB':
            pesoB_ = child_.text
            pesoB_ = self.gds_validate_string(pesoB_, node, 'pesoB')
            self.pesoB = pesoB_
            # validate type TDec_1203
            self.validate_TDec_1203(self.pesoB)
        elif nodeName_ == 'lacres':
            obj_ = lacresType.factory()
            obj_.build(child_)
            self.lacres.append(obj_)
            obj_.original_tagname_ = 'lacres'
# end class volType


class lacresType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nLacre=None):
        self.original_tagname_ = None
        self.nLacre = nLacre
        self.validate_nLacreType(self.nLacre)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacresType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacresType.subclass:
            return lacresType.subclass(*args_, **kwargs_)
        else:
            return lacresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nLacreType(self, value):
        # Validate type nLacreType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nLacreType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nLacreType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nLacreType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nLacreType_patterns_, ))
    validate_nLacreType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lacresType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacresType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lacresType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lacresType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lacresType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lacresType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nLacre>%s</nLacre>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nLacre), input_name='nLacre')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLacre':
            nLacre_ = child_.text
            nLacre_ = self.gds_validate_string(nLacre_, node, 'nLacre')
            self.nLacre = nLacre_
            # validate type nLacreType
            self.validate_nLacreType(self.nLacre)
# end class lacresType


class cobrType(GeneratedsSuper):
    """Dados da cobrança da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, fat=None, dup=None):
        self.original_tagname_ = None
        self.fat = fat
        if dup is None:
            self.dup = []
        else:
            self.dup = dup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cobrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cobrType.subclass:
            return cobrType.subclass(*args_, **kwargs_)
        else:
            return cobrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.fat is not None or
            self.dup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cobrType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cobrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cobrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cobrType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cobrType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cobrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fat is not None:
            self.fat.export(outfile, level, namespace_, name_='fat', pretty_print=pretty_print)
        for dup_ in self.dup:
            dup_.export(outfile, level, namespace_, name_='dup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fat':
            obj_ = fatType.factory()
            obj_.build(child_)
            self.fat = obj_
            obj_.original_tagname_ = 'fat'
        elif nodeName_ == 'dup':
            obj_ = dupType.factory()
            obj_.build(child_)
            self.dup.append(obj_)
            obj_.original_tagname_ = 'dup'
# end class cobrType


class fatType(GeneratedsSuper):
    """Dados da fatura"""
    subclass = None
    superclass = None
    def __init__(self, nFat=None, vOrig=None, vDesc=None, vLiq=None):
        self.original_tagname_ = None
        self.nFat = nFat
        self.validate_nFatType(self.nFat)
        self.vOrig = vOrig
        self.validate_TDec_1302(self.vOrig)
        self.vDesc = vDesc
        self.validate_TDec_1302(self.vDesc)
        self.vLiq = vLiq
        self.validate_TDec_1302(self.vLiq)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fatType.subclass:
            return fatType.subclass(*args_, **kwargs_)
        else:
            return fatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nFatType(self, value):
        # Validate type nFatType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nFatType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nFatType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nFatType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nFatType_patterns_, ))
    validate_nFatType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.nFat is not None or
            self.vOrig is not None or
            self.vDesc is not None or
            self.vLiq is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fatType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fatType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fatType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fatType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nFat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nFat>%s</nFat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nFat), input_name='nFat')), eol_))
        if self.vOrig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vOrig>%s</vOrig>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vOrig), input_name='vOrig')), eol_))
        if self.vDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDesc>%s</vDesc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDesc), input_name='vDesc')), eol_))
        if self.vLiq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vLiq>%s</vLiq>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vLiq), input_name='vLiq')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nFat':
            nFat_ = child_.text
            nFat_ = self.gds_validate_string(nFat_, node, 'nFat')
            self.nFat = nFat_
            # validate type nFatType
            self.validate_nFatType(self.nFat)
        elif nodeName_ == 'vOrig':
            vOrig_ = child_.text
            vOrig_ = self.gds_validate_string(vOrig_, node, 'vOrig')
            self.vOrig = vOrig_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vOrig)
        elif nodeName_ == 'vDesc':
            vDesc_ = child_.text
            vDesc_ = self.gds_validate_string(vDesc_, node, 'vDesc')
            self.vDesc = vDesc_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDesc)
        elif nodeName_ == 'vLiq':
            vLiq_ = child_.text
            vLiq_ = self.gds_validate_string(vLiq_, node, 'vLiq')
            self.vLiq = vLiq_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vLiq)
# end class fatType


class dupType(GeneratedsSuper):
    """Dados das duplicatas NT 2011/004"""
    subclass = None
    superclass = None
    def __init__(self, nDup=None, dVenc=None, vDup=None):
        self.original_tagname_ = None
        self.nDup = nDup
        self.validate_nDupType(self.nDup)
        self.dVenc = dVenc
        self.validate_TData(self.dVenc)
        self.vDup = vDup
        self.validate_TDec_1302Opc(self.vDup)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dupType.subclass:
            return dupType.subclass(*args_, **kwargs_)
        else:
            return dupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nDupType(self, value):
        # Validate type nDupType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nDupType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nDupType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nDupType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nDupType_patterns_, ))
    validate_nDupType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [['^0\\.[0-9]{1}[1-9]{1}$|^0\\.[1-9]{1}[0-9]{1}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.nDup is not None or
            self.dVenc is not None or
            self.vDup is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dupType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dupType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nDup>%s</nDup>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nDup), input_name='nDup')), eol_))
        if self.dVenc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dVenc>%s</dVenc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dVenc), input_name='dVenc')), eol_))
        if self.vDup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDup>%s</vDup>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDup), input_name='vDup')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nDup':
            nDup_ = child_.text
            nDup_ = self.gds_validate_string(nDup_, node, 'nDup')
            self.nDup = nDup_
            # validate type nDupType
            self.validate_nDupType(self.nDup)
        elif nodeName_ == 'dVenc':
            dVenc_ = child_.text
            dVenc_ = self.gds_validate_string(dVenc_, node, 'dVenc')
            self.dVenc = dVenc_
            # validate type TData
            self.validate_TData(self.dVenc)
        elif nodeName_ == 'vDup':
            vDup_ = child_.text
            vDup_ = self.gds_validate_string(vDup_, node, 'vDup')
            self.vDup = vDup_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDup)
# end class dupType


class pagType(GeneratedsSuper):
    """Dados de Pagamento. Obrigatório apenas para (NFC-e) NT 2012/004"""
    subclass = None
    superclass = None
    def __init__(self, detPag=None, vTroco=None):
        self.original_tagname_ = None
        if detPag is None:
            self.detPag = []
        else:
            self.detPag = detPag
        self.vTroco = vTroco
        self.validate_TDec_1302(self.vTroco)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pagType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pagType.subclass:
            return pagType.subclass(*args_, **kwargs_)
        else:
            return pagType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.detPag or
            self.vTroco is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pagType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pagType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pagType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pagType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pagType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='pagType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for detPag_ in self.detPag:
            detPag_.export(outfile, level, namespace_, name_='detPag', pretty_print=pretty_print)
        if self.vTroco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vTroco>%s</vTroco>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vTroco), input_name='vTroco')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'detPag':
            obj_ = detPagType.factory()
            obj_.build(child_)
            self.detPag.append(obj_)
            obj_.original_tagname_ = 'detPag'
        elif nodeName_ == 'vTroco':
            vTroco_ = child_.text
            vTroco_ = self.gds_validate_string(vTroco_, node, 'vTroco')
            self.vTroco = vTroco_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTroco)
# end class pagType


class detPagType(GeneratedsSuper):
    """Grupo de detalhamento da forma de pagamento."""
    subclass = None
    superclass = None
    def __init__(self, indPag=None, tPag=None, vPag=None, card=None):
        self.original_tagname_ = None
        self.indPag = indPag
        self.validate_indPagType(self.indPag)
        self.tPag = tPag
        self.validate_tPagType(self.tPag)
        self.vPag = vPag
        self.validate_TDec_1302(self.vPag)
        self.card = card
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detPagType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detPagType.subclass:
            return detPagType.subclass(*args_, **kwargs_)
        else:
            return detPagType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_indPagType(self, value):
        # Validate type indPagType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indPagType' % {"value" : value.encode("utf-8")} )
    def validate_tPagType(self, value):
        # Validate type tPagType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02', '03', '04', '05', '10', '11', '12', '13', '14', '15', '90', '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tPagType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.indPag is not None or
            self.tPag is not None or
            self.vPag is not None or
            self.card is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='detPagType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detPagType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='detPagType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='detPagType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='detPagType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='detPagType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indPag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indPag>%s</indPag>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indPag), input_name='indPag')), eol_))
        if self.tPag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tPag>%s</tPag>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tPag), input_name='tPag')), eol_))
        if self.vPag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vPag>%s</vPag>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vPag), input_name='vPag')), eol_))
        if self.card is not None:
            self.card.export(outfile, level, namespace_, name_='card', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indPag':
            indPag_ = child_.text
            indPag_ = self.gds_validate_string(indPag_, node, 'indPag')
            self.indPag = indPag_
            # validate type indPagType
            self.validate_indPagType(self.indPag)
        elif nodeName_ == 'tPag':
            tPag_ = child_.text
            tPag_ = self.gds_validate_string(tPag_, node, 'tPag')
            self.tPag = tPag_
            # validate type tPagType
            self.validate_tPagType(self.tPag)
        elif nodeName_ == 'vPag':
            vPag_ = child_.text
            vPag_ = self.gds_validate_string(vPag_, node, 'vPag')
            self.vPag = vPag_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPag)
        elif nodeName_ == 'card':
            obj_ = cardType.factory()
            obj_.build(child_)
            self.card = obj_
            obj_.original_tagname_ = 'card'
# end class detPagType


class cardType(GeneratedsSuper):
    """Grupo de Cartões"""
    subclass = None
    superclass = None
    def __init__(self, tpIntegra=None, CNPJ=None, tBand=None, cAut=None):
        self.original_tagname_ = None
        self.tpIntegra = tpIntegra
        self.validate_tpIntegraType(self.tpIntegra)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.tBand = tBand
        self.validate_tBandType(self.tBand)
        self.cAut = cAut
        self.validate_cAutType(self.cAut)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardType.subclass:
            return cardType.subclass(*args_, **kwargs_)
        else:
            return cardType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpIntegraType(self, value):
        # Validate type tpIntegraType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpIntegraType' % {"value" : value.encode("utf-8")} )
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_tBandType(self, value):
        # Validate type tBandType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tBandType' % {"value" : value.encode("utf-8")} )
    def validate_cAutType(self, value):
        # Validate type cAutType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cAutType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cAutType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cAutType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cAutType_patterns_, ))
    validate_cAutType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.tpIntegra is not None or
            self.CNPJ is not None or
            self.tBand is not None or
            self.cAut is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cardType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cardType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cardType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cardType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cardType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cardType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpIntegra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpIntegra>%s</tpIntegra>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpIntegra), input_name='tpIntegra')), eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.tBand is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tBand>%s</tBand>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tBand), input_name='tBand')), eol_))
        if self.cAut is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cAut>%s</cAut>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cAut), input_name='cAut')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpIntegra':
            tpIntegra_ = child_.text
            tpIntegra_ = self.gds_validate_string(tpIntegra_, node, 'tpIntegra')
            self.tpIntegra = tpIntegra_
            # validate type tpIntegraType
            self.validate_tpIntegraType(self.tpIntegra)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'tBand':
            tBand_ = child_.text
            tBand_ = self.gds_validate_string(tBand_, node, 'tBand')
            self.tBand = tBand_
            # validate type tBandType
            self.validate_tBandType(self.tBand)
        elif nodeName_ == 'cAut':
            cAut_ = child_.text
            cAut_ = self.gds_validate_string(cAut_, node, 'cAut')
            self.cAut = cAut_
            # validate type cAutType
            self.validate_cAutType(self.cAut)
# end class cardType


class infAdicType(GeneratedsSuper):
    """Informações adicionais da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, infAdFisco=None, infCpl=None, obsCont=None, obsFisco=None, procRef=None):
        self.original_tagname_ = None
        self.infAdFisco = infAdFisco
        self.validate_infAdFiscoType(self.infAdFisco)
        self.infCpl = infCpl
        self.validate_infCplType(self.infCpl)
        if obsCont is None:
            self.obsCont = []
        else:
            self.obsCont = obsCont
        if obsFisco is None:
            self.obsFisco = []
        else:
            self.obsFisco = obsFisco
        if procRef is None:
            self.procRef = []
        else:
            self.procRef = procRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infAdicType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infAdicType.subclass:
            return infAdicType.subclass(*args_, **kwargs_)
        else:
            return infAdicType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_infAdFiscoType(self, value):
        # Validate type infAdFiscoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on infAdFiscoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on infAdFiscoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_infAdFiscoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_infAdFiscoType_patterns_, ))
    validate_infAdFiscoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_infCplType(self, value):
        # Validate type infCplType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 5000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on infCplType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on infCplType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_infCplType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_infCplType_patterns_, ))
    validate_infCplType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.infAdFisco is not None or
            self.infCpl is not None or
            self.obsCont or
            self.obsFisco or
            self.procRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infAdicType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infAdicType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infAdicType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infAdicType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infAdicType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infAdicType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infAdFisco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<infAdFisco>%s</infAdFisco>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.infAdFisco), input_name='infAdFisco')), eol_))
        if self.infCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<infCpl>%s</infCpl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.infCpl), input_name='infCpl')), eol_))
        for obsCont_ in self.obsCont:
            obsCont_.export(outfile, level, namespace_, name_='obsCont', pretty_print=pretty_print)
        for obsFisco_ in self.obsFisco:
            obsFisco_.export(outfile, level, namespace_, name_='obsFisco', pretty_print=pretty_print)
        for procRef_ in self.procRef:
            procRef_.export(outfile, level, namespace_, name_='procRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infAdFisco':
            infAdFisco_ = child_.text
            infAdFisco_ = self.gds_validate_string(infAdFisco_, node, 'infAdFisco')
            self.infAdFisco = infAdFisco_
            # validate type infAdFiscoType
            self.validate_infAdFiscoType(self.infAdFisco)
        elif nodeName_ == 'infCpl':
            infCpl_ = child_.text
            infCpl_ = self.gds_validate_string(infCpl_, node, 'infCpl')
            self.infCpl = infCpl_
            # validate type infCplType
            self.validate_infCplType(self.infCpl)
        elif nodeName_ == 'obsCont':
            obj_ = obsContType.factory()
            obj_.build(child_)
            self.obsCont.append(obj_)
            obj_.original_tagname_ = 'obsCont'
        elif nodeName_ == 'obsFisco':
            obj_ = obsFiscoType.factory()
            obj_.build(child_)
            self.obsFisco.append(obj_)
            obj_.original_tagname_ = 'obsFisco'
        elif nodeName_ == 'procRef':
            obj_ = procRefType.factory()
            obj_.build(child_)
            self.procRef.append(obj_)
            obj_.original_tagname_ = 'procRef'
# end class infAdicType


class obsContType(GeneratedsSuper):
    """Campo de uso livre do contribuinte
    informar o nome do campo no atributo xCampo
    e o conteúdo do campo no xTexto"""
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None):
        self.original_tagname_ = None
        self.xCampo = _cast(None, xCampo)
        self.xTexto = xTexto
        self.validate_xTextoType(self.xTexto)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, obsContType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if obsContType.subclass:
            return obsContType.subclass(*args_, **kwargs_)
        else:
            return obsContType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_xTextoType(self, value):
        # Validate type xTextoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xTextoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xTextoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xTextoType_patterns_, ))
    validate_xTextoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TString(self, value):
        # Validate type TString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TString_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TString_patterns_, ))
    validate_TString_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='obsContType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('obsContType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='obsContType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='obsContType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='obsContType'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='obsContType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xTexto>%s</xTexto>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xTexto), input_name='xTexto')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_TString(self.xCampo)    # validate type TString
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xTexto':
            xTexto_ = child_.text
            xTexto_ = self.gds_validate_string(xTexto_, node, 'xTexto')
            self.xTexto = xTexto_
            # validate type xTextoType
            self.validate_xTextoType(self.xTexto)
# end class obsContType


class obsFiscoType(GeneratedsSuper):
    """Campo de uso exclusivo do Fisco
    informar o nome do campo no atributo xCampo
    e o conteúdo do campo no xTexto"""
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None):
        self.original_tagname_ = None
        self.xCampo = _cast(None, xCampo)
        self.xTexto = xTexto
        self.validate_xTextoType51(self.xTexto)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, obsFiscoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if obsFiscoType.subclass:
            return obsFiscoType.subclass(*args_, **kwargs_)
        else:
            return obsFiscoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_xTextoType51(self, value):
        # Validate type xTextoType51, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xTextoType51' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xTextoType51' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType51_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xTextoType51_patterns_, ))
    validate_xTextoType51_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TString(self, value):
        # Validate type TString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TString_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TString_patterns_, ))
    validate_TString_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='obsFiscoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('obsFiscoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='obsFiscoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='obsFiscoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='obsFiscoType'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='obsFiscoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xTexto>%s</xTexto>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xTexto), input_name='xTexto')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_TString(self.xCampo)    # validate type TString
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xTexto':
            xTexto_ = child_.text
            xTexto_ = self.gds_validate_string(xTexto_, node, 'xTexto')
            self.xTexto = xTexto_
            # validate type xTextoType51
            self.validate_xTextoType51(self.xTexto)
# end class obsFiscoType


class procRefType(GeneratedsSuper):
    """Grupo de informações do  processo referenciado"""
    subclass = None
    superclass = None
    def __init__(self, nProc=None, indProc=None):
        self.original_tagname_ = None
        self.nProc = nProc
        self.validate_nProcType(self.nProc)
        self.indProc = indProc
        self.validate_indProcType(self.indProc)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, procRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if procRefType.subclass:
            return procRefType.subclass(*args_, **kwargs_)
        else:
            return procRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_nProcType(self, value):
        # Validate type nProcType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nProcType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nProcType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nProcType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nProcType_patterns_, ))
    validate_nProcType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_indProcType(self, value):
        # Validate type indProcType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indProcType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.nProc is not None or
            self.indProc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='procRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('procRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='procRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='procRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='procRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='procRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nProc>%s</nProc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nProc), input_name='nProc')), eol_))
        if self.indProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indProc>%s</indProc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indProc), input_name='indProc')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nProc':
            nProc_ = child_.text
            nProc_ = self.gds_validate_string(nProc_, node, 'nProc')
            self.nProc = nProc_
            # validate type nProcType
            self.validate_nProcType(self.nProc)
        elif nodeName_ == 'indProc':
            indProc_ = child_.text
            indProc_ = self.gds_validate_string(indProc_, node, 'indProc')
            self.indProc = indProc_
            # validate type indProcType
            self.validate_indProcType(self.indProc)
# end class procRefType


class exportaType(GeneratedsSuper):
    """Informações de exportação"""
    subclass = None
    superclass = None
    def __init__(self, UFSaidaPais=None, xLocExporta=None, xLocDespacho=None):
        self.original_tagname_ = None
        self.UFSaidaPais = UFSaidaPais
        self.validate_TUfEmi(self.UFSaidaPais)
        self.xLocExporta = xLocExporta
        self.validate_xLocExportaType(self.xLocExporta)
        self.xLocDespacho = xLocDespacho
        self.validate_xLocDespachoType(self.xLocDespacho)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exportaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exportaType.subclass:
            return exportaType.subclass(*args_, **kwargs_)
        else:
            return exportaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {"value" : value.encode("utf-8")} )
    def validate_xLocExportaType(self, value):
        # Validate type xLocExportaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLocExportaType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLocExportaType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLocExportaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLocExportaType_patterns_, ))
    validate_xLocExportaType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xLocDespachoType(self, value):
        # Validate type xLocDespachoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLocDespachoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLocDespachoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLocDespachoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLocDespachoType_patterns_, ))
    validate_xLocDespachoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.UFSaidaPais is not None or
            self.xLocExporta is not None or
            self.xLocDespacho is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exportaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exportaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exportaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exportaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exportaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='exportaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UFSaidaPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UFSaidaPais>%s</UFSaidaPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UFSaidaPais), input_name='UFSaidaPais')), eol_))
        if self.xLocExporta is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLocExporta>%s</xLocExporta>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLocExporta), input_name='xLocExporta')), eol_))
        if self.xLocDespacho is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLocDespacho>%s</xLocDespacho>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLocDespacho), input_name='xLocDespacho')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UFSaidaPais':
            UFSaidaPais_ = child_.text
            UFSaidaPais_ = self.gds_validate_string(UFSaidaPais_, node, 'UFSaidaPais')
            self.UFSaidaPais = UFSaidaPais_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UFSaidaPais)
        elif nodeName_ == 'xLocExporta':
            xLocExporta_ = child_.text
            xLocExporta_ = self.gds_validate_string(xLocExporta_, node, 'xLocExporta')
            self.xLocExporta = xLocExporta_
            # validate type xLocExportaType
            self.validate_xLocExportaType(self.xLocExporta)
        elif nodeName_ == 'xLocDespacho':
            xLocDespacho_ = child_.text
            xLocDespacho_ = self.gds_validate_string(xLocDespacho_, node, 'xLocDespacho')
            self.xLocDespacho = xLocDespacho_
            # validate type xLocDespachoType
            self.validate_xLocDespachoType(self.xLocDespacho)
# end class exportaType


class compraType(GeneratedsSuper):
    """Informações de compras  (Nota de Empenho, Pedido e Contrato)"""
    subclass = None
    superclass = None
    def __init__(self, xNEmp=None, xPed=None, xCont=None):
        self.original_tagname_ = None
        self.xNEmp = xNEmp
        self.validate_xNEmpType(self.xNEmp)
        self.xPed = xPed
        self.validate_xPedType52(self.xPed)
        self.xCont = xCont
        self.validate_xContType(self.xCont)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, compraType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if compraType.subclass:
            return compraType.subclass(*args_, **kwargs_)
        else:
            return compraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_xNEmpType(self, value):
        # Validate type xNEmpType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 22:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNEmpType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNEmpType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNEmpType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNEmpType_patterns_, ))
    validate_xNEmpType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xPedType52(self, value):
        # Validate type xPedType52, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xPedType52' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xPedType52' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xPedType52_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xPedType52_patterns_, ))
    validate_xPedType52_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xContType(self, value):
        # Validate type xContType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xContType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xContType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xContType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xContType_patterns_, ))
    validate_xContType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.xNEmp is not None or
            self.xPed is not None or
            self.xCont is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='compraType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('compraType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='compraType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='compraType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='compraType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='compraType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xNEmp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNEmp>%s</xNEmp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNEmp), input_name='xNEmp')), eol_))
        if self.xPed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xPed>%s</xPed>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xPed), input_name='xPed')), eol_))
        if self.xCont is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xCont>%s</xCont>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xCont), input_name='xCont')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xNEmp':
            xNEmp_ = child_.text
            xNEmp_ = self.gds_validate_string(xNEmp_, node, 'xNEmp')
            self.xNEmp = xNEmp_
            # validate type xNEmpType
            self.validate_xNEmpType(self.xNEmp)
        elif nodeName_ == 'xPed':
            xPed_ = child_.text
            xPed_ = self.gds_validate_string(xPed_, node, 'xPed')
            self.xPed = xPed_
            # validate type xPedType52
            self.validate_xPedType52(self.xPed)
        elif nodeName_ == 'xCont':
            xCont_ = child_.text
            xCont_ = self.gds_validate_string(xCont_, node, 'xCont')
            self.xCont = xCont_
            # validate type xContType
            self.validate_xContType(self.xCont)
# end class compraType


class canaType(GeneratedsSuper):
    """Informações de registro aquisições de cana"""
    subclass = None
    superclass = None
    def __init__(self, safra=None, ref=None, forDia=None, qTotMes=None, qTotAnt=None, qTotGer=None, deduc=None, vFor=None, vTotDed=None, vLiqFor=None):
        self.original_tagname_ = None
        self.safra = safra
        self.validate_safraType(self.safra)
        self.ref = ref
        self.validate_refType(self.ref)
        if forDia is None:
            self.forDia = []
        else:
            self.forDia = forDia
        self.qTotMes = qTotMes
        self.validate_TDec_1110v(self.qTotMes)
        self.qTotAnt = qTotAnt
        self.validate_TDec_1110v(self.qTotAnt)
        self.qTotGer = qTotGer
        self.validate_TDec_1110v(self.qTotGer)
        if deduc is None:
            self.deduc = []
        else:
            self.deduc = deduc
        self.vFor = vFor
        self.validate_TDec_1302(self.vFor)
        self.vTotDed = vTotDed
        self.validate_TDec_1302(self.vTotDed)
        self.vLiqFor = vLiqFor
        self.validate_TDec_1302(self.vLiqFor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, canaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if canaType.subclass:
            return canaType.subclass(*args_, **kwargs_)
        else:
            return canaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_safraType(self, value):
        # Validate type safraType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on safraType' % {"value" : value} )
            if len(str(value)) < 4:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on safraType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_safraType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_safraType_patterns_, ))
    validate_safraType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_refType(self, value):
        # Validate type refType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_refType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_refType_patterns_, ))
    validate_refType_patterns_ = [['^(0[1-9]$|^1[0-2])([/][2][0-9][0-9][0-9])$']]
    def validate_TDec_1110v(self, value):
        # Validate type TDec_1110v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1110v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1110v_patterns_, ))
    validate_TDec_1110v_patterns_ = [['^0$|^0\\.[0-9]{1,10}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,10})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.safra is not None or
            self.ref is not None or
            self.forDia or
            self.qTotMes is not None or
            self.qTotAnt is not None or
            self.qTotGer is not None or
            self.deduc or
            self.vFor is not None or
            self.vTotDed is not None or
            self.vLiqFor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='canaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('canaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='canaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='canaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='canaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='canaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.safra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<safra>%s</safra>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.safra), input_name='safra')), eol_))
        if self.ref is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ref>%s</ref>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ref), input_name='ref')), eol_))
        for forDia_ in self.forDia:
            forDia_.export(outfile, level, namespace_, name_='forDia', pretty_print=pretty_print)
        if self.qTotMes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qTotMes>%s</qTotMes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qTotMes), input_name='qTotMes')), eol_))
        if self.qTotAnt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qTotAnt>%s</qTotAnt>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qTotAnt), input_name='qTotAnt')), eol_))
        if self.qTotGer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qTotGer>%s</qTotGer>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qTotGer), input_name='qTotGer')), eol_))
        for deduc_ in self.deduc:
            deduc_.export(outfile, level, namespace_, name_='deduc', pretty_print=pretty_print)
        if self.vFor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vFor>%s</vFor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vFor), input_name='vFor')), eol_))
        if self.vTotDed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vTotDed>%s</vTotDed>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vTotDed), input_name='vTotDed')), eol_))
        if self.vLiqFor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vLiqFor>%s</vLiqFor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vLiqFor), input_name='vLiqFor')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'safra':
            safra_ = child_.text
            safra_ = self.gds_validate_string(safra_, node, 'safra')
            self.safra = safra_
            # validate type safraType
            self.validate_safraType(self.safra)
        elif nodeName_ == 'ref':
            ref_ = child_.text
            ref_ = self.gds_validate_string(ref_, node, 'ref')
            self.ref = ref_
            # validate type refType
            self.validate_refType(self.ref)
        elif nodeName_ == 'forDia':
            obj_ = forDiaType.factory()
            obj_.build(child_)
            self.forDia.append(obj_)
            obj_.original_tagname_ = 'forDia'
        elif nodeName_ == 'qTotMes':
            qTotMes_ = child_.text
            qTotMes_ = self.gds_validate_string(qTotMes_, node, 'qTotMes')
            self.qTotMes = qTotMes_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qTotMes)
        elif nodeName_ == 'qTotAnt':
            qTotAnt_ = child_.text
            qTotAnt_ = self.gds_validate_string(qTotAnt_, node, 'qTotAnt')
            self.qTotAnt = qTotAnt_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qTotAnt)
        elif nodeName_ == 'qTotGer':
            qTotGer_ = child_.text
            qTotGer_ = self.gds_validate_string(qTotGer_, node, 'qTotGer')
            self.qTotGer = qTotGer_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qTotGer)
        elif nodeName_ == 'deduc':
            obj_ = deducType.factory()
            obj_.build(child_)
            self.deduc.append(obj_)
            obj_.original_tagname_ = 'deduc'
        elif nodeName_ == 'vFor':
            vFor_ = child_.text
            vFor_ = self.gds_validate_string(vFor_, node, 'vFor')
            self.vFor = vFor_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFor)
        elif nodeName_ == 'vTotDed':
            vTotDed_ = child_.text
            vTotDed_ = self.gds_validate_string(vTotDed_, node, 'vTotDed')
            self.vTotDed = vTotDed_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTotDed)
        elif nodeName_ == 'vLiqFor':
            vLiqFor_ = child_.text
            vLiqFor_ = self.gds_validate_string(vLiqFor_, node, 'vLiqFor')
            self.vLiqFor = vLiqFor_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vLiqFor)
# end class canaType


class forDiaType(GeneratedsSuper):
    """Fornecimentos diários"""
    subclass = None
    superclass = None
    def __init__(self, dia=None, qtde=None):
        self.original_tagname_ = None
        self.dia = _cast(None, dia)
        self.qtde = qtde
        self.validate_TDec_1110v(self.qtde)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, forDiaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if forDiaType.subclass:
            return forDiaType.subclass(*args_, **kwargs_)
        else:
            return forDiaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TDec_1110v(self, value):
        # Validate type TDec_1110v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1110v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1110v_patterns_, ))
    validate_TDec_1110v_patterns_ = [['^0$|^0\\.[0-9]{1,10}$|^[1-9]{1}[0-9]{0,10}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,10})?$']]
    def hasContent_(self):
        if (
            self.qtde is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='forDiaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('forDiaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='forDiaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='forDiaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='forDiaType'):
        if self.dia is not None and 'dia' not in already_processed:
            already_processed.add('dia')
            outfile.write(' dia=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dia), input_name='dia')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='forDiaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qtde is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qtde>%s</qtde>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qtde), input_name='qtde')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dia', node)
        if value is not None and 'dia' not in already_processed:
            already_processed.add('dia')
            self.dia = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qtde':
            qtde_ = child_.text
            qtde_ = self.gds_validate_string(qtde_, node, 'qtde')
            self.qtde = qtde_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qtde)
# end class forDiaType


class deducType(GeneratedsSuper):
    """Deduções - Taxas e Contribuições"""
    subclass = None
    superclass = None
    def __init__(self, xDed=None, vDed=None):
        self.original_tagname_ = None
        self.xDed = xDed
        self.validate_xDedType(self.xDed)
        self.vDed = vDed
        self.validate_TDec_1302(self.vDed)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, deducType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if deducType.subclass:
            return deducType.subclass(*args_, **kwargs_)
        else:
            return deducType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_xDedType(self, value):
        # Validate type xDedType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xDedType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xDedType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xDedType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xDedType_patterns_, ))
    validate_xDedType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.xDed is not None or
            self.vDed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='deducType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('deducType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='deducType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='deducType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='deducType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='deducType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xDed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xDed>%s</xDed>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xDed), input_name='xDed')), eol_))
        if self.vDed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vDed>%s</vDed>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vDed), input_name='vDed')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xDed':
            xDed_ = child_.text
            xDed_ = self.gds_validate_string(xDed_, node, 'xDed')
            self.xDed = xDed_
            # validate type xDedType
            self.validate_xDedType(self.xDed)
        elif nodeName_ == 'vDed':
            vDed_ = child_.text
            vDed_ = self.gds_validate_string(vDed_, node, 'vDed')
            self.vDed = vDed_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDed)
# end class deducType


class infNFeSuplType(GeneratedsSuper):
    """Informações suplementares Nota Fiscal"""
    subclass = None
    superclass = None
    def __init__(self, qrCode=None, urlChave=None):
        self.original_tagname_ = None
        self.qrCode = qrCode
        self.validate_qrCodeType(self.qrCode)
        self.urlChave = urlChave
        self.validate_urlChaveType(self.urlChave)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFeSuplType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFeSuplType.subclass:
            return infNFeSuplType.subclass(*args_, **kwargs_)
        else:
            return infNFeSuplType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_qrCodeType(self, value):
        # Validate type qrCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 600:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on qrCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 100:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on qrCodeType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_qrCodeType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qrCodeType_patterns_, ))
    validate_qrCodeType_patterns_ = [['^(((HTTPS?$|^https?)://.*\\?chNFe=[0-9]{44}&nVersao=100&tpAmb=[1-2](&cDest=([A-Za-z0-9.:+-/)(]{0}$|^[A-Za-z0-9.:+-/)(]{5,20})?)?&dhEmi=[A-Fa-f0-9]{50}&vNF=(0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)&vICMS=(0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)&digVal=[A-Fa-f0-9]{56}&cIdToken=[0-9]{6}&cHashQRCode=[A-Fa-f0-9]{40})$|^((HTTPS?$|^https?)://.*\\?p=([0-9]{34}(1$|^4)[0-9]{9})\\|[2]\\|[1-2]\\|(0$|^[1-9]{1}([0-9]{1,5})?)\\|[A-Fa-f0-9]{40})$|^((HTTPS?$|^https?)://.*\\?p=([0-9]{34}9[0-9]{9})\\|[2]\\|[1-2]\\|([0]{1}[1-9]{1}$|^[1-2]{1}[0-9]{1}$|^[3]{1}[0-1]{1})\\|(0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)\\|[A-Fa-f0-9]{56}\\|(0$|^[1-9]{1}([0-9]{1,5})?)\\|[A-Fa-f0-9]{40}))$']]
    def validate_urlChaveType(self, value):
        # Validate type urlChaveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 85:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on urlChaveType' % {"value" : value.encode("utf-8")} )
            if len(value) < 21:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on urlChaveType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.qrCode is not None or
            self.urlChave is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infNFeSuplType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFeSuplType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infNFeSuplType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infNFeSuplType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infNFeSuplType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infNFeSuplType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qrCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qrCode>%s</qrCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qrCode), input_name='qrCode')), eol_))
        if self.urlChave is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<urlChave>%s</urlChave>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.urlChave), input_name='urlChave')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qrCode':
            qrCode_ = child_.text
            qrCode_ = self.gds_validate_string(qrCode_, node, 'qrCode')
            self.qrCode = qrCode_
            # validate type qrCodeType
            self.validate_qrCodeType(self.qrCode)
        elif nodeName_ == 'urlChave':
            urlChave_ = child_.text
            urlChave_ = self.gds_validate_string(urlChave_, node, 'urlChave')
            self.urlChave = urlChave_
            # validate type urlChaveType
            self.validate_urlChaveType(self.urlChave)
# end class infNFeSuplType


class infProtType(GeneratedsSuper):
    """Dados do protocolo de status"""
    subclass = None
    superclass = None
    def __init__(self, Id=None, tpAmb=None, verAplic=None, chNFe=None, dhRecbto=None, nProt=None, digVal=None, cStat=None, xMotivo=None, cMsg=None, xMsg=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.chNFe = chNFe
        self.validate_TChNFe(self.chNFe)
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.nProt = nProt
        self.validate_TProt(self.nProt)
        self.digVal = digVal
        self.validate_DigestValueType(self.digVal)
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.cMsg = cMsg
        self.validate_cMsgType(self.cMsg)
        self.xMsg = xMsg
        self.validate_xMsgType(self.xMsg)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infProtType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infProtType.subclass:
            return infProtType.subclass(*args_, **kwargs_)
        else:
            return infProtType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {"value" : value.encode("utf-8")} )
    def validate_TVerAplic(self, value):
        # Validate type TVerAplic, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TVerAplic' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TVerAplic' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerAplic_patterns_, ))
    validate_TVerAplic_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [['^[0-9]{44}$']]
    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))T(20$|^21$|^22$|^23$|^[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]$|^10$|^11):00$|^([\\+](12):00))$']]
    def validate_TProt(self, value):
        # Validate type TProt, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TProt' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TProt_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TProt_patterns_, ))
    validate_TProt_patterns_ = [['^[0-9]{15}$']]
    def validate_DigestValueType(self, value):
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_TStat(self, value):
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TStat' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TStat_patterns_, ))
    validate_TStat_patterns_ = [['^[0-9]{3}$']]
    def validate_TMotivo(self, value):
        # Validate type TMotivo, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TMotivo' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TMotivo' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TMotivo_patterns_, ))
    validate_TMotivo_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_cMsgType(self, value):
        # Validate type cMsgType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cMsgType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cMsgType_patterns_, ))
    validate_cMsgType_patterns_ = [['^[0-9]{1,4}$']]
    def validate_xMsgType(self, value):
        # Validate type xMsgType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 200:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMsgType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMsgType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMsgType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMsgType_patterns_, ))
    validate_xMsgType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.chNFe is not None or
            self.dhRecbto is not None or
            self.nProt is not None or
            self.digVal is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.cMsg is not None or
            self.xMsg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infProtType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infProtType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infProtType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infProtType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infProtType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='infProtType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpAmb>%s</tpAmb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<verAplic>%s</verAplic>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), eol_))
        if self.chNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<chNFe>%s</chNFe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.chNFe), input_name='chNFe')), eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dhRecbto>%s</dhRecbto>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), eol_))
        if self.nProt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nProt>%s</nProt>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nProt), input_name='nProt')), eol_))
        if self.digVal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<digVal>%s</digVal>%s' % (self.gds_format_base64(self.digVal, input_name='digVal'), eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cStat>%s</cStat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMotivo>%s</xMotivo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), eol_))
        if self.cMsg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMsg>%s</cMsg>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMsg), input_name='cMsg')), eol_))
        if self.xMsg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMsg>%s</xMsg>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMsg), input_name='xMsg')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'chNFe':
            chNFe_ = child_.text
            chNFe_ = self.gds_validate_string(chNFe_, node, 'chNFe')
            self.chNFe = chNFe_
            # validate type TChNFe
            self.validate_TChNFe(self.chNFe)
        elif nodeName_ == 'dhRecbto':
            dhRecbto_ = child_.text
            dhRecbto_ = self.gds_validate_string(dhRecbto_, node, 'dhRecbto')
            self.dhRecbto = dhRecbto_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'nProt':
            nProt_ = child_.text
            nProt_ = self.gds_validate_string(nProt_, node, 'nProt')
            self.nProt = nProt_
            # validate type TProt
            self.validate_TProt(self.nProt)
        elif nodeName_ == 'digVal':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'digVal')
            else:
                bval_ = None
            self.digVal = bval_
            # validate type DigestValueType
            self.validate_DigestValueType(self.digVal)
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'cMsg':
            cMsg_ = child_.text
            cMsg_ = self.gds_validate_string(cMsg_, node, 'cMsg')
            self.cMsg = cMsg_
            # validate type cMsgType
            self.validate_cMsgType(self.cMsg)
        elif nodeName_ == 'xMsg':
            xMsg_ = child_.text
            xMsg_ = self.gds_validate_string(xMsg_, node, 'xMsg')
            self.xMsg = xMsg_
            # validate type xMsgType
            self.validate_xMsgType(self.xMsg)
# end class infProtType


class infRecType(GeneratedsSuper):
    """Dados do Recibo do Lote"""
    subclass = None
    superclass = None
    def __init__(self, nRec=None, tMed=None):
        self.original_tagname_ = None
        self.nRec = nRec
        self.validate_TRec(self.nRec)
        self.tMed = tMed
        self.validate_TMed(self.tMed)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infRecType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infRecType.subclass:
            return infRecType.subclass(*args_, **kwargs_)
        else:
            return infRecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TRec(self, value):
        # Validate type TRec, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TRec' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TRec_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TRec_patterns_, ))
    validate_TRec_patterns_ = [['^[0-9]{15}$']]
    def validate_TMed(self, value):
        # Validate type TMed, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TMed_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TMed_patterns_, ))
    validate_TMed_patterns_ = [['^[0-9]{1,4}$']]
    def hasContent_(self):
        if (
            self.nRec is not None or
            self.tMed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infRecType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infRecType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infRecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infRecType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infRecType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infRecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nRec>%s</nRec>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nRec), input_name='nRec')), eol_))
        if self.tMed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tMed>%s</tMed>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tMed), input_name='tMed')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
            # validate type TRec
            self.validate_TRec(self.nRec)
        elif nodeName_ == 'tMed':
            tMed_ = child_.text
            tMed_ = self.gds_validate_string(tMed_, node, 'tMed')
            self.tMed = tMed_
            # validate type TMed
            self.validate_TMed(self.tMed)
# end class infRecType


class IPITribType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pIPI=None, qUnid=None, vUnid=None, vIPI=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType80(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pIPI = pIPI
        self.validate_TDec_0302a04(self.pIPI)
        self.qUnid = qUnid
        self.validate_TDec_1204v(self.qUnid)
        self.vUnid = vUnid
        self.validate_TDec_1104(self.vUnid)
        self.vIPI = vIPI
        self.validate_TDec_1302(self.vIPI)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPITribType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPITribType.subclass:
            return IPITribType.subclass(*args_, **kwargs_)
        else:
            return IPITribType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CSTType80(self, value):
        # Validate type CSTType80, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['00', '49', '50', '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType80' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [['^0$|^0\\.[0-9]{2,4}$|^[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [['^0$|^0\\.[0-9]{1,4}$|^[1-9]{1}[0-9]{0,11}$|^[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [['^0$|^0\\.[0-9]{4}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pIPI is not None or
            self.qUnid is not None or
            self.vUnid is not None or
            self.vIPI is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPITribType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPITribType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPITribType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPITribType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPITribType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IPITribType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vBC>%s</vBC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), eol_))
        if self.pIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pIPI>%s</pIPI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pIPI), input_name='pIPI')), eol_))
        if self.qUnid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qUnid>%s</qUnid>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qUnid), input_name='qUnid')), eol_))
        if self.vUnid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vUnid>%s</vUnid>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vUnid), input_name='vUnid')), eol_))
        if self.vIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vIPI>%s</vIPI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vIPI), input_name='vIPI')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType80
            self.validate_CSTType80(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pIPI':
            pIPI_ = child_.text
            pIPI_ = self.gds_validate_string(pIPI_, node, 'pIPI')
            self.pIPI = pIPI_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pIPI)
        elif nodeName_ == 'qUnid':
            qUnid_ = child_.text
            qUnid_ = self.gds_validate_string(qUnid_, node, 'qUnid')
            self.qUnid = qUnid_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qUnid)
        elif nodeName_ == 'vUnid':
            vUnid_ = child_.text
            vUnid_ = self.gds_validate_string(vUnid_, node, 'vUnid')
            self.vUnid = vUnid_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vUnid)
        elif nodeName_ == 'vIPI':
            vIPI_ = child_.text
            vIPI_ = self.gds_validate_string(vIPI_, node, 'vIPI')
            self.vIPI = vIPI_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPI)
# end class IPITribType


class IPINTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None):
        self.original_tagname_ = None
        self.CST = CST
        self.validate_CSTType81(self.CST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPINTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPINTType.subclass:
            return IPINTType.subclass(*args_, **kwargs_)
        else:
            return IPINTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CSTType81(self, value):
        # Validate type CSTType81, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02', '03', '04', '05', '51', '52', '53', '54', '55']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType81' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPINTType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPINTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPINTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPINTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPINTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IPINTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CST>%s</CST>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType81
            self.validate_CSTType81(self.CST)
# end class IPINTType


class CanonicalizationMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanonicalizationMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanonicalizationMethodType.subclass:
            return CanonicalizationMethodType.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CanonicalizationMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CanonicalizationMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CanonicalizationMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CanonicalizationMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CanonicalizationMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CanonicalizationMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CanonicalizationMethodType


class SignatureMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureMethodType.subclass:
            return SignatureMethodType.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignatureMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignatureMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignatureMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignatureMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureMethodType


class DigestMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestMethodType.subclass:
            return DigestMethodType.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DigestMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DigestMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DigestMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DigestMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DigestMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DigestMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DigestMethodType


GDSClassesMapping = {
    'Signature': SignatureType,
    'retConsReciNFe': TRetConsReciNFe,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TRetConsReciNFe'
        rootClass = TRetConsReciNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TRetConsReciNFe'
        rootClass = TRetConsReciNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TRetConsReciNFe'
        rootClass = TRetConsReciNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TRetConsReciNFe'
        rootClass = TRetConsReciNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from retConsReciNFe import *\n\n')
        sys.stdout.write('import retConsReciNFe as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CIDEType",
    "COFINSAliqType",
    "COFINSNTType",
    "COFINSOutrType",
    "COFINSQtdeType",
    "COFINSSTType",
    "COFINSType",
    "CanonicalizationMethodType",
    "DIType",
    "DigestMethodType",
    "ICMS00Type",
    "ICMS10Type",
    "ICMS20Type",
    "ICMS30Type",
    "ICMS40Type",
    "ICMS51Type",
    "ICMS60Type",
    "ICMS70Type",
    "ICMS90Type",
    "ICMSPartType",
    "ICMSSN101Type",
    "ICMSSN102Type",
    "ICMSSN201Type",
    "ICMSSN202Type",
    "ICMSSN500Type",
    "ICMSSN900Type",
    "ICMSSTType",
    "ICMSTotType",
    "ICMSType",
    "ICMSUFDestType",
    "IIType",
    "IPINTType",
    "IPITribType",
    "IPIType",
    "ISSQNType",
    "ISSQNtotType",
    "KeyInfoType",
    "NFrefType",
    "PISAliqType",
    "PISNTType",
    "PISOutrType",
    "PISQtdeType",
    "PISSTType",
    "PISType",
    "ReferenceType",
    "SignatureMethodType",
    "SignatureType",
    "SignatureValueType",
    "SignedInfoType",
    "TConsReciNFe",
    "TEnderEmi",
    "TEndereco",
    "TEnviNFe",
    "TInfRespTec",
    "TIpi",
    "TLocal",
    "TNFe",
    "TNfeProc",
    "TProtNFe",
    "TRetConsReciNFe",
    "TRetEnviNFe",
    "TVeiculo",
    "TransformType",
    "TransformsType",
    "X509DataType",
    "adiType",
    "armaType",
    "autXMLType",
    "avulsaType",
    "canaType",
    "cardType",
    "cobrType",
    "combType",
    "compraType",
    "deducType",
    "destType",
    "detExportType",
    "detPagType",
    "detType",
    "dupType",
    "emitType",
    "encerranteType",
    "exportIndType",
    "exportaType",
    "fatType",
    "forDiaType",
    "ideType",
    "impostoDevolType",
    "impostoType",
    "infAdicType",
    "infNFeSuplType",
    "infNFeType",
    "infProtType",
    "infRecType",
    "lacresType",
    "medType",
    "obsContType",
    "obsFiscoType",
    "pagType",
    "procRefType",
    "prodType",
    "rastroType",
    "refECFType",
    "refNFPType",
    "refNFType",
    "retTranspType",
    "retTribType",
    "totalType",
    "transpType",
    "transportaType",
    "veicProdType",
    "volType"
]
